{"meta":{"title":"ZhongLeiDev","subtitle":"不忘初心，方得始终","description":"","author":"ZhongLeiDev","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-11-20T05:49:45.000Z","updated":"2019-11-23T06:17:52.477Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"ZhongLeiDev don't worry, be happy~ 这个家伙很懒，什么都没有写(o°ω°o) ~"},{"title":"相册初始化页面","date":"2019-11-20T05:49:45.000Z","updated":"2019-11-20T08:03:58.137Z","comments":true,"path":"albums/index.html","permalink":"http://yoursite.com/albums/index.html","excerpt":"","text":""},{"title":"读后感始化页面","date":"2019-11-19T01:03:22.000Z","updated":"2019-11-20T08:00:00.077Z","comments":true,"path":"bookreading/index.html","permalink":"http://yoursite.com/bookreading/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-11-20T06:14:16.000Z","updated":"2019-11-20T07:44:12.933Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-11-20T07:43:27.000Z","updated":"2019-11-20T07:45:00.917Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"感悟初始化页面","date":"2019-11-20T05:46:06.000Z","updated":"2019-11-20T08:02:42.602Z","comments":true,"path":"thinking/index.html","permalink":"http://yoursite.com/thinking/index.html","excerpt":"","text":""},{"title":"写作初始化页面","date":"2019-11-19T01:04:14.000Z","updated":"2019-11-20T08:50:19.226Z","comments":true,"path":"writing/index.html","permalink":"http://yoursite.com/writing/index.html","excerpt":"","text":""}],"posts":[{"title":"《EffectiveJava》（五）","slug":"EffectiveJava4","date":"2019-11-23T09:10:09.000Z","updated":"2019-11-23T09:11:28.553Z","comments":true,"path":"2019/11/23/EffectiveJava4/","link":"","permalink":"http://yoursite.com/2019/11/23/EffectiveJava4/","excerpt":"【68】executor 和 task 优先于线程创建工作队列： 12345ExecutorService executor = Executors.newSingleThreadExecutor()；executor.execute(runnable)；//执行提交一个 runnable 方法executor.shutdown()；//优雅地终止","text":"【68】executor 和 task 优先于线程创建工作队列： 12345ExecutorService executor = Executors.newSingleThreadExecutor()；executor.execute(runnable)；//执行提交一个 runnable 方法executor.shutdown()；//优雅地终止 如果编写的是小程序，或者是轻载的服务器，使用 Executors.newCachedThreadPool 通常是个不错的选择，因为它不需要配置，并且在一般的情况下能够正确的完成工作。但在大负载的产品服务其中，最好使用 Executors.newFixedThreadPool，它为你提供了一个包含固定线程数目的线程池，或者为了最大限度地控制它，就直接使用 ThreadPoolExecutor。 ScheduledThradPoolExecutor 是用来代替 java.util.Timer 的东西。timer 只用一个线程来执行任务，这在面对长期运行的任务时，会影响到定时的准确性。如果 timer 唯一的线程抛出未被捕获的异常，timer 就会停止执行。被调度的线程池 executor 支持多个线程，并优雅地从抛出未受检异常的任务中恢复。 【69】并发工具优先于 wait 和 notify在并发情境中，除非不得以，否则应该优先使用 ConcurrentHashMap，而不是使用 Collection.-synchronizedMap 或者 Hashtable。只要用并发 Map 替换老式的同步 Map，就可以极大的提升并发应用程序的性能。更一般地，应该优先使用并发集合，而不是使用外部同步集合。 同步器是一些使线程能够等待另一个线程的对象，允许他们协调动作。最常用的同步器是 Count-DownLatch 和 Semaphore，较不常用的是 CyclicBarrier 和 Exchanger。 倒计数锁存器（CountDownLatch）是一次性的障碍，允许一个或者多个线程等待一个或者其它线程来做某些事情。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ConcurrentTimer &#123; private ConcurrentTimer() &#123; &#125; // Noninstantiable public static long time(Executor executor, int concurrency, final Runnable action) throws InterruptedException &#123; final CountDownLatch ready = new CountDownLatch(concurrency); final CountDownLatch start = new CountDownLatch(1); final CountDownLatch done = new CountDownLatch(concurrency); for (int i = 0; i &lt; concurrency; i++) &#123; executor.execute(new Runnable() &#123; public void run() &#123; ready.countDown(); // Tell timer we're ready try &#123; start.await(); // Wait till peers are ready action.run(); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; finally &#123; done.countDown(); // Tell timer we're done &#125; &#125; &#125;); &#125; ready.await(); // Wait for all workers to be ready long startNanos = System.nanoTime(); start.countDown(); // And they're off! done.await(); // Wait for all workers to finish return System.nanoTime() - startNanos; &#125;&#125; 对于间歇式的定时，始终应该优先使用 System.nanoTime，而不是使用 System.currentTime-Mills。System.nanoTime 更加准确也更加精确，它不受系统的实时时钟的调整所影响。 使用 wait 方法的标准模式： 1234567891011synchronized (obj) &#123; while (&lt;condition does not hold&gt;) &#123; obj.wait()；// (Release lock，and reacquires on wakeup) ... // Perform action appropriate to condition &#125;&#125; 简而言之，直接使用 wait 和 notify 就像用 “并发汇编语言” 进行编程一样，而 java.util.concurr-ent则提供了更高级的语言。没有理由在新代码中使用 wait 和 notify，即使有，也是极少的。如果你在维护使用 wait 和 notify 的代码，务必确保始终是利用标准的模式从 while 循环的内部调用 wait。一般情况下，你应该优先使用 notifyAll，而不是使用 notify。如果使用 notify，请一定要小心，以确保程序的活性。 【70】线程安全性的文档化线程安全性的级别： 1.不可变的（immutable）——这个类的实力是不可变的。所以不需要外部的同步。这样的例子包括 String、Long 和 BigInteger。 2.无条件的线程安全（unconditionally thread-safe）——这个类的实例是可变的，但是这个类有着足够的内部同步，所以它的实例可以被并发使用而无需任何外部同步。其例子包括 Random 和 Co-ncurrentHashMap。 3.有条件的线程安全（conditionally thread-safe）——除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件线程安全相同。这样的例子包括 Collection.synchroni-zed 包装返回的集合，它的迭代器要求外部同步。 4.非线程安全（not thread-safe）——这个类的实例是可变的。为了并发的使用他们，客户必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如 ArrayList 和 HashMap。 5.线程对立的（thread-hostile）——这个类不能安全的被多个线程并发使用，即使所有的方法调用都被外部同步包围。在 Java 平台类库中，线程对立的类或者方法非常少。System.runFinalizers-OnExit 方法是线程对立的，但已经被废除了。 私有锁对象： 1234567891011private final Object lock = new Object()； public void foo() &#123; synchronized(lock) &#123; ... &#125;&#125; 私有锁对象不能被这个类的客户端程序所访问，所以它们不可能妨碍对象的同步。 简而言之，每个类都应该利用详细的说明或者线程安全注解，清楚地在文档中说明它的线程安全属性。synchronized 修饰符与这个文档毫无关系。有条件的线程安全类必须在文档中指明“哪个方法调用序列需要外部同步，以及在执行这些序列的时候要获得哪把锁”。如果你编写的是无条件的线程安全类，就应该考虑使用私有的锁对象来代替同步的方法。这样可以防止客户端程序和子类的不同步干扰，让你能够在后续的版本中灵活地对并发控制采用更加复杂的方法。 【71】慎用延迟初始化延迟初始化（lazy initialization）是延迟到需要的域的值时才将它初始化的这种行为。在大多数情况下，正常的初始化要优先于延迟初始化。 正常初始化： 1private final FieldType field = computeFieldValue()； 利用延迟优化来破坏初始化的循环，就要使用同步访问方法： 12345678910111213private FieldType field；synchronized FieldType getField() &#123; if (field == null) &#123; field = computeFieldValue()； &#125; return field；&#125; 如果出于性能的考虑而需要对静态域使用延迟初始化，就使用 lazy initialization holder class 模式： 1234567private static class FieldHolder &#123; static final FieldType field = computeFieldValue()；&#125;static FieldType getField() &#123; return **FieldHolder.field**；&#125; 如果出于性能的考虑而需要对实例域使用延迟初始化，就使用双重检查模式（double check idiom）： 12345678910111213141516171819202122232425private volatile FieldType field；FieldType getField() &#123; FieldType result = field； if (result == null) &#123; // First check (no locking) synchronized(this) &#123; result = field； if (result == null) &#123; // Second check (with locking) field = result = computeFieldValue()； &#125; &#125; &#125; return result；&#125; 如果需要延迟初始化一个可以接受重复初始化的实例域，就可以使用单重检查模式： 123456789101112131415private volatile FieldType field；FieldType getField() &#123; FieldType result = field； if (result == null) &#123; // single check field = result = computeFieldValue()； &#125; return result；&#125; 简而言之，大多数的域应该正常的进行初始化，而不是延迟初始化。如果为了达到性能目标，或者为了破坏有害的初始化循环，而必须延迟初始化一个域，就可以使用相应的延迟初始化方法。对于实例域，就使用双重检查模式；对于静态域，则使用 lazy initialization holder class idiom。对于可以接受重复初始化的实例域，也可以考虑单重检查模式。 【72】不要依赖于线程调度器任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的。要编写健壮的、可移植的多线程应用程序，最好的办法是确保可运行线程的平均数量不明显多于处理器的数量。保持可运行线程数量尽可能少的主要方法是，让每个线程做些有意义的工作，然后等待更多有意义的工作。如果线程没有在做有意义的工作，就不应该运行。 对于大多数程序员来说，Thread.yield 的唯一用途是在测试期间人为地增加程序的并发性。但是它从来不能保证一定可行。因此，应该使用 Thread.sleep(1) 代替 Thread.yield 来进行并发测试。 简而言之，不要让应用程序的正确性依赖于线程调度器。否则结果得到的应用程序将既不健壮，也不具有可移植性。作为推论，不要依赖于 Thread.yield 或者线程优先级。这些设施仅仅对调度器做些暗示。线程优先级可以用来提高一个已经能够正常工作的程序的服务质量，但永远不应该用来“修正”一个原本不能工作的程序。 【73】避免使用线程组我们最好把线程组看作是一个不成功的试验，你可以忽略它们，就当它们更笨不存在一样。 十二、序列化： 【74】谨慎地实现 Serializable 接口对象序列化提供了一个框架，用来将对象编码成字节流，并从字节流编码中重新构建对象。对象被序列化后，它的编码就可以从一台正在运行的虚拟机被传递到另一台虚拟机上，或者被存储到磁盘上。实现序列化的代价有： (1)实现 Serializable 接口而付出最大的代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。 序列化会使类的演变受到限制，这种限制的一个例子与流的唯一标识符有关，通常也被称为序列版本 UID。如果没有现实的指定这个 UID，系统会自动生成该标识号，它的值与类的各个部分都有着复杂的关系，如果类改变，这个 UID 也会跟着改变，结果就会出现兼容性问题。 (2)第二个代价是，它增加了出现 BUG 和安全漏洞的可能性。 (3)第三个代价是，随着类发行新的版本，相关的测试负担也增加了。 根据经验，比如 Date 和 BigInteger 这样的值应该实现 Serializable，大多数的集合类也应该如此。代表活动的实体类，比如线程池，一般不应该实现 Serializable。 为了继承而设计的类应该尽可能地少地去实现 Serializable 接口，用户的接口也应该尽可能少的继承 Serializable 接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.concurrent.atomic.*;public abstract class AbstractFoo &#123; private int x, y; // Our state // This enum and field are used to track initialization private enum State &#123; NEW, INITIALIZING, INITIALIZED &#125;; private final AtomicReference&lt;State&gt; init = new AtomicReference&lt;State&gt;(State.NEW); public AbstractFoo(int x, int y) &#123; initialize(x, y); &#125; // This constructor and the following method allow // subclass's readObject method to initialize our state. protected AbstractFoo() &#123; &#125; protected final void initialize(int x, int y) &#123; if (!init.compareAndSet(State.NEW, State.INITIALIZING)) throw new IllegalStateException( \"Already initialized\"); this.x = x; this.y = y; // Do anything else the original constructor did init.set(State.INITIALIZED); &#125; // These methods provide access to internal state so it can // be manually serialized by subclass's writeObject method. protected final int getX() &#123; checkInit(); return x; &#125; protected final int getY() &#123; checkInit(); return y; &#125; // Must call from all public and protected instance methods private void checkInit() &#123; if (init.get() != State.INITIALIZED) throw new IllegalStateException(\"Uninitialized\"); &#125; // Remainder omitted&#125; checkInit 方法在其它方法工作之前调用，用来保证子类初始化之前调用相关方法就可以快速而干净地失败。 【75】考虑使用自定义的序列化形式一般来讲，只有当你自行设计的自定义序列化形式与默认的序列化形式基本相同时，才能接受默认的序列化形式。 对于一个对象来说，理想的序列化形式应该只包含该对象所表示的逻辑数据，而逻辑数据与物理表示法应该是各自独立的。如果一个对象物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式（POJO类？）。 即使你确定了默认的序列化形式是合适的，通常还必须提供一个 readObject 方法以保证约束关系和安全性。 transient 修饰符表明这个实例域将从一个类的默认序列化形式中省略掉： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// StringList with a reasonable custom serialized formimport java.io.*;public final class StringList implements Serializable &#123; private transient int size = 0; private transient Entry head = null; // No longer Serializable! private static class Entry &#123; String data; Entry next; Entry previous; &#125; // Appends the specified string to the list public final void add(String s) &#123; // Implementation omitted &#125; /** * Serialize this &#123;@code StringList&#125; instance. * * @serialData The size of the list (the number of strings * it contains) is emitted (&#123;@code int&#125;), followed by all of * its elements (each a &#123;@code String&#125;), in the proper * sequence. */ private void writeObject(ObjectOutputStream s) throws IOException &#123; s.defaultWriteObject(); s.writeInt(size); // Write out all elements in the proper order. for (Entry e = head; e != null; e = e.next) s.writeObject(e.data); &#125; private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; s.defaultReadObject(); int numElements = s.readInt(); // Read in all elements and insert them in list for (int i = 0; i &lt; numElements; i++) add((String) s.readObject()); &#125; private static final long serialVersionUID = 93248094385L; // Remainder omitted&#125; 尽管 StringList 的所有域都是瞬时的（transient），但 writeObject 方法的首要任务仍是调用 de-faultWriteObject，readObject 方法的首要任务仍是调用 defaultReadObject。如果所有的域都是瞬时的，从技术角度而言，不调用 defaultWriteObject 和 defaultReadObject 也是允许的，但是不推荐这样做。 不管你选择了那种序列化形式，都要为自己编写的每个可序列化的类声明一个显示的序列版本UID。这样可以避免序列版本UID成为潜在的不兼容根源。 private static final long serialVersionUID = randomLongValue； 【76】保护性地编写 readObject 方法readObject 方法实际上相当于另一个公有的构造器，如同其它的构造器一样，它也要求注意同样的所有注意事项。构造器必须检查其参数的有效性，并且在必要的时候对参数进行保护性拷贝，同样的，readObject 方法也需要这样做。 readObject 方法可以首先调用 defaultReadObject，然后检查被反序列化之后的对象有效性。如果有效性检测失败，readObject 方法就抛出一个 InvalidObjectException 异常，是反序列化过程不能成功完成： 123456789101112131415// readObject method with validity checkingprivate void readObject(ObjectInputStream s) throws IOException,ClassNotFoundException &#123; s.defaultReadObject()； // Check that our invariants are satisfied if (start.compareTo(end) &gt; 0) &#123; throw new **InvalidObjectException**(start + \" after \" + end)； &#125;&#125; 编写更加健壮的 readObject 方法的指导方针： 对于对象引用域必须保持为私有的类，要保护性地拷贝这些域中的每个对象。不可变类的可变组件就属于这一类。 对于任何约束条件，如果检查失败，则抛出一个 InvalidObjectException 异常。这些检查动作应该跟在所有的保护性拷贝之后。 如果整个对象图在被反序列化之后必须进行验证，就应该使用 ObjectInputValidation 接口。 无论直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。 【77】对于实例控制，枚举类型优先于 readResolvereadResolve 特性允许你用 readObject 创建的实例代替另一个实例。对于一个正在被反实例化的对象，如果它的类定义了一个 readResolve 方法，并且具备正确的声明，那么在反序列化之后，新建对象上的 readResolve 方法就会被调用。然后，该方法返回的对象引用将被返回，取代新建的对象。 readResolve 的可访问性很重要。如果把 readResolve 方法放在一个 final 类上，它就应该是私有的。如果把 readResolve 方法放在一个非 final 对象上，就必须认真考虑它的可访问性。 总而言之，你应该尽可能地使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控的类，就必须提供一个 readResolve 方法，并确保该类的所有实例域都为基本类型，或者是 transient 的。 【78】考虑用序列化代理代替序列化实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.*;import java.io.*;public final class Period implements Serializable &#123; private final Date start; private final Date end; /** * @param start the beginning of the period * @param end the end of the period; must not precede start * @throws IllegalArgumentException if start is after end * @throws NullPointerException if start or end is null */ public Period(Date start, Date end) &#123; this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); if (this.start.compareTo(this.end) &gt; 0) throw new IllegalArgumentException( start + \" after \" + end); &#125; public Date start () &#123; return new Date(start.getTime()); &#125; public Date end () &#123; return new Date(end.getTime()); &#125; public String toString() &#123; return start + \" - \" + end; &#125; // Serialization proxy for Period class private static class SerializationProxy implements Serializable &#123; private final Date start; private final Date end; SerializationProxy(Period p) &#123; this.start = p.start; this.end = p.end; &#125; private static final long serialVersionUID = 234098243823485285L; // Any number will do (Item 75) // readResolve method for Period.SerializationProxy private Object readResolve() &#123; return new Period(start, end); // Uses public constructor &#125; &#125; // writeReplace method for the serialization proxy pattern private Object writeReplace() &#123; return new SerializationProxy(this); &#125; // readObject method for the serialization proxy pattern private void readObject(ObjectInputStream stream) throws InvalidObjectException &#123; throw new InvalidObjectException(\"Proxy required\"); &#125;&#125; 总而言之，每当你发现自己必须在一个不能被客户端扩展的类上编写 readObject 或者 write-Object 方法的时候，就应该考虑使用序列化代理模式。要想稳健地将带有重要约束条件的对象序列化时，这种模式可能是最容易的方法。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"book","slug":"book","permalink":"http://yoursite.com/tags/book/"}]},{"title":"《EffectiveJava》（四）","slug":"EffectiveJava3","date":"2019-11-23T08:57:33.000Z","updated":"2019-11-23T09:12:01.267Z","comments":true,"path":"2019/11/23/EffectiveJava3/","link":"","permalink":"http://yoursite.com/2019/11/23/EffectiveJava3/","excerpt":"【47】了解和使用库不要重复发明轮子。一般而言，类库的代码可能比你自己编写的代码更好一些，并且会随着时间的推移不断改进。从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能够给予的投入。 强烈需要了解的类库： java.lang java.util java.io","text":"【47】了解和使用库不要重复发明轮子。一般而言，类库的代码可能比你自己编写的代码更好一些，并且会随着时间的推移不断改进。从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能够给予的投入。 强烈需要了解的类库： java.lang java.util java.io 特别推荐： java.util.Collections java.util.concurrent 【48】如果需要精确的答案，请避免使用 float 和 doublefloat 和 double 类型主要是为了科学计算和工程计算而设计的。它们执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。要让一个 float 或者 double 精确地表示 0.1（或任何10的任何其它负数次方值）是不可能的。 如果想让系统来记录十进制小数点，并且不介意因为不使用基本类型而带来的不便，就请使用BigDecimal(数值超过18位数字则必须使用它)，它允许你完全控制舍入。另外对于小数值也可以使用int 或者 long。以下为一个使用 BigDecimal 的例子： 12345678910111213141516171819final BigDecimal TEN_CENTS = new BigDecimal(“.10”)；int itemsBought = 0；BigDecimal funds = new BigDecimal(“1.00”)；for (BigDecimal price = TEN_CENTS；funds.compareTo(price) &gt;= 0；price = price.add(TEN_CENTS)) &#123; itemsBought ++； funds = funds.subtract(price)；&#125;System.out.println(itemsBought + \"items bought.\")；System.out.println(“Money left over：$” + funds)； 【49】基本类型优先于装箱基本类型Java有一个类型系统由两部分组成，包含基本类型，如 int、double、boolean，和引用类型，如 String 和 List。每个基本类型都有一个对应的引用类型，称作装箱基本类型。如： int —&gt; Integer，double —&gt; Double，boolean —&gt; Boolean 基本类型和装箱基本类型之间的三个主要区别： &lt;1&gt;基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。换句话说，两个装箱基本类型可以具有相同的值和不同的同一性。 &lt;2&gt;基本类型只有功能完备的值，而每个装箱基本类型还有一个非功能值：null。 &lt;3&gt;基本类型通常比装箱基本类型更节约时间和空间。 当程序用 == 操作符比较两个装箱基本类型时，它做了一个同一性比较，这几乎肯定不是你所希望的。当程序进行涉及装箱和拆箱基本类型混合类型计算时，它会进行拆箱，会抛出 NullPointer-Exception 异常。最后，当程序装箱了基本类型时，会导致高开销和不必要的对象创建。 123456789Integer i = new Integer(42)；Integer j = new Integer(42)；Interger f；if (i == j) //返回 falseif (f == 42) //抛出 NullPointerException，因为 f 初始值为 null 【50】如果其它类型更合适，则尽量避免使用字符串字符串不适合代替其它的值类型。比如说表达数值的字符串应该转化为适当的数值类型，比如说int、float、BigInteger。如果它是一个“是—或—否”这种问题的答案，就应该转变为 boolean 类型。 字符串不适合代替枚举类型。枚举类型比字符串更加适合用来表示枚举的常量。 字符串不适合代替聚集类型。如果一个实体有多个组件，用一个字符串来表示这个实体通常是很不恰当的。例如： 1String compoundKey = className + \"#\" + i.next()； 如果分隔符出现在某个域中，结果会出现混乱。使用时也需要解析字符串得到三个单独的域，造成性能损失。更好的做法是，简单地编写一个类来描述这个数据集，通常是一个私有的静态成员类。 1234567891011class CompoundKey &#123; String className： String seperator； String add； ...&#125; 【51】当心字符串连接的性能为连接 n 个字符串而重复地使用字符串连接操作符，需要 n 的平方级的时间。这是由于字符串不可变而导致的不幸结果。当两个字符串被连接在一起时，它们的内容都要被拷贝。 不要使用字符串连接操作符（+）来合并多个字符串，除非性能无关紧要。相反，应该使用 Strin-gBuilder 的 append 方法。另一种方法是，使用字符数组，或者每次只处理一个字符串，而不是将它们组合起来。 【52】通过接口引用对象应该使用接口而不是用类作为参数的类型。更一般的讲，应该优先使用接口而不是类来引用对象。如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当你利用构造器创建某个对象的时候，才需要真正引用这个对象的类。 例外情况： （1）如果没有合适的接口类型存在，完全可以用类而不是接口来引用对象。 （2）对象属于一个框架，而框架的基本类型是类。 （3）类实现了接口，但是它提供了接口中不存在的额外方法。 【53】接口优先于反射机制待添加。。。 【54】谨慎地使用本地方法在使用本地方法之前务必三思。极少数情况下会需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层的资源或者遗留代码库，也要尽可能少用本地代码，并且要全面进行测试。本地代码的一个 BUG 就有可能破坏整个应用程序。 【55】谨慎地进行优化三条与优化有关的格言： 1.很多计算机上的过失都被归咎于效率（没必要达到的效率），而不是任何其他原因——甚至盲目的做傻事。 2.不要去计较效率上的一些小小的得失，在 %97 的情况下，不成熟的优化才是一切问题的根源。 3.1不要进行优化。 3.2（仅针对专家）：还是不要进行优化——也就是说，在你还没有绝对清晰的优化方案之前，请不要进行优化。 总而言之，不要费力去编写快速的程序——应该努力编写好的程序，速度自然会随之而来。在设计系统的时候，特别是在设计 API 、线路层协议和永久数据格式的时候，一定要考虑性能的因素。当构建完系统之后，要测量它的性能。如果它够快，你的任务就完成了。如果不够快，则可以在性能剖析器的帮助下，找到问题的根源，然后设法优化系统中相关的部分。第一个步骤是检查所选择的算法：再多的底层优化也无法弥补算法的选择不当。必要时重复这个过程，在每次改变之后都要测量性能，直到满意为止。 【56】遵守普遍接受的命名惯例把标准的命名惯例当做一种内在的机制来看待，并且学着用它们作为第二特征。字面惯例是非常直接和明确的；语法惯例则更加复杂和松散。“如果长期养成的习惯用法与此不同，请不要盲目遵从这些命名惯例。”请运用常识。 十、异常：【57】只针对异常的情况才使用异常设计良好的 API 不应该强迫它的客户端为了正常的控制流而使用异常。如果类具有“状态相关”的方法，即只有在特定的不可预知的条件下才可以被调用的方法，这个类往往也应该有个单独的“状态测试”方法，即指示是否可以调用这个状态相关的方法。例如： 12345for （Iterator&lt;Foo&gt; i = collection.iterator；i.hasNext；）&#123; //状态测试方法“hasNext()” Foo foo = i.next()；//状态相关方法“next()”&#125; 另一种提供单独的状态测试方法的做法是，如果“状态相关”的方法被调用时，该对象处于不适当的状态之中，他就会返回一个可识别的值，比如 null，但这种方法对于 Iterator 而言并不合适，因为Null 是 next 方法的合法返回值。 【58】对可恢复的情况使用受检异常，对编程错误使用运行时异常Java 程序设计语言提供了三种可抛出结构：受检的异常、运行时异常和错误。 在决定使用受检异常或是未受检异常时，主要的原则是：如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常。通过抛出受检的异常，强迫调用者在一个 catch 子句中处理该异常或者将它传播出去。 因为受检的异常往往指明了可恢复的条件，所以对于这样的异常，提供一些辅助方法尤其重要，通过这些方法，调用者可以获取一些有助于恢复的信息。例如，假设因为用户没有存储足够的钱，他企图在一个收费电话上呼叫就会失败，于是抛出受检异常。这个异常应该提供一个访问方法，以便允许客户查询所缺的费用金额，从而将这个数值传递给电话用户。 【59】避免不必要的使用受检的异常在异常处理的时候，都会接触到受检异常（checked exception）和非受检异常（unchecked-exception）这两种异常类型。非受检异常指的是java.lang.RuntimeException和java.lang.Error类及其子类，所有其他的异常类都称为受检异常。两种类型的异常在作用上并没有差别，唯一的差别就在于使用受检异常时的合法性要在编译时刻由编译器来检查。正因为如此，受检异常在使用的时候需要比非受检异常更多的代码来避免编译错误。 “把受检异常变成未受检异常”的一种方法是，把这个抛出异常的方法分成两个方法，其中第一个方法是，其中第一个方法返回一个 boolean，表明是否应该抛出异常。这种 API 重构，把下面的调用序列： 1234567891011try &#123; obj.action()；&#125; catch (TheCheckedException e) &#123; //Handle exceptional condition ...&#125; 重构为： 1234567891011if (obj.actionPermitted(args)) &#123; obj.action(args)；&#125; else &#123; //Handle exceptional condition ...&#125; 【60】优先使用标准的异常 【61】抛出与抽象相对应的异常如果方法抛出的异常与它所执行的任务没有明显的联系，这种情形将会使人不知所措。当方法传递由低层抽象抛出的异常时，往往会发生这种情况。 为了避免这个问题，更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法被称为异常转译（exception translation），如下所示： 123456789try &#123; // Use lower-level abstraction to do our bidding&#125; catch (LowerLevelException e) &#123; throw new HigherLevelException(...)；&#125; 一种特殊的异常转译形式称为异常链，如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。低层的异常（原因）被传到高层的异常，高层的异常提供访问方法来获得低层的异常： 123456789try &#123; // Use lower-level abstraction to do our bidding&#125; catch (LowerLevelException cause) &#123; throw new HigherLevelException(cause)；&#125; 高层异常的构造器将原因传到支持连的超级构造器，因此它最终将被传给 Throwable 的其中一个运行异常链的构造器，例如 Throwable(Throwable)： 123456789class HighLevelException(Throwable cause) &#123; HigherLevelException(Throwable cause) &#123; super(cause)； &#125;&#125; 总而言之，如果不能阻止或处理来自更低层的异常，一般的做法是使用异常转译，除非低层方法碰巧可以保证它抛出的所有异常对高层也合适才可以将异常从低层传播到高层。异常链对高层和低层异常都提供了最佳的功能：它允许抛出适当的高层异常，同时又能捕获底层的原因进行失败分析。 【62】每个方法抛出的异常都要有文档始终要单独地声明受检的异常，并且利用Javadoc的@throws标记，准确的记录下抛出每个异常的条件。 总而言之，要为你编写的每个方法所能抛出的每个异常建立文档。对于受检异常和非受检异常，以及对于抽象的和具体的方法也都一样。要为每个受检异常提供单独的 throws 子句，不要为未受检异常提供 throws 子句。 【63】在细节消息中包含能捕获失败的信息为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。为了确保在异常的细节消息中包含足够的能够捕获失败的信息，一种办法是在异常的构造器而不是字符串细节消息中引入这些信息。然后，有了这些信息，只要把他们放到消息描述中，就可以自动产生细节消息。例如，IndexOutOfBoundsException 并不是有个 String 构造器，而是有个这样的构造器： 123456789101112public IndexOutOfBoundsException（int lowerBound，int upperBound，int index）&#123; super(\"Lower bound：\" + lowerBound + “，Upper bound：” + upperBound + \"， Index：\" + index)； this.lowerBound = lowerBound； this.upperBound = upperBound； this.index = index；&#125; 为异常的“失败捕获”信息（在上例中的 lowerBound、upperBound 和 index 方法）提供一些访问方法是合适的。提供这样的访问方法对于受检的异常，比对于未受检的异常更为重要，因为失败——捕获信息对于从失败中恢复是非常有用的。 【64】努力使失败保持原子性一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法被称为具有失败原子性。 实现这种效果的途径： 1.设计一个不可变的对象。如果对象是不可变的，失败原子性就是显然的。 2.对于在可变对象上执行操作的方法： 2.1在执行操作之前检查参数的有效性。 2.2调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。 2.3编写一段恢复代码，由它来拦截操作过程中发生的失败，以及使对象回滚到操作开始之前的状态上。这种办法主要用于永久性的数据结构。（例如数据库的回滚） 2.4在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。 【65】不要忽略异常空的 catch 块会使异常达不到应有的目的： 1234567try &#123; ...&#125; catch (SomeException e) &#123;&#125; 不管异常代表了可预见的异常条件，还是编程错误，用空的 catch 块忽略它，将会导致程序在遇到错误的情况下悄然地执行下去。而会在将来的某个点上突然失败。 十一、并发：【66】同步访问共享的可变数据读取一个非 long 或 double 类型的变量，可以保证返回的值是某个线程保存在改变量中的，即使多个线程在没有同步的情况下并发地修改这个变量也是如此。 为了在线程之间进行可靠的通信，也是为了互斥访问，同步是必要的。 要阻止一个线程妨碍另一个线程，建议的做法是让第一个线程轮询一个 boolean 域，这个域一开始为 false ，但是可以通过第二个线程设置为 true ，表示第一个线程将中止自己。由于 boolean 域的读和写操作都是原子的，程序员在访问这个域的时候不再使用同步： 12345678910111213141516171819202122232425262728293031public class StopThread &#123; private static boolean stopRequested；//boolean域 public static void main(String[] args) throws InterruptedException &#123; Thread backgroundThread = new Thread(new Runnable() &#123; public void run() &#123; int i = 0； while (!stopRequested) &#123; i ++； &#125; &#125; &#125;)； backgroundThread.start()； TimeUnit.SECONDS.sleep(1)； stopRequested = true； &#125;&#125; 由于没有同步，就不能保证后台线程何时“看到”主线程对 stopRequested 的值所做的改变。因此上述代码永远不会终止，修正的一种方法是同步访问 stopRequested 域： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class StopThread &#123;private static boolean stopRequested；//boolean域 private static synchronized void requestStop() &#123; //同步写操作 stopRequested = true； &#125; private static synchronized boolean stopRequested() &#123; //同步读操作 return stopRequested； &#125; public static void main(String[] args) throws InterruptedException &#123; Thread backgroundThread = new Thread(new Runnable() &#123; public void run() &#123; int i = 0； while (**!stopRequested()**) &#123; i ++； &#125; &#125; &#125;)； backgroundThread.start()； TimeUnit.SECONDS.sleep(1)； requestStop()； &#125;&#125; 如果读和写操作没有都被同步，同步就不会起作用。上述的 boolean 域的读写操作即使没有同步也是原子的，因此这些方法的同步只是为了它的通信效果（让其它线程立即知道改变），而不是为了互斥访问。起着同样的作用的修饰符是 volatile，它虽然不执行互斥访问，但是它可以保证任何一个县城在读取该域的时候都将看到最近刚刚被写入的值，一个需要特别注意的点是，使用 volatile 修饰符的变量进行其它操作时，需要注意此操作的原子性（总之谨慎地使用 volatile）。 【67】避免过度同步简而言之，为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法。更为一般地讲，要尽量限制同步区域内部的工作量。当你在设计一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。在现在这个多核的时代，这比永远不要过度同步来得更重要。只有当你有足够的理由一定要在内部同步类的时候，才应该这么做，同时还应该将这个决定清楚地写到文档中。 （暂时还是不能很好地理解，后续再慢慢理解）","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"book","slug":"book","permalink":"http://yoursite.com/tags/book/"}]},{"title":"《EffectiveJava》（三）","slug":"EffectiveJava2","date":"2019-11-23T08:57:22.000Z","updated":"2019-11-23T09:14:12.341Z","comments":true,"path":"2019/11/23/EffectiveJava2/","link":"","permalink":"http://yoursite.com/2019/11/23/EffectiveJava2/","excerpt":"【27】优先考虑泛型方法静态工具方法尤其适合泛型化。如实现构造器： 12345public static &lt;V，K&gt; HashMap&lt;V，K&gt; newHashMap() &#123;return new HashMap&lt;K，V&gt;()；&#125;","text":"【27】优先考虑泛型方法静态工具方法尤其适合泛型化。如实现构造器： 12345public static &lt;V，K&gt; HashMap&lt;V，K&gt; newHashMap() &#123;return new HashMap&lt;K，V&gt;()；&#125; 调用 Map&lt;String，List&gt; anagrams = newHashMap() 来实现 anagrams 的生成。 对于 public static &lt;T extends Comparable&gt; T max(List list) {…}；类型限制&lt;T extends Comparable&gt;，可以读作 “ 针对可以与自身进行比较的每个类型 T “，这与互比性的概念或多或少有些一致。 【28】利用有限制通配符来提升 API 的灵活性确定了子类型后，每个类型便都是自身的子类型，即便它没有将自身扩展。 为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。如果某个输入参数既是生产者，又是消费者，那么通配符类型就没有什么好处了：因为你需要的是严格的类型匹配，这不是用任何通配符而得到的。 PECS 表示 producer-extends，consumer-super。 如果参数化类型表示一个 T 生产者，就使用&lt;? extends T&gt;；如果它表示一个 T 消费者，就使用&lt;? super T&gt;。例如： 1234567public void pushAll(Iterable&lt;? extends E&gt; src) &#123; for (E e：src) push(e)；&#125; 上述方法中的 src 参数产生 E 实例供 Stack 使用，因此 src 相应的类型为 Iterable&lt;? super E&gt;； 1234567public void popAll(Collection&lt;E&gt; dst) &#123; while ( ! isEmpty) dst.add(pop())；&#125; 上述方法中 dst 参数通过 Stack 消费 E 实例，因此 dst 相应的类型为 Collection&lt;? super E&gt;。 一般来说，如果类型参数只在方法声明中出现一次，就可以用通配符取代它。如果是无限制的类型参数()，就用无限制的通配符取代它(&lt;?&gt;)；如果是有限制的类型参数，就用有限制的通配符取代它。 【29】优先考虑类型安全的异构容器cast 方法是 Java 的 cast 操作符的动态模拟。它只检测它的参数是否为 Class 对象所表示的类型实例。如果是，就返回参数；否则就抛出 ClassCastException 异常。 集合 API （如 Set 和 Map）说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上来避开这一限制。对于这种类型安全的异构容器，可以用 Class 对象作为键。以这种方式使用的 Class 对象称作类型令牌。你也可以使用定制的键类型。例如，用一个 DatabaseRow 类型表示一个数据库行（容器），用泛型 Column 作为它的键。 七、枚举和注解：【30】用 enum 代替 int 常量Java 枚举类型背后的基本想法非常简单：它们就是通过公有的静态 final 域为每个枚举常量导出实例的类。因为没有可以访问的构造器，枚举类型是真正的 final。Java 枚举本质上是 int 值。 为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器，例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public enum Planet &#123; MERCURY (3.302e+23, 2.439e6), //使用构造器 VENUS (4.869e+24, 6.052e6), EARTH (5.975e+24, 6.378e6), MARS (6.419e+23, 3.393e6), JUPITER (1.899e+27, 7.149e7), SATURN (5.685e+26, 6.027e7), URANUS (8.683e+25, 2.556e7), NEPTUNE (1.024e+26, 2.477e7); private final double mass; private final double radius; private final double surfaceGravity; private static final double G = 6.67300E-11; //内部构造器，外部不能访问 Planet(double mass, double radius) &#123; this.mass = mass; this.radius = radius; surfaceGravity = G * mass / (radius * radius); &#125; public double mass() &#123; return mass; &#125; public double radius() &#123; return radius; &#125; public double surfaceGravity() &#123; return surfaceGravity; &#125; public double surfaceWeight(double mass) &#123; return mass * surfaceGravity; &#125;&#125; 每当需要一组固定常量的时候，应该使用枚举。枚举中的常量集不一定要始终保持不变。如果多个枚举常量同时共享相同的行为，则考虑策略枚举： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061enum PayrollDay &#123; MONDAY(PayType.WEEKDAY)， //使用策略一 ... SUNDAY(PayType.WEEKEND)； //使用策略二 private final PayType payType； PayrollDay(PayType payType) &#123; this.payType = payType； &#125; double pay(double hoursWorked，double payRate) &#123; return payType.pay(hoursWorked，payRate)； &#125; //策略枚举 private enum PayType &#123; WEEKDAY &#123; //策略一：WEEKDAY 策略 double overtimePay(double hours，double payRate) &#123; ... &#125; &#125;， WEEKEND &#123; //策略二：WEEKEND 策略 double overtimePay(double hours，double payRate) &#123; ... &#125; &#125;； ... //枚举内部声明的抽象构造方法 abstract double overtimePay(double hours，double payRate)； double pay(double hours，double payRate) &#123; ... &#125; &#125;&#125; 【31】用实例域代替序数永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。很少用到，故不详细说明了。 【32】用 EnumSet 代替位域集合的位域表示法： 12345678910111213public class Text &#123; public static final int STYLE_BOLD = 1&lt;&lt;0；// 1 public static final int STYLE_ITALIC = 1&lt;&lt;1；// 2 public static final int STYLE_UNDERLINE = 1&lt;&lt;2；// 4 public static final int STYLE_STRIKETHROUGH = 1&lt;&lt;3；// 8 public void applyStyles(int styles) &#123;...&#125;&#125; 调用： 1text.applyStyles(STYLE_BOLD | STYLE_ITALIC)； 用枚举代替位域： 1234567public class Text &#123; public enum Style &#123; BOLD，ITALIC，UNDERLINE，STRIKETHROUGH &#125; public void applyStyles(Set&lt;style&gt; styles) &#123;...&#125;&#125; 调用： 1text.applyStyles(EnumSet.of(Style.BOLD，Style.ITALIC))； 【33】用 EnumMap 代替序数索引最好不要用序数来索引数组，而要使用 EnumMap。如果你所表示的这种关系是多维的，就使用 EnumMap&lt;…， EnumMap&lt;…&gt;&gt;。应用程序的程序员在一般的情况下都不使用 Enum.ordinal 即使要用也很少，因此这是一种特殊情况。 123456789101112131415Map&lt;Herb.Type，Set&lt;Herb&gt;&gt; herbsByType = new EnumMap&lt;Herb.Type，Set&lt;Herb&gt;&gt;(Herb.Type.class)；for (Herb.Type t：Herb.Type.values()) &#123; herbsByType.put(t，new HashSet&lt;Herb&gt;())；&#125;for (Herb h：garden) &#123; herbsByType.get(h.type).add(h)；&#125;System.out.println(herbsByType)； 【34】用接口模拟可伸缩的枚举虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。这样允许客户端编写自己的枚举来实现接口。如果 API 是根据接口编写的，那么在可以使用基础枚举类型的任何地方，也都可以使用这些枚举。例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public interface Operation &#123; //接口 double apply(double x，double y)；&#125;public enum BasicOperation implements Operation &#123; //扩展接口的基本运算类型 PLUS (\"+\") &#123; //加法运算 public double apply(double x，double y) &#123; return x+y；&#125; &#125;， MINUS (\"-\") &#123;...&#125;， //减法运算，省略 TIMES (\"*\") &#123;...&#125;， //乘法运算，省略 DEVIDE (\"/\") &#123;...&#125;； //除法运算，省略 private final String symbol； BasicOperation(String symbol) &#123; this.symbol = symbol； &#125; @Override public String toString() &#123; return symbol； &#125;&#125;public enum ExtendedOperation implements Operation &#123; //扩展接口的扩展运算类型 EXP(\"^\") &#123; //计算 x 的 y 次方的结果 public double apply(double x，double y) &#123; return Math.pow(x，y)； &#125; &#125;， REMINDER(\"%\") &#123;...&#125;； //求余运算 ... ...&#125; 【35】注解优先于命名模式【36】坚持使用 Override 注解Override 注解只能用在方法声明中，它表示被注解的方法声明覆盖了超类型中的一个声明。如果坚持使用这个注解，可以防止一大类的非法错误。例如： 1234567891011121314151617public class Bigram &#123; private final char first； private final char second； ... public boolean equals(Bigram b) &#123; //结果是重载而非覆盖 equals 方法 return b.first == first &amp;&amp; b.second == second； &#125; ...&#125; 为了覆盖 Object.equals，必须定义一个参数为 Object 类型的 equals 方法，但是 Bigram 的 equals 方法的参数并不是 Object 类型，因此 Bigram 从 Object 继承了 equals 方法，而非覆盖了equals 方法。需要改成正确的覆盖方式： 123456789101112131415161718192021222324252627public class Bigram &#123; private final char first； private final char second； ... @Override //当加入注解时，会给出覆盖 equals 方法提示 public boolean equals(**Object o**) &#123; //覆盖 equals 方法 if (!(o instanceof Bigram)) &#123; return false； &#125; Bigram b = (Bigram) 0； return b.first == first &amp;&amp; b.second == second； &#125; ...&#125; 【37】用标记接口定义类型标记接口是没有包含方法声明的接口，而只是指明一个类实现了某种属性的接口。例如，考虑 Serializable 接口。通过实现这个接口，类表明它的实例可以被写到 ObjectOutputStream (或者“被序列化”)。 序列化的原因：很多时候，由于通信协议的原因，在传输的过程中，复杂的类对象是不支持传来传去的，所以一般来说要转化成流的形式，放在包中传来传去。 标记接口的例子： 定义标记接口： 1public interface RandomAccess &#123;&#125; 标记接口继承： 1234567891011121314151617public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable //继承Random-Access &#123; //... &#125;public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable //未继承Random-Access &#123; //... &#125; 标记接口使用： 12345678910111213141516171819202122232425import java.util.List;import java.util.RandomAccess;public class SourceLearning&#123; public void iteratorElements(List&lt;String&gt; list) &#123; //判断 list 是否为 RandomAccess 实例，以采取不同的处理策略 if (list instanceof **RandomAccess**) &#123; ... &#125; else &#123; ... &#125; &#125;&#125; 八、方法：【38】检查参数的有效性每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制，应该把这些限制写到文档中，并且在这个方法的开头处，通过显示的检查来实施这些限制。养成这样的的习惯是非常重要的。只要有效检查有一次失败，你为必要的有效性检查所付出的努力便都可以连本带利得到偿还了。 【39】必要时进行保护性拷贝如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性的拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当的修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。实例： 我们定义了一个Person类，该类的字段均为私有的，同时没有添加可以修改字段的方法： 123456789101112131415161718192021222324252627public class Person &#123; private String name; private Date birth; public Person(String name, Date birth) &#123; this.name = name; this.birth = birth; &#125; public Date getBirth() &#123; return birth; &#125; public String getName() &#123; return name; &#125; &#125; 该类看似是一个不可变类，实际上是这样的吗？可以测试一下： 1234567891011121314151617public static void main(String[] args) &#123; Person p = new Person(\"Benson\",new Date(1990, 4, 13)); System.out.println(p.getName()); System.out.println(p.getBirth().getYear()); Date hole = p.getBirth(); //得到 Date 变量，但 Date 变量是可变的 hole.setYear(2013); //birth 改变 System.out.println(p.getName()); System.out.println(p.getBirth().getYear()); &#125; 输出为： 1234567Benson 1990 Benson 2013 Person 实例被改变了，虽然 Person 实例中没有可以改变 Person 类的方法给外部访问，但是 Person 类中具有一个可变的属性 Date ，外部客户端可以先得到这个 Date 属性，再调用 Date 的 set() 方法来改变 Person 类，造成了类的可变性。 使用保护性拷贝： 12345678910111213public class Person &#123; ... public Date getBirth() &#123; return new Date(birth.toString()); //保护性拷贝 &#125; ... &#125; 之后再调用 Date hole = p.getBirth(); 得到的变量 hole 是 Person 属性 birth 的一个副本，之后再 调用 hole.set() 方法就不会改变 birth 属性的值了，对 Person 类就有了一个很好的保护。 【40】谨慎的设计方法签名（1）谨慎地选择方法的名称。方法的名称应该始终遵循标准的命名习惯。 （2）不要过于追求提供便利的的方法。每个方法都应该尽其所能。方法太多会使类难以学习、使用、文档化、测试和维护。 （3）避免过长的参数列表。目标是四个，或者更少。缩短参数列表的方法： &lt;1&gt;将方法分解为多个方法。 &lt;2&gt;创建辅助类。例如 draw（int x, int y, String name）中的（int x，int y）代表一个点，就可以用 draw（Point point，String name）来代替。 &lt;3&gt;从对象构建到方法调用都采用 Builder 模式。例如 fruit.addName(“Apple”).addColor(“Red”) （4）对于参数类型，要优先使用借口而不是类。如果使用的是类而不是接口，则限制了客户端只能传入特定的实现，如果碰巧输入的数据是以其他的形式存在，则就会导致不必要的，可能非常昂贵的拷贝操作。例如如果使用 Map 接口作为参数，就可以使你传入一个 Hashtable、HashMap、Tr-eeMap 或者任何有待于将来编写的 Map 实现。 （5）对于 boolean 参数，要优先使用两个元素的枚举类型。它使代码更易于阅读和编写，也使以后更易于添加更多的选项。 【41】慎用重载对于重载方法的选择是静态的，对于被覆盖的方法的选择则是动态的。 调用重载方法是在编译时作出决定的，选择被覆盖的方法的正确版本是在运行时进行的。 对于以下变量 collections : 1234567Collection&lt;?&gt; collections = &#123; new HashSet&lt;String&gt;()， new ArrayList&lt;BigInteger&gt;()， new HashMap&lt;String，String&gt;().values() &#125;；for (Collection&lt;?&gt; c ： collections) &#123; System.out.println(classify(c))；&#125; 对于 for 循环的三次迭代，Collection&lt;?&gt; 为参数的编译时类型，而 HashSet，Array-List，HashMap&lt;String，String&gt; 为三个参数的运行时类型。 重载的例子：如构造函数， 123public Test () &#123; &#125;；public Test (String name) &#123; &#125;； 覆盖的例子：如子类Override复写， 12345678class Wine &#123; String name() &#123; return \"wine\"； &#125;&#125;class SparklingWine extends Wine &#123; @Override String name() &#123; return \"sparkling wine\"； &#125;&#125; 重载的安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用可变参数，保守的策略是根本不要重载它。这项限制并不麻烦，因为你始终可以给方发起不同的名称，而不使用重载机制。 对于构造器，你没有选择使用不同名称的机会；一个类的多个构造器总是重载的。在许多情况下，可以选择导出静态工厂，而不是构造器。 总而言之，“能够重载方法”并不意味着“应该重载方法”。一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法，但是在某些情况下，特别是涉及构造器的时候，就必定要重载 这种情况下，至少要避免这种情形：同一组参数只需要经过类型转换就可以传递给不同的重载方法。如果不可避免，就应当保证：当传递同样的参数时，所有重载方法的行为必须一致。 【42】慎用可变参数在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用。如果使用不当，会产生混乱的结果。 定义可变参数方法的一个好的例子： 1234567891011121314151617static int min(int firstArg，int... remainingArgs) &#123; int min = firstArg； for (int arg：remainingArgs) &#123; if (arg &lt; min) &#123; min = arg； &#125; return min； &#125;&#125; 在重视性能的情况下，使用可变参数机制要特别小心。可变参数方法的每次调用都会导致进行一次数组分配和初始化。假设确定对某个方法 95% 的调用会有 3 个或者更少的参数，就该声明 5 个重载，如下所示： 123456789public void foo() &#123; &#125;；public void foo(int a1) &#123; &#125;；public void foo(int a1，int a2) &#123; &#125;；public void foo(int a1，int a2，int a3) &#123; &#125;；public void foo(int a1，int a2，int a3，int... rest) &#123; &#125;； 【43】返回零长度的数组或者集合，而不是 null返回类型为数组或者为集合的方法不应该返回 null，而应该返回一个零长度的数组或者集合。集合值的方法可以做成在每当需要返回空集合的时候都返回同一个不可变的空集合。Collections.empty-Set、emptyList 和 emptyMap 提供的正是我们需要的。 12345678910111213public List&lt;Cheese&gt; getCheeseList() &#123; if (cheeseInStock.isEmpty()) &#123; return Collections.emptyList()；//返回空集合，而不是 null &#125; else &#123; return new ArrayList&lt;Cheese&gt;(cheeseInStock)； &#125;&#125; 【44】为所有导出的 API 元素编写文档注释Javadoc 的 {@code} 标签：使代码片段以代码字体进行呈现，并限制 HTML 标记和嵌套的 Jav-adoc 标签在代码片段中进行处理。后一种属性正是允许我们在代码片段中使用小于号（&lt;）的东西，虽然它是一个 HTML 元字符。 Javadoc 的 {@literal} 标签也是为了产生包含 HTML 元字符的文档，比如小于号（&lt;）、大于号（&gt;）以及“与”（&amp;）。除了它不以代码字体渲染文本之外，其余方面就像 {@code} 标签一样。例如： * The triangle inequality is { @literal |x + y|&lt;|x| + |y| } 产生的文档为： “The triangle inequality is |x + y|&lt;|x| + |y| ” 文档注释在源代码和产生的文档中都应该是易于阅读的。如果无法让两者都易读，产生的文档的可读性要优先于源码的可读性。 九、通用程序设计：【45】将局部变量的作用域最小化将局部变量的作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。 要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。几乎每个局部变量的声明都应该包含一个初始化表达式。如果还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。 如果在循环终止之后不再需要循环变量的内容，for 循环就优先于 while 循环。以下展示一个“剪切—粘贴”错误： 1234567891011121314151617Iterator&lt;Element&gt; i = c.iterator()；while (i.hasNext()) &#123; doSomething(i.next())；&#125;...Iterator&lt;Element&gt; i2 = c2.iterator()；while (i.hasNext()) &#123; //BUG! 变量 i 的作用域使 i 仍在有效范围 doSomethingElse()；&#125; 使用 for 循环可以避免这种问题： 1234567891011for (Iterator&lt;Element&gt; i = c.iterator()；i.hasNext()；) &#123; doSomething(i.next())；&#125;for (Iterator&lt;Element&gt; i = c2.iterator()；i.hasNext()；) &#123; //上一个变量 i 作用域已结束，不影响 doSomething(i.next())；&#125; 【46】for-each 循环优先于传统的 for 循环for-each 循环在简洁性和预防 BUG 方面有着传统的 for 循环无法比拟的优势，并且没有性能损失。应该尽可能地使用 for-each 循环。for-each 循环不仅让你遍历集合和数组，还让你遍历任何实现Iterable 接口的对象。例如： 使用 for 循环： 1234567891011for (Iterator&lt;Suit&gt; i = suits.iterator()；i.hasNext()；) &#123; Suit suit = i.next()； for (Iterator&lt;Rank&gt; j = ranks.iterator()；j.hasNext()；) &#123; deck.add(new Card(suit，j.next()))； &#125;&#125; 使用 for-each 循环代替： 123456789for (Suit suit：suits) &#123; for (Rank rank：ranks) &#123; deck.add(new Card(suit，j.next()))； &#125;&#125; 三种常见的不能使用 for-each 循环的情况： 过滤——如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的remove 方法。 转换——如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引，以便设定元素的值。 平行迭代——如果需要并行的遍历多个集合，就需要显式的控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"book","slug":"book","permalink":"http://yoursite.com/tags/book/"}]},{"title":"《EffectiveJava》（二）","slug":"EffectiveJava1","date":"2019-11-23T08:57:10.000Z","updated":"2019-11-23T09:15:34.882Z","comments":true,"path":"2019/11/23/EffectiveJava1/","link":"","permalink":"http://yoursite.com/2019/11/23/EffectiveJava1/","excerpt":"【15】使可变性最小化不可变类只是实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。为了使类成为不可变，要遵循下面五条规则： &lt;1&gt;不要提供任何会修改对象状态的方法。 &lt;2&gt;保证类不会被扩展。 &lt;3&gt;使所有的域都是 final 的。 &lt;4&gt;使所有的域都成为私有的。 &lt;5&gt;确保对于任何可变组件的互斥访问。","text":"【15】使可变性最小化不可变类只是实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。为了使类成为不可变，要遵循下面五条规则： &lt;1&gt;不要提供任何会修改对象状态的方法。 &lt;2&gt;保证类不会被扩展。 &lt;3&gt;使所有的域都是 final 的。 &lt;4&gt;使所有的域都成为私有的。 &lt;5&gt;确保对于任何可变组件的互斥访问。 不可变对象本质上是线程安全的，它们不要求同步。当多个线程并发访问这样的对象时它们不会遭到破坏。这无疑是获得线程安全最容易的办法。 不可变类真正唯一的缺点是，对于每一个不同的值都需要一个单独的对象，创建这种对象的代价可能会很高。这时候就需要为不可变类提供一个共有的可变配套类来进行复杂的多阶段操作，例如： StringBuilder 类就是 String 类的可变配套类，用来改变 String 对象，以提升性能。 【16】复合优先于继承继承的功能非常强大，但也存在诸多问题，因为它违背了封装原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类处在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性。为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。 复合设计：不用扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，现有类成为了新类的一个组件，新类中的每个实例方法都可以调用被包含的现有实例中的对应方法，并返回结果。例如： 12345678910111213141516171819202122232425262728293031323334//转发类（中间层），包含转发方法public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123; private final Set&lt;E&gt; s；//现有类的实例 public ForwardingSet（Set&lt;E&gt; s） &#123; this.s = s； &#125; public void clear() &#123; s.clear； &#125; public boolean add(E e) &#123; return s.add(e)； &#125;...&#125;//复合类public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt;&#123; private int addCount = 0； public InstrumentedSet(Set&lt;E&gt; s) &#123; super(s)； &#125; @override public boolean add(E e)&#123; addCount++； return super.add(e)； &#125;&#125; 【17】要么为继承而设计，并提供文档说明，要么就禁止继承为了允许继承，类还需遵守其他一些约束。构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用，因为超类的构造器是在子类的构造器之前运行的，所以子类中覆盖版本的方法将会在子类的构造器运行之前就先被调用。 对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种方法可以禁止子类化： &lt;1&gt;把这个类声明为 final 的。 &lt;2&gt;把类中所有的构造器都变成私有的，包括包级私有的，并增加一些公有的静态工厂来替代构造器。 你可以机械地消除类中可覆盖方法的自用特性，而不改变它的行为。将每个可覆盖方法的代码体移到一个私有的 “辅助方法（helper method）” 中，并让每个可覆盖方法调用它的私有辅助方法。然后，用 “直接调用可覆盖方法的私有辅助方法” 来代替 “可覆盖方法的每个自用调用” 。 【18】接口优于抽象类接口和抽象类机制之间的区别：抽象类允许包含某些方法的实现，但是接口则不允许；一个更重要的区别在于，为了实现由抽象类定义的类型，类必须成为抽象类的一个子类，而任何一个类，只要它定义了所有必要的方法，并且遵守通用约定，它就被允许实现一个接口，而不管这个类是处于类层次的哪个位置。 抽象类的演变比接口的演变要容易得多。如果在后续的发行版本中，你希望在抽象类中增加新的方法，始终可以增加具体方法，它包含合理的默认实现。然后，该抽象类的所有实现都将提供这个新的方法，对于接口，这样做是行不通的。 通过对导出的每一个重要接口都提供一个抽象的骨架实现（skeletal implementation）类，可以把接口和抽象类的优点结合起来。接口的作用仍然是定义类型，但是骨架实现类接管了所有与接口实现相关的工作。例如： 接口1： 123456789public interface IFoo &#123; void foo(); void add(); void del();&#125; 接口2： 12345public interface IBar &#123; void bar();&#125; 接口1的抽象骨架实现： 12345678910111213141516171819202122232425public abstract class AbstractFoo implements IFoo&#123; private String val; public String getVal() &#123;**//自定义 get 方法，扩展接口1的实现** return val; &#125; public void setVal(String val) &#123;**//自定义 set 方法，扩展接口1的实现** this.val = val; &#125; public void foo() &#123;**//实现接口1的 foo() 方法** System.out.println(\"AbstarctFoo\"); &#125; &#125; 新的测试类： 123456789101112131415161718192021222324252627public class FooBar extends AbstractFoo implements IBar&#123; @Override public void bar() &#123;**//实现 IBar 接口方法 bar()** // yingkhtodo Auto-generated method stub &#125; @Override public void add() &#123;**//实现 AbstractFoo 中未实现的接口1的 add() 方法** // yingkhtodo Auto-generated method stub &#125; @Override public void del() &#123;**//实现 AbstractFoo 中未实现的接口1的 del() 方法** // yingkhtodo Auto-generated method stub &#125;&#125; FooBar 类继承自 AbstractFoo 类，可以调用父类的 set()、get()、foo() 方法，也可以自己实现接口1和 IBar 接口的方法，其中接口1 foo() 方法在抽骨架价类 AbstractFoo 中实现，不需要再次实现，并且其它继承自 AbstractFoo 类的任意子类都不需要实现接口1的 foo() 方法， AbstractFoo 类接管了所有与接口1实现的相关工作。 【19】接口只用于定义类型接口应该只被用来定义类型，它们不应该被用来导出常量。如果常量被看做枚举类型的成员，就应该用枚举类型（enum type）来导出这些常量，否则，应该使用不可实例化的工具类（utility-class）来导出常量，如： 1234567891011public class PhysicalConstants &#123; private PhysicalConstants() &#123; &#125; //Prevents instantiation public static final double AVOGADROS_NUMBER = 6.02214199e23； public static final double BOLTZMANN_CONSTANT = 1.3806503e-23； ...&#125; 【20】类层次优于标签类标签类很少有使用的时候，当你想要编写一个包含显式标签域的类时，应该考虑一下，这个标签域是否可以被取消，这个类是否可以被层次类来代替。当你遇到一个包含标签域的现有类时，就要考虑将它重构到一个层次结构中去。例如，标签类如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Figure &#123; enum Shape &#123; RECTANGLE，CIRCLE &#125;； final Shape shape；//标签域，用来表示图形类别 //矩形参数 double length； double width； //圆形参数 double radius Figure (double radius) &#123; shape = Shape.CIRCLE； this.radiu = radius； &#125; ... double area() &#123; switch(shape) &#123; case CIRCLE： return MATH.PI * (radius * radius)； ... &#125; &#125;&#125; 转换为层次类如下： 123456789101112131415161718192021abstract class Figure &#123; abstract double area()；&#125;class Circle extends Figure &#123; final double radius； Circle(Double radius) &#123; this.radius = radius；&#125; double area() &#123; return Math.PI * (radius * radius)；&#125;&#125;class Rectangle extends Figure &#123;...&#125; 【21】用函数对象表示策略有些语言支持函数指针（function pointer）、代理（delegate）、lambda表达式，或者支持类似机制，允许程序把 “调用特殊函数的能力 “ 存储起来并传递这种能力。这种机制通常用于允许函数的调用者通过传入第二个函数，来指定自己的行为。 函数指针的主要用途就是实现策略（Strategy）模式。为了在 JAVA 中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略被使用一次时，通常使用匿名类来声明和实现这个具体策略类。当一个具体策略是设计用来重复使用的时候，它的类通常就要被实现为私有的静态成员类，并通过公有的静态 final 域被导出，其类型为该策略接口。 策略接口示例： 12345public interface Comparator&lt;T&gt; &#123; public int compare(T t1，T t2)；&#125; 匿名类示例： 123456789Array.sort(stringArray，new Comparator&lt;String&gt;() &#123; public int compare(String s1，s2) &#123; return s1.length() - s2.length()； &#125;&#125;)； 导出静态域实现策略示例： 12345678910111213141516171819class Host &#123; private static class StrLenCmp implements Comparator&lt;String&gt;，Serializable &#123; public int compare(String s1，String s2) &#123; return s1.length() - s2.length()； &#125;&#125;//公有静态域public static final Comparator&lt;String&gt; STRING_LENGTH_COMPARATOR = new StrLenCmp()；&#125; 【22】优先考虑静态成员类嵌套类有四种：静态成员类、非静态成员类、匿名类和局部类。 静态成员类是最简单的一种嵌套类，它可以访问外围类的所有成员，包括那些声明为私有的成员。 非静态成员类每个实例都隐含着与外围类的一个外围实例相关联，在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的 this 构造获得外围实例的引用。如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是静态成员类：在没有外围实例的情况下，想要创建非静态成员类的实例是不可能的。 如果声明成员类不要求访问外围实例，就要始终把 static 修饰符放在它的声明中，使它成为静态成员类，而不是非静态成员类。 匿名类出现在表达式中必须保持简短（10行或更少），否则会影响程序可读性。匿名类的一种常见用法是动态地创建函数对象（sort(A ，new B(){ … })；）；另一种常见用法是创建过程对象，如 Runnable、Thread 或者 ThreadTask 实例。 六、泛型：【23】请不要在新代码中使用原生态类型使用原生态类型会在运行时导致异常，因此不要在新代码中使用。原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。Set 是个参数化类型，表示可以包含任何对象类型的一个集合；Set&lt;?&gt; 则是一个通配符类型，表示包含某种位置对象类型的一个集合；Set 则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。 不要新代码中使用原生态类型，这条规则有两种例外： a.在类文字中必须使用原生类型，如 List.class、String[].class 合法，但是 List.class 不合法。 b.由于泛型信息可以在运行时被擦除，因此在参数化类型而非无限制通配符上使用 instanceof 操作符是非法的。用无限制通配符类型代替原生态类型，对 instanceof 操作符的行为不会产生任何影响 下面是利用泛型来使用 instanceof 操作符的首选方法： 1234567if （o instanceof Set） &#123; Set&lt;?&gt; m = (Set &lt;?&gt;) o； ...&#125; 【24】消除非受检警告用泛型编程时，会遇到许多编译器警告，每一条警告都表示可能在运行时抛出 ClassCast- Exception 异常。要尽最大的努力消除这些警告。如果无法消除非受检警告，同时可以证明引起警告的代码是类型安全的，就可能在尽可能小的范围中，用@SupperessWarnings(unchecked)注解来禁止该警告。要用注释把禁止该警告的原因记录下来。 【25】列表优先于数组数组和泛型有着非常不同的类型规则。数组是协变且可以具体化的；泛型是不可变且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型也一样。一般来说，数组和泛型不能很好的混用。如果你发现自己将它们混合起来使用，并且得到了编译时错误或者警告，你的第一反应就应该是用列表 (List或者List) 代替数组 (Object[ ] 或者 E[ ] )。 123456789101112131415161718192021static &lt;E&gt; E reduce(List&lt;E&gt; list，Function&lt;E&gt; f，E initval) &#123; List&lt;E&gt; snapshot； synchronized(list) &#123; snapshot = new ArrayList&lt;E&gt;(list)； &#125; E result = initVal； for (E e：snapshot) &#123; result = f.apply(result，e)； &#125; return result；&#125; 【26】优先考虑泛型使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。在设计新类型的时候，要确保他们不需要这种转换就可以使用。这通常意味着要把类做成泛型。只要时间允许，就要把现有的类型都泛型化。这对于这些类型的新用户来说会变得更加轻松，又不会破坏现有的客户端。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"book","slug":"book","permalink":"http://yoursite.com/tags/book/"}]},{"title":"《EffectiveJava》（一）","slug":"EffectiveJava","date":"2019-11-23T07:25:42.000Z","updated":"2019-11-23T09:15:46.004Z","comments":true,"path":"2019/11/23/EffectiveJava/","link":"","permalink":"http://yoursite.com/2019/11/23/EffectiveJava/","excerpt":"一、基本原则：【1】模块的用户永远也不应该被模块的行为所迷惑【2】模块要尽可能小，但又不能太小【3】代码应该被重用，而不是被拷贝【4】模块之间的依赖性应该尽可能地降到最小【5】错误应该尽早被检测出来，最好是在编译时刻","text":"一、基本原则：【1】模块的用户永远也不应该被模块的行为所迷惑【2】模块要尽可能小，但又不能太小【3】代码应该被重用，而不是被拷贝【4】模块之间的依赖性应该尽可能地降到最小【5】错误应该尽早被检测出来，最好是在编译时刻 二、Java语言支持四种类型：接口（interface）、类（class）、数组（array）和基本类型（primitive） 前三种类型通常被称为引用类型（reference type），类实例和数组是对象（object），而基本类型的值则不是对象。 三、创建和销毁对象：【1】考虑用静态工厂方法代替构造器优点：a.静态工厂方法有名称，可以提示返回值，而构造器返回值是默认的 b.不必在每次调用静态工厂方法时都创建一个新的对象（单例模式） c.静态工厂方法可以返回元返回类型的任何子类型的对象 d.静态工厂方法在创建参数化类型实例的时候，使得代码变得更加简洁 实例： 一般定义： 1Map&lt;String，List&lt;String&gt;&gt; m = new HashMap&lt;String，List&lt;String&gt;&gt;()； 静态工厂方法： 12345public static &lt;K，V&gt; HashMap&lt;K，V&gt; newInstance()&#123; return new HashMap&lt;K，V&gt;()；&#125; 静态工厂方法定义： 1Map&lt;String，List&lt;String&gt;&gt; m = HashMap.newInstance()； 缺点： ​ i.类如果不含有共有的或者受保护的构造器，就不能被子例化 ​ ii.它们与其他的静态方法实际上没有任何的区别 常用方法： ​ &lt;1&gt; valueOf() 类型转换方法 ​ &lt;2&gt; getInstance() 获取实例，对于Singleton来说，该方法没有参数，并返回唯一实例 ​ &lt;3&gt; newInstance() 获取新的不同实例 【2】遇到多个构造器参数时要考虑用构建器（Builder）如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择，特别是当大多数参数都是可选的时候。与是用传统的重叠构造器模式相比，使用Builder模式的客户端代码将更易于阅读和编写，构建器也比JavaBean更加安全。 实例： 123456789NutritionFacts cocaCola = new NutritionFacts.Builder(240,8) .calories(100) .sodium(35) .carbonhydrate(27) .build(); 【3】用私有构造器或者枚举类型强化Singleton属性实现方法： ​ a.共有静态成员为final域 ​ b.公有成员为静态工厂方法 ​ c.包含单个元素的枚举类型 【4】通过私有构造器强化不可实例化的能力对于工具类，一般只包含静态方法和静态的域，这样的工具类（utility class）不希望被实例化，实例化对它没有任何意义。 企图将类做成抽象类来强制该类不可被实例化是行不通的，因为该类可以被子类化，并且该子类也可以被实例化。 将显示构造器声明为私有的就可以使类不能被实例化： 1234567891011public class UtilityClass&#123; //Suppress default constructor for noninstantiability private UtilityClass()&#123; throw new AssertionError()； &#125;&#125; 这样做的副作用：使一个类不能被子类化。 【5】避免创建不必要的对象例子： 123String s = new String(\"ABC\")；//**DON‘T DO THIS**String s = \"ABC\";//**OK** tips:要优先使用基本数据类型而不是装箱基本类型，要当心无意识的自动装箱。 Long sum = 0L —-&gt; Long sum = 0l 使用0L的时候，代表每调用一次sum就会新创建一个Long实例 通过维护自己的对象池（object pool）来避免创建对象并不是一种好的做法，除非对象池中的对象是非常重量级的（例如数据库连接池、线程池）。 在提倡保护性拷贝的时候，因重用对象付出的代价要远远大于因创建重复对象而付出的代价，必要时如果没能实施保护性拷贝，会导致潜在的错误和安全漏洞；而不必要的创建对象则只会影响程序的风格和性能。 【6】消除过期的对象引用一般而言，只要类是自己管理内存，程序就应该警惕内存泄漏问题。 典型的例子就是 Stack 类，Stack 类自己管理内存，如果一个栈先是增长，然后再收缩，那么从栈中弹出来的对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，由于栈内维护着这些对象的过期引用，它们也不会被回收。 清空过期引用的例子： 123456789101112131415public Object pop()&#123; if(size == 0)&#123; throw new EmptyStackException()； &#125; Object result = elements[--size]； elements[size] = null；//消除过期对象引用 return result；&#125; 【7】避免使用终结方法类中对象中封装的资源（例如文件或者线程）需要终止时，只需提供一个显式的终止方法，并要求该类的客户端在每个实例不再有用的时候调用这个方法即可。 显式的终止方法通常与try-finally结构结合起来使用，以确保及时终止。 12345678910111213Foo foo = new Foo(...)；try&#123; //Do what must done with foo ...&#125; finally &#123; foo.terminate()；//显式调用终止方法&#125; 四、对于所有对象都通用的方法：【8】覆盖 equals 时请遵守通用约定Object类提供的equals方法：类的每个实例都只与它的自身相等 一般来说，内容相同不一定他们在内存中指向的地址也是相同的。而不同的对象在内存中若指向同一个地址，则他们的内容肯定是相同的(因为他们实际上就是同一个对象)。而==(两个等号)运算符与 equal函数就是运来比较这两块内容的。其中==运算符是用来比较内存中的地址是否相同，即比较它们的身份证号码是否相同。而equal函数则只比较他们的内容。如果他们的内容相同，即使身份证号码不相同(内存中的地址不同)，这个函数也人们他们是相同的，会返回TRUE值。 例子： ◆String str1=new String(“welcome”); //创建一个对象，给利用单词welcome初始化 ◆String str2=new String(“welcome”); //创建一个对象，给利用单词welcome初始化 ◆String str3=str1; //创建一个对象，并利用对象str1的地址赋值 比较 str1==str2 返回 false 比较 str1==str3 返回 true 比较 str1.equals(str2) 返回 true Object 中的 equals 方法实现了等价关系，具有以下特性： （1）自反性 （2）对称性 （3）传递性 （4）一致性 （5）非空性 实现高质量的 equals 方法的诀窍： &lt;1&gt;使用 == 操作符检查“参数是否为这个对象的引用” &lt;2&gt;使用 instanceof 操作符检查“参数是否为正确的类型” &lt;3&gt;把参数转换成正确地类型 &lt;4&gt;对于该类中的每个“关键域”，检查参数中的域是否与该对象中对应的域匹配 &lt;5&gt;当你编写完成了 equals 方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？ 最后的忠告： ​ -&gt;覆盖 equals 时总要覆盖 hashCode ​ -&gt;不要企图让 equals 方法过于智能 ​ -&gt;不要将 equals 声明中的 Object 对象替换为其它的类型 【9】覆盖 equals 时总要覆盖 hashCode【10】始终要覆盖 toStringjava.lang.Object 类提供了一个原生的 toString 方法实现，返回的字符串为：类名称+@+hash-Code，例如 “PhoneNumber@163b91” ；为了使类用起来更加舒适，建议所有的子类都覆盖toString 方法。 在实际使用中，toString 方法应该返回对象中包含的所有值得关注的信息，无论你对返回的信息是否指定确切的格式，都应该在函数文档说明中明确地表明自己的意图；无论是否指定格式，都应该为 toString 返回值中包含的所有信息，提供一种编程式的访问途径。 例如：PhoneNumber类： 1234567891011121314151617181920212223242526272829/*** 以 “（XXX） YYY-ZZZZ” 的格式返回 PhoneNumber 实例*/@Override public String toString() &#123; return String.format(\"(%03d) %03d-%04d，areaCode，prefix，lineNumber\")；&#125;public String getAreaCode() &#123; return this.areaCode；&#125;public String getPrefix() &#123; return this.prefix；&#125;public String getLineNumber() &#123; return this.lineNumber；&#125; 【11】谨慎地覆盖 clone记住一点：Cloneable接口具有许多的问题，其他的接口都不应该扩展这个接口，为了继承而设计的类也不应该实现这个接口。对于一个专门为了继承而设计的类，如果你未能提供行为良好的受保护 clone 方法，它的子类就不可能实现 Cloneable 接口。 【12】考虑实现 Comparable 接口通用约定：将对象与指定的对象进行比较，当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCa- stException异常。 五、类和接口：【13】使类和成员的可访问性最小化要区别设计良好的模块与设计不好的模块，最重要的因素在于，这个模块对于外部的其他模块而言，是否隐藏其内部数据和其它实现细节。设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。 对于顶层的（非嵌套类）类和接口，只有两种可能的访问级别：包级私有的（package-private）和公有的（public）。如果你用 public 修饰符声明了顶层类或者接口，那它就是公有的；否则，它将是包级私有的。例如： 12345class Student &#123; ...&#125; 为包级私有的类，只有同一个包下的类才能够访问到，如果在另一个包内的类，就不能访问到。 12345public class Student&#123; ...&#125; 为公有类，在不同的包内都可以访问到。 实例域决不能是公有的，以保证实例域的不可变性。 注意，长度非零的数组总是可变的，所以，类具有公有静态 final 数组域，或者返回这个域的访问方法，这几乎总是错误的。如果类具有这样的域或者访问方法，客户端就能够修改数组中的内容，可以使公有数组变成私有的，并增加一个公有的不可变列表来修正： 12345private static final Thing[ ] PRIVATE_VALUES = &#123;...&#125;；public static final List&lt;Thing&gt; VALUES = Collection.unmodifiableList(Arrays.asList(PRIVATE_VALUES))； 【14】在公有类中使用访问方法而非公有域1234567891011121314151617181920212223242526272829Class Point &#123; private double x； private double y； public Point(double x，double y)&#123; this.x = x； this.y = y； &#125; public double getX()&#123; return x； &#125; public double getY()&#123; return y； &#125;...&#125; 公有类永远都不应该暴露可变的域。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"book","slug":"book","permalink":"http://yoursite.com/tags/book/"}]},{"title":"设计原本","slug":"设计原本","date":"2019-11-23T07:22:34.000Z","updated":"2019-11-23T08:54:59.851Z","comments":true,"path":"2019/11/23/设计原本/","link":"","permalink":"http://yoursite.com/2019/11/23/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E6%9C%AC/","excerpt":"【1】什么是设计？Dorothy Sayers(英国作家和戏剧家)说设计有三个阶段：概念构造的形成，在真实媒质上的实现，与真正用户的交互。 【2】新思想来自于将一门艺术中的领悟联系并应用到另一门艺术中，经理若干次这样的经历而有所悟，脑海里自然就孕育出了“新思想”。——培根","text":"【1】什么是设计？Dorothy Sayers(英国作家和戏剧家)说设计有三个阶段：概念构造的形成，在真实媒质上的实现，与真正用户的交互。 【2】新思想来自于将一门艺术中的领悟联系并应用到另一门艺术中，经理若干次这样的经历而有所悟，脑海里自然就孕育出了“新思想”。——培根 【3】给设计者的六点建议： a.专心研究以前设计者的工作，看看他们如何解决问题。 b.尝试弄明白他们为什么做出那样的设计决定，这是对你自己最有启发性的问题。 c.仔细研究以前设计者的风格。最好的方式是尝试用他们的一些风格勾画设计草图。 d.保存一本“草图本”，将您的想法、设计和局部设计记录下来，不论使用何种媒质 e.在开始设计时，写下您对用户和使用方式的假定。 f.设计、设计、设计！ 【4】哪些领域的研究将有助于毕业生变成卓越的软件设计师？ a.算法和数据结构是重要的基础课程。 b.计算机硬件架构。 c.应用领域，特别是商业数据处理、数据库技术和数据挖掘。 d.心理学，特别是直觉心理学，因为用户是最重要的。 【5】对于大多数的创作者来说，构思的不完整性和不一致性只有到了实现的时候才变得明显起来。因此，记录、试验和“解决”成为了理论家们的关键原则。 【6】设计中最困难的部分在于决定要设计什么，而设计师的主要任务乃是帮助客户发现他们想要的设计。 【7】快速原型是一种进行精准的需求配置的必要工具。不仅整个设计过程是迭代的，就连设计目标的设定过程也是迭代的。 【8】研习设计史的最有利的原因是去了解怎么样的设计方案是行不通的以及为什么这些设计方案行不通。（前世之事，后事之师？！） 【9】我们都是围绕着约束来做设计的，该过程要求对于设计空间中少有人问津的角落有着很多创新和探索的精神，这是设计之乐的部分所在，也是设计之难的大部分所在。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"book","slug":"book","permalink":"http://yoursite.com/tags/book/"}]},{"title":"架构之美","slug":"架构之美","date":"2019-11-23T07:16:51.000Z","updated":"2019-11-23T08:47:39.498Z","comments":true,"path":"2019/11/23/架构之美/","link":"","permalink":"http://yoursite.com/2019/11/23/%E6%9E%B6%E6%9E%84%E4%B9%8B%E7%BE%8E/","excerpt":"【1】形式永远服从功能。 【2】好的架构的生成： ​ &lt;1&gt;确实进行有意为之的前端设计。 ​ &lt;2&gt;设计者的素质和经验。 ​ &lt;3&gt;在开发过程中，保持清晰的设计观点。","text":"【1】形式永远服从功能。 【2】好的架构的生成： ​ &lt;1&gt;确实进行有意为之的前端设计。 ​ &lt;2&gt;设计者的素质和经验。 ​ &lt;3&gt;在开发过程中，保持清晰的设计观点。 ​ &lt;4&gt;授权团队负责软件的整体设计，而团队也承担起这一责任。 ​ &lt;5&gt;不要害怕改变设计：没有什么是一成不变的。 ​ &lt;6&gt;让合适的人加入到团队中，包括设计者、程序员和经理，确保开发团队的规模合适。 确保他们具有健康的工作关系，应为这些关系不可避免地影响代码的结构。 ​ &lt;7&gt;在合适的时候做出设计决定，当你知道所有必要的信息时再做决定。延迟那些暂时不 能做出的决定。 ​ &lt;8&gt;好的项目管理，以及合适的最后期限。 【3】新芯片的设计目标不是将一件事做得更快，而是同时做多件事。如果在芯片上运行的 多项任务实际上可以同时执行，那么在芯片层面上引入并发执行将带来更好的总体性能。 【4】关于数据传输：快重试与慢重试的交叉使用。快重试是指客户端发送文件，服务器接收 文件后返回状态码，客户端接收到的状态码如果不是OK则立即重新传输文件，最多重传3次； 慢重试是指如果3次重传返回的状态码依旧是FAIL，则将任务放在失败重传序列，序列将以20 分钟为间隔来进行新一轮的重传操作，直到文件传输完毕。当然在进行传输时需要设置超时时 间。 【5】面向资源的架构方法很优雅的实现了一些折中。一方面，对于传统的方法来说，这些方法 可能看起来有些奇怪，从而没有尝试过。如果人们关心自己的简历，就会希望停留在尝试过的、 真正在使用的方法。另一方面，对于那些研究过Web和它的基本组成模块的人来说，它很有意义， 代表人们设想和实现过的最大、最成功的网络软件架构。 【6】Facebook：数据隐私层；跨语言的进程间通信（IPC）系统Thrift;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"book","slug":"book","permalink":"http://yoursite.com/tags/book/"}]},{"title":"《人月神话》","slug":"人月神话","date":"2019-11-23T07:10:52.000Z","updated":"2019-11-23T07:21:47.490Z","comments":true,"path":"2019/11/23/人月神话/","link":"","permalink":"http://yoursite.com/2019/11/23/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/","excerpt":"【1】由一个人来进行问题的分解，其他人给予他所需要的支持，以提高效率和生产力。 【2】系统的 体系结构（architecture） 指的是完整和详细的用户接口说明。 对于计算机，它是编程手册；对于编译器，它是语言手册； 对于控制程序，它是语言和函数调用手册；","text":"【1】由一个人来进行问题的分解，其他人给予他所需要的支持，以提高效率和生产力。 【2】系统的 体系结构（architecture） 指的是完整和详细的用户接口说明。 对于计算机，它是编程手册；对于编译器，它是语言手册； 对于控制程序，它是语言和函数调用手册； 对于整个系统，它是用户要完成自己全部工作所需参考的手册的集合。 【3】想要成功，结构师必须： a.牢记是开发人员承担创造性和发明性的实现责任， 所以结构师只能建议， 而不能支配； b.时刻准备着为所指定的说明建议 一种 实现的方法， 同样准备接受其他任何能达到目标的方法； c.对上述的建议保持低调和平静； d.准备放弃坚持所作的改进建议； 【4】一个可以开阔结构师眼界的准则是为每个小功能分配一个值：每次改进，功能 x 不超过 m字节的内存和 n微秒。这些值会在一开始作为决策的向导， 在物理实现期间充当指南和对所有人的警示。 【5】一个规格说明作者必须在仔细定义规定什么的同时，定义未规定什么。 【6】如同前面所示，形式化定义可以是一种设计实现。反之，设计实现也可以作为一种形式化定义的方法。当制造第一批兼容性的计算机时，我们使用的正是上述技术：新的机器同原有的机器一致。如果手册有一些模糊的地方？“问一问机器！ ”——设计一段程序来得到其行为，新机器必须按照上述结果运行。 【7】认识到编程需要技术积累，需要开发很多公共单元构件。每个项目要有能用于队列、搜索和排序的例程或者宏库。对于每项功能，库至少应该有两个程序实现：运行速度较快和短小精炼的。 上述的公共库开发是一件重要的实现工作， 它可以与系统设计工作并行进行。 【8】由于缺乏空间而绞尽脑汁的编程人员，常常能通过从自己的代码中挣脱出来，回顾、分析实际情况，仔细思考程序的数据，最终获得非常好的结果。实际上，数据的表现形式 是编程的根本。 【9】不变只是愿望，变化才是永恒。——SWIFT 普遍的做法是，选择一种方法，试试看；如果失败了，没关系，再试试别的。不管怎么样，重要的是先去尝试。——富兰克林 D.罗斯福 【10】每个产品都应该有数字版本号，每个版本都应该有自己的日程表和冻结日期，在此之后的变更属于下一个版本的范畴。 【11】自顶向下的设计：开始是勾画出能得到主要结果的，但比较粗略的任务定义和大概的解决方案。然后，对该定义和方案进行细致的检查，以判断结果与期望之间的差距。同时，将上述步骤的解决方案，在更细的步骤中进行分解，每一项任务定义的精化变成了解决方案中算法的精化，后者还可能伴随着数据表达方式的精化。 【12】增量模式开发系统：首先系统应该能够运行，即使未完成任何有用功能，只能正确调用一系列伪子系统。接着，系统一点一点被充实，子系统轮流被开发，或者是在更低的层次调用程序、模块、子系统的占位符（伪程序）等。 【13】向软件系统增加必要的复杂性： ​ a.层次化，通过分层的模块或者对象。 ​ b.增量化，从而系统可以持续地运行。 【14】精炼、 充分和快速的程序。 往往是 战略性 突破的结果， 而不仅仅技巧上的提高。这种突破常常是一种新型算法。更普遍的是， 战略上突破常来自于数据或表的重新表达。 数据的表现形式是编程的根本。 【15】对于大多数项目，第一个开发的系统并不合用。它可能太慢、太大，而且难以使用，或者三者兼而有之。系统的丢弃和重新设计可以一步完成， 也可以一块块地实现。 这是个 必须完成的步骤。 【16】对于大型项目， 一个对里程碑报告进行维护的 计划和控制（Plan and Control ）小组是非常可贵的。 【17】每一份发布的程序拷贝应该包括一些测试用例，其中一部分用于校验输入数据，一部分用于边界输入数据，另一部分用于无效的输入数据。 【18】增量开发模型：首先设计框架，再向框架内添加内容，保证在每一个设计阶段都有可运行的系统输出，从空的框架一步步到添加了各个功能的完整系统。 【19】设计类似一棵树的技巧是将那些变化可能性较小的设计决策放置在树的根部。这样的设计使得模块的重用最大化。更重要的是，可以延伸相同的策略，使它不但可以包括发布产品，而且还包括以增量开发策略创建的后续中间版本。这样，产品可以通过它的中间阶段，以最低限度的回溯代价增长。 【20】“从第一个里程碑开始构建”的微软流程和快速原型之间的差别是什么？功能。 第一个里程碑产品可能不包含足够的功能使任何人对它产生兴趣，而可发布产品和定义中的一样，在完整性上——配备了一系列实用的功能集，在质量上——它可以健壮地运行。 【21】人力（人）和时间（月）之间的平衡远不是线性关系，使用人月作为生产率的衡量标准实际是一个神话： ​ a.第一次发布的成本最优进度时间，T = 2. 5（M M ）1/ 3 。即，月单位的最优时间是估计工作量（人月）的立方根，估计工作量则由规 ​ 模估计和模型中的其他因子导出。最优人员配备曲线是由推导得出的。 ​ b.当计划进度比最优进度长时， 成本曲线会缓慢攀升。 时间越充裕， 花的时间也越长。 ​ c.当计划进度比最优进度短时，成本曲线急剧升高。 ​ d.无论安排多少人手， 几乎没有任何项目能够在少于 3/ 4的最优时间内获得成功！ 【22】对于项目的成功而言，项目人员的素质、人员的组织管理是比使用的工具或采用的技术方法更重要的因素。 【23】如果人们认同我在文中多处提到的观点——创造力来自于个人，而不是组织架构或者开发过程， 那么项目管理面对的中心问题是如何设计架构和流程， 来提高而不是压制主动性和创造力。 【24】通过权力委派，中心的权威实际上是得到了加强；从整体而言，组织机构实际上更加融洽和繁荣。 【25】“大多数成功的第 4 代语言是以选项和参数方式系统化某个应用领域的结果。 ”这些第 4 代语言最普遍的情况是带有查询语言、数据库以及通讯软件包的应用生成程序。 【26】软件工程的一些特殊问题: ​ a.如何把一系列程序设计和构建成 系统。 ​ b.如何把程序或者系统设计成健壮的、经过测试的、文档化的、可支持的产品。 ​ c.如何维持对大量的 复杂性 的控制。 【27】软件工程这个复杂的行业需要：进行持续的发展；学习使用更大的要素来开发；新工具的最佳使用；经论证的管理方法的最佳应用；良好判断的自由发挥；以及能够使我们认识到自己不足和容易犯错的——上帝所赐予的谦卑。 【28】乍一看,用任何规则或者原理来约束创造性思维的想法是一种阻碍, 而不是帮助, 但实际情况中完全不是这样. 规范的思维实际上是促进而不是阻碍了灵感的产生。 【29】Brooks《 人月神话 》的核心论点：由于人力的划分，大型项目遭遇的管理问题与小型项目的不同；因此，产品的概念完整性很关键；取得这种统一性是很困难，但并不是不可能的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"book","slug":"book","permalink":"http://yoursite.com/tags/book/"}]},{"title":"贪婪算法介绍","slug":"greedy","date":"2019-11-18T12:57:57.000Z","updated":"2019-11-20T08:46:36.065Z","comments":true,"path":"2019/11/18/greedy/","link":"","permalink":"http://yoursite.com/2019/11/18/greedy/","excerpt":"算法简介贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。 贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。","text":"算法简介贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。 贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。 贪婪算法并没有固定的算法解决框架，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。 必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。 比如前边介绍的最短路径问题(广度优先、狄克斯特拉)都属于贪婪算法，只是在其问题策略的选择上，刚好可以得到最优解。 基本思路其基本的解题思路为： 1.建立数学模型来描述问题 2.把求解的问题分成若干个子问题 3.对每一子问题求解，得到子问题的局部最优解 4.把子问题对应的局部最优解合成原来整个问题的一个近似最优解 案例这边的案例来自”算法图解”一书 案例一区间调度问题: 假设有如下课程，希望尽可能多的将课程安排在一间教室里： 课程 开始时间 结束时间 美术 9AM 10AM 英语 9:30AM 10:30AM 数学 10AM 11AM 计算机 10:30AM 11:30AM 音乐 11AM 12PM 这个问题看似要思考很多，实际上算法很简单: 1.选择结束最早的课，便是要在这教室上课的第一节课 2.接下来，选择第一堂课结束后才开始的课，并且结束最早的课，这将是第二节在教室上的课。 重复这样做就能找出答案，这边的选择策略便是结束最早且和上一节课不冲突的课进行排序，因为每次都选择结束最早的，所以留给后面的时间也就越多，自然就能排下越多的课了。 每一节课的选择都是策略内的局部最优解(留给后面的时间最多)，所以最终的结果也是近似最优解(这个案例上就是最优解)。 (该案例的代码实现，就是一个简单的时间遍历比较过程) 案例二背包问题：有一个背包，容量为35磅 ， 现有如下物品 物品 重量 价格 吉他 15 1500 音响 30 3000 笔记本电脑 20 2000 显示器 29 2999 笔 1 200 要求达到的目标为装入的背包的总价值最大，并且重量不超出。 方便计算所以只有3个物品，实际情况可能是成千上万。 同上使用贪婪算法，因为要总价值最大，所以每次每次都装入最贵的,然后在装入下一个最贵的，选择结果如下： 选择: 音响 + 笔，总价值 3000 + 200 = 3200 并不是最优解: 吉他 + 笔记本电脑, 总价值 1500 + 2000 = 3500 当然选择策略有时候并不是很固定，可能是如下： (1)每次挑选价值最大的,并且最终重量不超出： 选择: 音响 + 笔，总价值 3000 + 200 = 3200 (2)每次挑选重量最大的,并且最终重量不超出(可能如果要求装入最大的重量才会优先考虑)： 选择: 音响 + 笔，总价值 3000 + 200 = 3200 (3)每次挑选单位价值最大的(价格/重量),并且最终重量不超出： 选择: 笔+ 显示器，总价值 200 + 2999 = 3199 如上最终的结果并不是最优解，在这个案例中贪婪算法并无法得出最优解，只能得到近似最优解,也算是该算法的局限性之一。该类问题中需要得到最优解的话可以采取动态规划算法(后续更新，也可以关注我的公众号第一时间获取更新信息)。 案例三集合覆盖问题: 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号。 广播台 覆盖地区 K1 ID,NV,UT K2 WA,ID,MT K3 OR,NV,CA K4 NV,UT K5 CA,AZ … … 如何找出覆盖所有地区的广播台的集合呢，听起来容易，实现起来很复杂，使用穷举法实现： (1) 列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2ⁿ个【由组合及二项式定理得出：C(n,1)+C(n,2)+C(n,3)+…+C(n,n) = 2^n】 (2) 在这些集合中，选出覆盖全部地区的最小的集合，假设n不在，但是当n非常大的时候，假设每秒可以计算10个子集 广播台数量n 子集总数2ⁿ 需要的时间 5 32 3.2秒 10 1024 102.4秒 32 4294967296 13.6年 100 1.26*100³º 4x10²³年 目前并没有算法可以快速计算得到准备的值， 而使用贪婪算法，则可以得到非常接近的解，并且效率高: 选择策略上，因为需要覆盖全部地区的最小集合: (1) 选出一个广播台，即它覆盖了最多未覆盖的地区即便包含一些已覆盖的地区也没关系 (2) 重复第一步直到覆盖了全部的地区 这是一种近似算法（approximation algorithm，贪婪算法的一种）。在获取到精确的最优解需要的时间太长时，便可以使用近似算法，判断近似算法的优劣标准如下: 速度有多快 得到的近似解与最优解的接近程度 在本例中贪婪算法是个不错的选择，不仅运行速度快，本例运行时间O(n²),最坏的情况，假设n个广播台，每个广播台就覆盖1个地区,n个地区，总计需要查询n*n=O(n²),实现可查看后面的java代码实现 广播台数量n 子集总数2ⁿ 穷举需要时间 贪婪算法 5 32 3.2秒 2.5秒 10 32 102.4秒 10秒 32 32 13.6年 102.4秒 100 32 4x10²³年 1000秒 此时算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区，可能不是预期中的K2, K3,K4,K5(也许预期中的更便宜，更便于实施等等) NP完全问题案例四旅行商问题 假设有旅行商需要从下面三个城市的某一个城市出发，如何规划路线获取行程的最短路径。 存在3！(阶乘)=6种可能情况: A-&gt;B-&gt;C A-&gt;C-&gt;B B-&gt;A-&gt;C B-&gt;C-&gt;A C-&gt;A-&gt;B C-&gt;B-&gt;A 这边和之前求最短路径的算法(广度搜索、狄克斯特拉、贝尔曼-福特)，最大的差别是没有固定源点(起点),，每一个节点都可能是源点，并且需要经过每一个节点，所以若穷举法则不得不找出每一种可能并进行比较。 当城市数量为n,则可能性为n!，假设每秒处理判断一个路线 数量n 总数n! 穷举需要时间 5 120 120秒 10 32 42天 而使用贪婪算法，随机选择从一个城市出发，比如A，每次选择从最近的还没去过的城市出发,则可以得到近似最优解。 第一次比较n-1个城市 第二次比较n-2个城市 … 第n-1次比较1个城市 第n次不存在需要比较的了个 0+1+2+3+..+(n-1) ≈ O(n²/2) 数量n 总数n! 穷举需要时间 贪婪需要时间 5 120 120秒 12.5秒 10 32 42天 50秒 类似上述集合覆盖问题、旅行商问题，都属于NP完全问题，在数学领域上并没有快速得到最优解的方案，贪婪算法是最适合处理这类问题的了。 如何判断是NP完全问题的:1.元素较少时，一般运行速度很快，但随着元素数量增多，速度会变得非常慢 2.涉及到需要计算比较”所有的组合”情况的通常是NP完全问题 3.无法分割成小问题，必须考虑各种可能的情况。这可能是NP完全问题 4.如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题 5.如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题 6.如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题 小结1.贪婪算法可以寻找局部最优解，并尝试与这种方式获得全局最优解 2.得到的可能是近似最优解，但也可能便是最优解(区间调度问题，最短路径问题(广度优先、狄克斯特拉)) 3.对于完全NP问题，目前并没有快速得到最优解的解决方案 4.面临NP完全问题，最佳的做法就是使用近似算法 5.贪婪算法(近似算法)在大部分情况下易于实现，并且效率不错 JAVA 实现贪婪算法需要根据具体问题，选择对应的策略来实现，所以这边只取集合覆盖问题做个示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 贪婪算法 - 集合覆盖问题 * @author Administrator * */ public class Greedy &#123; public static void main(String[] args)&#123; //初始化广播台信息 HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;String,HashSet&lt;String&gt;&gt;(); broadcasts.put(\"K1\", new HashSet(Arrays.asList(new String[]&#123;\"ID\",\"NV\",\"UT\"&#125;))); broadcasts.put(\"K2\", new HashSet(Arrays.asList(new String[] &#123;\"WA\",\"ID\",\"MT\"&#125;))); broadcasts.put(\"K3\", new HashSet(Arrays.asList(new String[] &#123;\"OR\",\"NV\",\"CA\"&#125;))); broadcasts.put(\"K4\", new HashSet(Arrays.asList(new String[] &#123;\"NV\",\"UT\"&#125;))); broadcasts.put(\"K5\", new HashSet(Arrays.asList(new String[] &#123;\"CA\",\"AZ\"&#125;))); //需要覆盖的全部地区 HashSet&lt;String&gt; allAreas = new HashSet(Arrays.asList(new String[] &#123;\"ID\",\"NV\",\"UT\",\"WA\",\"MT\",\"OR\",\"CA\",\"AZ\"&#125;)); //所选择的广播台列表 List&lt;String&gt; selects = new ArrayList&lt;String&gt;(); HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;(); String maxKey = null; while(allAreas.size()!=0) &#123; maxKey = null; for(String key : broadcasts.keySet()) &#123; tempSet.clear(); HashSet&lt;String&gt; areas = broadcasts.get(key); tempSet.addAll(areas); //求出2个集合的交集，此时tempSet会被赋值为交集的内容，所以使用临时变量 tempSet.retainAll(allAreas); //如果该集合包含的地区数量比原本的集合多 if (tempSet.size()&gt;0 &amp;&amp; (maxKey == null || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123; maxKey = key; &#125; &#125; if (maxKey != null) &#123; selects.add(maxKey); allAreas.removeAll(broadcasts.get(maxKey)); &#125; &#125; System.out.print(\"selects:\" + selects); &#125; &#125; 执行完main方法打印信息如下: 1selects:[K1, K2, K3, K5] 参考：https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html 原文链接：https://www.jianshu.com/p/fede80bad3f1","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"SHA(安全散列算法)简单实现","slug":"sha","date":"2019-11-18T12:42:00.000Z","updated":"2019-11-18T13:20:09.270Z","comments":true,"path":"2019/11/18/sha/","link":"","permalink":"http://yoursite.com/2019/11/18/sha/","excerpt":"摘要算法：SHA 及 Java 实现样例 SHA = 安全散列算法（Secure Hash Algorithm）。 SHA 与 MD5 类似，都是单向不可逆散列函数，用于计算消息摘要，生成消息数字签名（指纹）。","text":"摘要算法：SHA 及 Java 实现样例 SHA = 安全散列算法（Secure Hash Algorithm）。 SHA 与 MD5 类似，都是单向不可逆散列函数，用于计算消息摘要，生成消息数字签名（指纹）。 Algorithm 散列值长度（单位比特） SHA-1 160 SHA-224 224 SHA-256 256 SHA-384 384 SHA-512 512 Java 实现样例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.security.MessageDigest; public class MySHA &#123; public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub String msg = \"0123456789abcdef\"; MessageDigest sha = MessageDigest.getInstance(\"SHA\"); sha.update(msg.getBytes()); byte []shaBin = sha.digest(); printBytes(shaBin); MessageDigest sha1 = MessageDigest.getInstance(\"SHA-1\"); sha1.update(msg.getBytes()); printBytes(sha1Bin); MessageDigest sha224 = MessageDigest.getInstance(\"SHA-224\"); sha224.update(msg.getBytes()); byte []sha224Bin = sha224.digest(); printBytes(sha224Bin); MessageDigest sha256 = MessageDigest.getInstance(\"SHA-256\"); sha256.update(msg.getBytes()); byte []sha256Bin = sha256.digest(); printBytes(sha256Bin); MessageDigest sha384 = MessageDigest.getInstance(\"SHA-384\"); sha384.update(msg.getBytes()); byte []sha384Bin = sha384.digest(); printBytes(sha384Bin); MessageDigest sha512 = MessageDigest.getInstance(\"SHA-512\"); sha512.update(msg.getBytes()); byte []sha512Bin = sha512.digest(); printBytes(sha512Bin); &#125; &#125; /** * 十六进制打印字节数组 * @param b byte[] */ public static void printBytes(byte[] b) &#123; for(int i=0;i&lt;b.length;i++) &#123; System.out.printf(\"%02X\", b[i]); &#125; System.out.println(); &#125; &#125; 注：散列值都是按照十六进制大写字母编码表示 很多人肯定会出来反驳，加密简单的123456可以在某些解密网站直接解密出来。 在这样的情况下，我们可以尝试在字符串追加其他文字如yangzhangyin，实际如下： 123456789101112131415161718192021222324import java.math.BigInteger; import java.security.MessageDigest; public class SHAEncryption &#123; public static byte[] encryptSHA(byte[] data, String shaN) throws Exception &#123; MessageDigest sha = MessageDigest.getInstance(shaN); sha.update(data); return sha.digest(); &#125; public static String encryptFlychordPwd(String str) &#123; byte[] outputData = new byte[0]; try &#123; outputData = encryptSHA((str+\"yangzhangyin\").getBytes(), \"SHA-256\"); return new BigInteger(1, outputData).toString(16); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"\"; &#125; public static void main(String[] args) &#123; //加密123456 System.out.println(ss.encryptFlychordPwd(\"123456\")); &#125; &#125; 这样就解决了简单密码被解密的问题啦。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Diffie-Hellman（秘钥协商算法）介绍","slug":"diffie-hellman","date":"2019-11-18T12:35:06.000Z","updated":"2019-11-19T00:48:49.698Z","comments":true,"path":"2019/11/18/diffie-hellman/","link":"","permalink":"http://yoursite.com/2019/11/18/diffie-hellman/","excerpt":"一、概述 Diffie-Hellman密钥协商算法主要解决秘钥配送问题，本身并非用来加密用的；该算法其背后有对应数学理论做支撑，简单来讲就是构造一个复杂的计算难题，使得对该问题的求解在现实的时间内无法快速有效的求解（computationally infeasible ）。","text":"一、概述 Diffie-Hellman密钥协商算法主要解决秘钥配送问题，本身并非用来加密用的；该算法其背后有对应数学理论做支撑，简单来讲就是构造一个复杂的计算难题，使得对该问题的求解在现实的时间内无法快速有效的求解（computationally infeasible ）。 理解Diffie-Hellman密钥协商的原理并不困难，只需要一点数论方面的知识既可以理解，主要会用到简单的模算术运算、本原根、费马小定理、离散对数等基础数论的知识。在现代密码学中的基础数论知识梳理中已经对这些知识做了必要的总结。 二、从何而来 DH密钥协商算法在1976年在Whitfield Diffie和Martin Hellman两人合著的论文New Directions in Cryptography（Section Ⅲ PUBLIC KEY CRYPTOGRAPHY）中被作为一种公开秘钥分发系统(public key distribution system)被提出来。原文的叙述过程比较简单，但基本阐述了算法的原理以及其可行性。 在该论文中实际上提出了一些在当时很有创新性的思想。原论文重点讨论两个话题： （1）在公网通道上如何进行安全的秘钥分派。 （2）认证（可以细分为消息认证和用户认证）。 为了解决第一个问题，原文提出两种方法：公钥加密系统(public key cryptosystem)和秘钥分发系统(public key distribution system)。对于公钥加密系统，原文只是勾画了一种比较抽象的公钥加密系统的概念模型，重点是加解密采用不同的秘钥，并总结了该系统应该满足的一些特性，相当于是一种思想实验，并没有给出具体的算法实现途径，但这在当时应该来说已经足够吸引人。后来RSA三人组（Ron Rivest、Adi Shamir 和 Leonard Adleman）受此启发，经过许多轮失败的尝试后，于第二年在论文A Method for Obtaining Digital Signatures and Public-Key Cryptosystems中提出了切实可行且很具体的公钥加密算法–RSA公钥加密算法。而对于秘钥分发系统，就是本文的DH秘钥协商算法。 为了解决第二个问题，原文通过单向函数（one-way function）来解决，这就是单向认证的问题。另外作者还讨论了这些密码学问题之间的关联性以及如何相互转化。比如一个安全的密码系统（可以防御明文攻击）可以用来生成一个的单向函数、公钥加密系统可以用来作为单向认证、陷门密码系统可以用来生成一个公钥加密系统。数学难题的计算复杂度被当成一种保障密码学安全问题的有效工具被利用起来，这一重要思想贯穿现代密码学的许多加密算法。 三、算法流程及原理 按照惯例，以Alice和Bob这两个密码学中的网红为角色，述阐DH算法的流程。 假设Alice需要与Bob协商一个秘钥（秘钥本质上就是一个比特序列，从计算的角度看就是一个大数）。 1）首先Alice与Bob共享一个素数p以及该素数p的本原根g（geneator），当然这里有2⩽g⩽p−1。这两个数是可以不经过加密地由一方发送到另一方，至于谁发送给并不重要，其结果只要保证双方都得知p和g即可。 2）然后Alice产生一个私有的随机数A，满足1⩽A⩽p−1，然后计算gAmodp=Ya，将结果Ya通过公网发送给Bob；与此同时，Bob也产生一个私有的随机数B，满足1⩽B⩽p−1，计算gBmodp=Yb，将结果Yb通过公网发送给Alice。 3）此时Alice知道的信息有p,g,A,Ya，其中数字A是Alice私有的，只有她自己知道，别人不可能知道，其他三个信息都是别人有可能知道的；Bob知道的信息有p,g,B,Yb，其中数字B是Bob私有的，只有他自己知道，别人不可能知道，其他都是别人有可能知道的。 到目前为止，Alice和Bob之间的秘钥协商结束。 Alice通过计算Ka=(Yb)Amodp得到秘钥Ka，同理，Bob通过计算Kb=(Ya)Bmodp得到秘钥Kb，此时可以证明，必然满足Ka=Kb。因此双方经过协商后得到了相同的秘钥，达成秘钥协商的目的。 证明： 对于Alice有： Ka=(Yb)Amodp=(gBmodp)Amodp=gB×Amodp 对于Bob有： Kb=(Ya)Bmodp=(gAmodp)Bmodp=gA×Bmodp 可见，Alice和Bob生成秘钥时其实是进行相同的运算过程，因此必然有Ka=Kb。”相同的运算过程”是双方能够进行秘钥协商的本质原因，类似的利用椭圆曲线进行秘钥协商也是与之相同的原理。 更严密地考虑，A和B不应该选择p−1，也就是说只能在集合{1,2,3,…,p−2}中选择。这是因为如果选择p−1，那么由费马小定理可知，情况就退化成了gp−1≡1(modp)的情况，对秘钥协商的机密性构成威胁。 所以总结起来，整个流程串起来大概就是这样： 那么窃听者Eve能否破解秘钥呢？首先要知道Eve能够得知哪些信息，显然Eve能够窃听到的信息只能有p,g,Ya,Yb，现在的问题是Eve能够通过以上信息计算出Ka或者Kb吗？要计算Ka或者Kb需要知道A或者B。 以计算A为例，Eve能根据条件gAmodp=Ya计算出A吗？实际上当p是大质数的时候，这是相当困难的，这就是离散对数问题。实际上在论文发表的当时，计算该问题的最有效的算法的时间复杂度大约是O(p–√)。也正是求解该问题在计算上的困难程度保证了DH算法的安全性。如果能够找到对数时间复杂度的算法，那么该算法即容易被攻破。 四、一个实例 1）假设Alice和Bob共享的p和g分别是p=17,g=3，显然这里g=3是p=17的一个本原根，实际上3,5,6,7,10,11,12,14都是17的本原根。 2）然后Alice选定一个私有数字，假设A=15，计算Ya=315mod17=14348907mod17=6，将6发送给Bob；同时Bob也选定一个私有的数字，假设B=13，计算Ya=313mod17=1594323mod17=12，将12发送给Alice。 3）Alice计算秘钥Ka=1215mod17=2147483647mod17=8，Bob计算秘钥Kb=613mod17=2147483647mod17=8。双方经过协商后，8最终成为双方的协商的秘钥。 实际上，当指数和模数的位数都比较大的时候，存在一种快速计算幂取模的算法叫做“反复平方算法”，实现取来也比较简单，在算法导论中第三十一章有相应的解释。 五、存在的问题 是否DH秘钥协商算法就一定安全呢？应该说也不是，因为存在一种伪装者攻击（或者称为中间人攻击）能够对这种秘钥协商算法构成威胁。 假设秘钥协商过程中，在Alice和Bob中间有一个称为Mallory的主动攻击者，他能够截获Alice和Bob的消息并伪造假消息，考虑如下情况。 1）Alice和Bob已经共享一个素数p及其该素数p的本原根g，当然Mallory监听到报文也得知了这两个消息。 2）此时Alice计算Ya=gAmodp，然而在将Ya发送给Bob的过程中被Mallory拦截，Mallory自己选定一个随机数S，计算Ysb=gSmodp，然后将Ysb发送给了Bob。 3）同时Bob计算Yb=gBmodp，然而在将Yb发送给Alice的过程中被Mallory拦截，Mallory自己选定一个随机数T，计算Yta=gTmodp，然后将Yta发送给了Alice。 由于通讯消息被替换，Alice计算出的秘钥实际上是Alice和Mallory之间协商秘钥：Kam=gA×Tmodp；Bob计算出的秘钥实际上是Bob与Mallory之间协商的秘钥：Kbm=gB×Smodp。如果之后Alice和Bob用他们计算出的秘钥加密任何信息，Mallory截获之后都能够解密得到明文，而且Mallory完全可以伪装成Alice或者Bob给对方发消息。 六、References 1、New Directions in Cryptography 2、密码编码学与网络安全原理与实践 3、图解密码技术 原文出处：http://www.cnblogs.com/qcblog/p/9016704.html","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"Simhash算法介绍","slug":"simhash","date":"2019-11-18T12:20:56.000Z","updated":"2019-11-19T00:54:23.971Z","comments":true,"path":"2019/11/18/simhash/","link":"","permalink":"http://yoursite.com/2019/11/18/simhash/","excerpt":"Simhash的生成及存储 一、背景介绍 根据 Detecting Near-Duplicates for Web Crawling 论文中的介绍，在互联网中有很多网页的内容是一样的，但是它们的网页元素却不是完全相同的。每个域名下的网页总会有一些自己的东西，比如广告、导航栏、网站版权之类的东西，但是对于搜索引擎来讲，只有内容部分才是有意义的，虽然网页元素不同，但是对搜索结果没有任何影响，所以在判定内容是否重复的时候，应该忽视后面的部分。当新爬取的内容和数据库中的某个网页的内容一样的时候，就称其为Near-Duplicates（重复文章）。对于重复文章，不应再执行入库操作，这种操作的优点是(A)节省带宽、(B)节省磁盘、(C)减轻服务器负荷以及(D)去除相似文章噪点干扰，提升索引的质量。","text":"Simhash的生成及存储 一、背景介绍 根据 Detecting Near-Duplicates for Web Crawling 论文中的介绍，在互联网中有很多网页的内容是一样的，但是它们的网页元素却不是完全相同的。每个域名下的网页总会有一些自己的东西，比如广告、导航栏、网站版权之类的东西，但是对于搜索引擎来讲，只有内容部分才是有意义的，虽然网页元素不同，但是对搜索结果没有任何影响，所以在判定内容是否重复的时候，应该忽视后面的部分。当新爬取的内容和数据库中的某个网页的内容一样的时候，就称其为Near-Duplicates（重复文章）。对于重复文章，不应再执行入库操作，这种操作的优点是(A)节省带宽、(B)节省磁盘、(C)减轻服务器负荷以及(D)去除相似文章噪点干扰，提升索引的质量。 在现实中，一模一样的网页的概率是很小的，大部分的相似网页都会存在一些细节的变化，而如何进行这种判定就是一个本文要解决的一个问题。除了近似文章判定算法的难题，还有以下待解决的难点（按照80亿篇文章来考虑）： 数据规模巨大，对于海量数据如何存储 查找速度，如何做到在毫秒级别返回检索结果 二、simhash介绍 simhash是由 Charikar 在2002年提出来的，它是一种能计算文档相似度的hash算法，google用它来进行海量文本去重工作。simhash属于局部敏感型（locality sensitive hash）的一种，其主要思想是降维，将高维的特征向量转化成一个f位的指纹（fingerprint），通过算出两个指纹的海明距离（hamming distince）来确定两篇文章的相似度，海明距离越小，相似度越低（根据 Detecting Near-Duplicates for Web Crawling 论文中所说），一般海明距离为3就代表两篇文章相同。 simhash也有其局限性，在处理小于500字的短文本时，simhash的表现并不是很好，所以在使用simhash前一定要注意这个细节。 三、simhash与hash算法的区别 传统Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统hash算法产生的两个签名，如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。 我们主要解决的是文本相似度计算，要比较的是两个文章是否相似，当然我们降维生成了hash签名也是用于这个目的。看到这里，估计大家就明白了，即使把文章中的字符串变成 01 串，我们使用的simhash算法也还是可以用于计算相似度，而传统的hash却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。 通过simhash计算结果为： 1000010010101101111111100000101011010001001111100001001011001011 1000010010101101011111100000101011010001001111100001101010001011 通过传统hash计算为： 0001000001100110100111011011110 1010010001111111110010110011101 大家可以看得出来，相似的文本只有部分 01 串变化了，而普通的hash却不能做到，这个就是局部敏感哈希的魅力。 四、simhash的生成 simhash的生成图解如下图： 为了更加通俗易懂，采用例子来详解simhash的生成规则。simhash的生成划分为五个步骤：分词-&gt;hash-&gt;加权-&gt;合并-&gt;降维 1：分词。首先，判断文本分词，形成这个文章的特征单词。然后，形成去掉噪音词的单词序列。最后，为每个分词加上权重。我们假设权重分为5个级别（1~5），比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==&gt; 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。 2：hash。通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101，“51区”通过hash算法计算为 101011。这样，我们的字符串就变成了一串串数字，还记得文章开头说过的吗？要把文章变为数字计算，才能提高相似度计算性能，现在是降维过程进行时。 3：加权。在第2步骤hash生成结果后，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。 4：合并。把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实的计算需要把所有单词的序列串累加。 5：降维。把第4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于或等于0 则记为 0。最后算出结果为：“1 0 1 0 1 1”。 整个过程的流程图为： 五、simhash分表存储策略 在线上查询算法中，首先建立多个指纹表:T1，T2，√…，Tt。每个指纹表 Ti 关联两个未知数：一个整型pi和一个在f bit-positions上的排列πi，Ti就是对已经存在的所有指纹进行排列πi得到的有序集合。对于一个指纹f和一个整数k，算法分两个步骤： 1 找到Ti中所有的前pi个bit-positions和πi（F）的前pi个bit-positions相同的指纹，假设为指纹集合F。 2 在F中的每一个指纹，比较其是否和πi（F）有的差异不超过k个。 分表存储原理 借鉴“hashmap算法找出可以hash的key值”。因为我们使用的simhash是局部敏感哈希，这个算法的特点是：只要相似的字符串，只有个别的位数是有差别变化的。这样，我们可以推断两个相似的文本，至少有16位的simhash是一样的。 分表存储设计 假设f = 64 ，k=3，并且我们有80亿 = 2^34个数的网页指纹，d=34，可以有下面四种设计方法 （f：指纹位数，k：海明距离，d：将文章数量转化成2的幂次方，d就是幂值） 1.20个表：将64bit分为11,11,11,11,10,10六个bit块。根据排列组合，如果想从这6个块中找3个作为leading bits的话（这样才能满足|pi-d|是个小整数），一共有C(6,3)=20种找法，所以需要20个表，每个表的前三块来自不同的三个块，那么pi就有11+11+11、11+ 11+10和11+10+10三种可能了。一次嗅探平均需要检索2^(34-31)=8个指纹。 2.16个表：先将64bit均分成4份，然后针对每份，将剩余的48bit再均分成四份，也就是16,12,12,12,12,12五部分，很明显这种组合的可能是4*4，而pi = 28。一次嗅探平均需要检索2^(34-28)=64个指纹。 3.10个表：将64bit分成 13，13，13，13，12 五个bit快。根据排列组合，需要从5块中找到2个作为leading bits，共有C(5,2)=10种找法，需要10张表，而pi=25或26。一次嗅探平均需要检索2^(34-25)=512个指纹。 4.4个表：同理 64 等分为4份，每份16bit，从四份中找出1个leading bits，共有C(4,1)=4种找法，pi=16,一次嗅探平均需要检索2^(34-16)=256K个指纹。 分表存储实现 存储： 1、将一个64位的simhash签名拆分成4个16位的二进制码。（图上红色的16位） 2、分别拿这4个16位二进制码查找当前对应位置上是否有元素。（放大后的16位） 3、对应位置没有元素，直接追加到链表上；对应位置有则直接追加到链表尾端。（图上的 S1 — SN） 查找： 1、将需要比较的simhash签名拆分成4个16位的二进制码。 2、分别拿着4个16位二进制码每一个去查找simhash集合对应位置上是否有元素。 3、如果有元素，则把链表拿出来顺序查找比较，直到simhash小于一定大小的值，整个过程完成。 原理： 借鉴“hashmap算法找出可以hash的key值”。因为我们使用的simhash是局部敏感哈希，这个算法的特点是：只要相似的字符串，只有个别的位数是有差别变化的。那这样我们可以推断两个相似的文本，至少有16位的simhash是一样的。具体选择16位、8位、4位，大家根据自己的数据测试选择，虽然比较的位数越小越精准，但是空间会变大。分为4个16位段的存储空间是单独simhash存储空间的4倍。之前算出5000w数据是 382 Mb，扩大4倍1.5G左右，还可以接受 最佳分表策略 根据 4.2节分表存储设计，给定 f,k 我们可以有很多种分表的方式，增加表的个数会减少检索时间，但是会增加内存的消耗，相反的，减少表的个数，会减少内存的压力，但是会增加检索时间。 根据google大量的实验，存在一个分表策略满足时间和空间的平衡点 τ=d-pi （pi计算看4.2章节，取最小pi） simhash存储实现(Go) 国外有一大神用go实现了d=3和6的实现，在他的基础上我实现了d到8的扩展，源码请看https://github.com/kricen/shstorage 参考文章 论文 Detecting Near-Duplicates for Web Crawling http://www.cnblogs.com/maybe2030/p/5203186.html 原文链接：https://kricen.github.io/2018/03/06/perday/simhash/","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"如何使用 Disruptor（三）","slug":"disruptor3","date":"2019-11-18T12:03:12.000Z","updated":"2019-11-19T00:50:59.661Z","comments":true,"path":"2019/11/18/disruptor3/","link":"","permalink":"http://yoursite.com/2019/11/18/disruptor3/","excerpt":"写入 Ringbuffer 本文的重点是：不要让 Ring 重叠；如何通知消费者；生产者一端的批处理；以及多个生产者如何协同工作。 作者：Trisha 廖涵译 这是 Disruptor 全方位解析（end-to-end view）中缺少的一章。当心，本文非常长。但是为了让你能联系上下文阅读，我还是决定把它们写进一篇博客里。","text":"写入 Ringbuffer 本文的重点是：不要让 Ring 重叠；如何通知消费者；生产者一端的批处理；以及多个生产者如何协同工作。 作者：Trisha 廖涵译 这是 Disruptor 全方位解析（end-to-end view）中缺少的一章。当心，本文非常长。但是为了让你能联系上下文阅读，我还是决定把它们写进一篇博客里。 本文的 重点 是：不要让 Ring 重叠；如何通知消费者；生产者一端的批处理；以及多个生产者如何协同工作。 ProducerBarriers Disruptor 代码 给 消费者 提供了一些接口和辅助类，但是没有给写入 Ring Buffer 的 生产者 提供接口。这是因为除了你需要知道生产者之外，没有别人需要访问它。尽管如此，Ring Buffer 还是与消费端一样提供了一个 ProducerBarrier 对象，让生产者通过它来写入 Ring Buffer。 写入 Ring Buffer 的过程涉及到两阶段提交 (two-phase commit)。首先，你的生产者需要申请 buffer 里的下一个节点。然后，当生产者向节点写完数据，它将会调用 ProducerBarrier 的 commit 方法。 那么让我们首先来看看第一步。 “给我 Ring Buffer 里的下一个节点”，这句话听起来很简单。的确，从生产者角度来看它很简单：简单地调用 ProducerBarrier 的 nextEntry() 方法，这样会返回给你一个 Entry 对象，这个对象就是 Ring Buffer 的下一个节点。 ProducerBarrier 如何防止 Ring Buffer 重叠 在后台，由 ProducerBarrier 负责所有的交互细节来从 Ring Buffer 中找到下一个节点，然后才允许生产者向它写入数据。 （我不确定 闪闪发亮的新手写板 能否有助于提高我画图片的清晰度，但是它用起来很有意思）。 在这幅图中，我们假设只有一个生产者写入 Ring Buffer。过一会儿我们再处理多个生产者的复杂问题。 ConsumerTrackingProducerBarrier 对象拥有所有正在访问 Ring Buffer 的 消费者 列 表。这看起来有点儿奇怪－我从没有期望 ProducerBarrier 了解任何有关消费端那边的事情。但是等等，这是有原因的。因为我们不想与队列“混为一谈”（队列需要追踪队列的头和尾，它们有时候会指向相同的位 置），Disruptor 由消费者负责通知它们处理到了哪个序列号，而不是 Ring Buffer。所以，如果我们想确定我们没有让 Ring Buffer 重叠，需要检查所有的消费者们都读到了哪里。 在上图中，有一个 消费者 顺利的读到了最大序号 12（用红色/粉色高亮）。第二个消费者 有点儿落后——可能它在做 I/O 操作之类的——它停在序号 3。因此消费者 2 在赶上消费者 1 之前要跑完整个 Ring Buffer 一圈的距离。 现在生产者想要写入 Ring Buffer 中序号 3 占据的节点，因为它是 Ring Buffer 当前游标的下一个节点。但是 ProducerBarrier 明白现在不能写入，因为有一个消费者正在占用它。所以，ProducerBarrier 停下来自旋 (spins)，等待，直到那个消费者离开。 申请下一个节点 现在可以想像消费者 2 已经处理完了一批节点，并且向前移动了它的序号。可能它挪到了序号 9（因为消费端的批处理方式，现实中我会预计它到达 12，但那样的话这个例子就不够有趣了）。 上图显示了当消费者 2 挪动到序号 9 时发生的情况。在这张图中我已经忽略了ConsumerBarrier，因为它没有参与这个场景。 ProducerBarier 会看到下一个节点——序号 3 那个已经可以用了。它会抢占这个节点上的 Entry（我还没有特别介绍 Entry 对象，基本上它是一个放写入到某个序号的 Ring Buffer 数据的桶），把下一个序号（13）更新成 Entry 的序号，然后把 Entry 返回给生产者。生产者可以接着往 Entry 里写入数据。 提交新的数据 两阶段提交的第二步是——对，提交。 绿色表示最近写入的 Entry，序号是 13 ——厄，抱歉，我也是红绿色盲。但是其他颜色甚至更糟糕。 当生产者结束向 Entry 写入数据后，它会要求 ProducerBarrier 提交。 ProducerBarrier 先等待 Ring Buffer 的游标追上当前的位置（对于单生产者这毫无意义－比如，我们已经知道游标到了 12 ，而且没有其他人正在写入 Ring Buffer）。然后 ProducerBarrier 更新 Ring Buffer 的游标到刚才写入的 Entry 序号－在我们这儿是 13。接下来，ProducerBarrier 会让消费者知道 buffer 中有新东西了。它戳一下 ConsumerBarrier 上的 WaitStrategy 对象说－“喂，醒醒！有事情发生了！”（注意－不同的 WaitStrategy 实现以不同的方式来实现提醒，取决于它是否采用阻塞模式。） 现在消费者 1 可以读 Entry 13 的数据，消费者 2 可以读 Entry 13 以及前面的所有数据，然后它们都过得很 happy。 ProducerBarrier 上的批处理 有趣的是 Disruptor 可以同时在生产者和 消费者 两端实现批处理。还记得伴随着程序运行，消费者 2 最后达到了序号 9 吗？ProducerBarrier 可以在这里做一件很狡猾的事－它知道 Ring Buffer 的大小，也知道最慢的消费者位置。因此它能够发现当前有哪些节点是可用的。 如果 ProducerBarrier 知道 Ring Buffer 的游标指向 12，而最慢的消费者在 9 的位置，它就可以让生产者写入节点 3，4，5，6，7 和 8，中间不需要再次检查消费者的位置。 多个生产者的场景 到这里你也许会以为我讲完了，但其实还有一些细节。 在上面的图中我稍微撒了个谎。我暗示了 ProducerBarrier 拿到的序号直接来自 Ring Buffer 的游标。然而，如果你看过代码的话，你会发现它是通过 ClaimStrategy 获取的。我省略这个对象是为了简化示意图，在单个生产者的情况下它不是很重要。 在多个生产者的场景下，你还需要其他东西来追踪序号。这个序号是指当前可写入的序号。注意这和“向 Ring Buffer 的游标加 1”不一样－如果你有一个以上的生产者同时在向 Ring Buffer 写入，就有可能出现某些 Entry 正在被生产者写入但还没有提交的情况。 让我们复习一下如何申请写入节点。每个生产者都向 ClaimStrategy 申请下一个可用的节点。生产者 1 拿到序号 13，这和上面单个生产者的情况一样。生产者 2 拿到序号 14，尽管 Ring Buffer的当前游标仅仅指向 12。这是因为 ClaimSequence 不但负责分发序号，而且负责跟踪哪些序号已经被分配。 现在每个生产者都拥有自己的写入节点和一个崭新的序号。 我把生产者 1 和它的写入节点涂上绿色，把生产者 2 和它的写入节点涂上可疑的粉色－看起来像紫色。 现在假设生产者 1 还生活在童话里，因为某些原因没有来得及提交数据。生产者 2 已经准备好提交了，并且向 ProducerBarrier 发出了请求。 就像我们先前在 commit 示意图中看到的一样，ProducerBarrier 只有在 Ring Buffer 游标到达准备提交的节点的前一个节点时它才会提交。在当前情况下，游标必须先到达序号 13 我们才能提交节点 14 的数据。但是我们不能这样做，因为生产者 1 正盯着一些闪闪发光的东西，还没来得及提交。因此 ClaimStrategy 就停在那儿自旋 (spins)， 直到 Ring Buffer 游标到达它应该在的位置。 现在生产者 1 从迷糊中清醒过来并且申请提交节点 13 的数据（生产者 1 发出的绿色箭头代表这个请求）。ProducerBarrier 让 ClaimStrategy 先等待 Ring Buffer 的游标到达序号 12，当然现在已经到了。因此 Ring Buffer 移动游标到 13，让 ProducerBarrier 戳一下 WaitStrategy 告诉所有人都知道 Ring Buffer 有更新了。现在 ProducerBarrier 可以完成生产者 2 的请求，让 Ring Buffer 移动游标到 14，并且通知所有人都知道。 你会看到，尽管生产者在不同的时间完成数据写入，但是 Ring Buffer 的内容顺序总是会遵循 nextEntry() 的初始调用顺序。也就是说，如果一个生产者在写入 Ring Buffer 的时候暂停了，只有当它解除暂停后，其他等待中的提交才会立即执行。 呼——。我终于设法讲完了这一切的内容并且一次也没有提到内存屏障（Memory Barrier）。 更新：最近的 RingBuffer 版本去掉了 Producer Barrier。如果在你看的代码里找不到 ProducerBarrier，那就假设当我讲“Producer Barrier”时，我的意思是“Ring Buffer”。 更新2：注意 Disruptor 2.0 版使用了与本文不一样的命名。如果你对类名感到困惑，请阅读我写的Disruptor 2.0更新摘要。 原文链接：http://ifeve.com/dissecting-the-disruptor-writing-to-the-ring-buffer/ 译文链接：http://ifeve.com/disruptor-writing-ringbuffer/","categories":[],"tags":[{"name":"concurrent","slug":"concurrent","permalink":"http://yoursite.com/tags/concurrent/"}]},{"title":"如何使用Disruptor（二）","slug":"disruptor2","date":"2019-11-18T11:57:31.000Z","updated":"2019-11-19T00:49:59.458Z","comments":true,"path":"2019/11/18/disruptor2/","link":"","permalink":"http://yoursite.com/2019/11/18/disruptor2/","excerpt":"从Ringbuffer读取数据 从上一篇文章中我们都了解了什么是Ring Buffer以及它是如何的特别。但遗憾的是，我还没有讲述如何使用Disruptor向Ring Buffer写数据和从Ring Buffer中读取数据。 从上一篇文章中我们都了解了什么是Ring Buffer以及它是如何的特别。但遗憾的是，我还没有讲述如何使用Disruptor向Ring Buffer写数据和从Ring Buffer中读取数据。","text":"从Ringbuffer读取数据 从上一篇文章中我们都了解了什么是Ring Buffer以及它是如何的特别。但遗憾的是，我还没有讲述如何使用Disruptor向Ring Buffer写数据和从Ring Buffer中读取数据。 从上一篇文章中我们都了解了什么是Ring Buffer以及它是如何的特别。但遗憾的是，我还没有讲述如何使用Disruptor向Ring Buffer写数据和从Ring Buffer中读取数据。 ConsumerBarrier与消费者 这里我要稍微反过来介绍，因为总的来说读取数据这一过程比写数据要容易理解。假设通过一些“魔法”已经把数据写入到Ring Buffer了，怎样从Ring Buffer读出这些数据呢？ (好，我开始后悔使用Paint/Gimp 了。尽管这是个购买绘图板的好借口，如果我继续写下去的话… UML界的权威们大概也在诅咒我的名字了。) 消费者(Consumer)是一个想从Ring Buffer里读取数据的线程，它可以访问ConsumerBarrier对象——这个对象由RingBuffer创建并且代表消费者与RingBuffer进行交互。就像Ring Buffer显然需要一个序号才能找到下一个可用节点一样，消费者也需要知道它将要处理的序号——每个消费者都需要找到下一个它要访问的序号。在上面的例子中，消费者处理完了Ring Buffer里序号8之前（包括8）的所有数据，那么它期待访问的下一个序号是9。 消费者可以调用ConsumerBarrier对象的waitFor()方法，传递它所需要的下一个序号. 1final long availableSeq = consumerBarrier.waitFor(nextSequence); ConsumerBarrier返回RingBuffer的最大可访问序号——在上面的例子中是12。ConsumerBarrier有一个WaitStrategy方法来决定它如何等待这个序号，我现在不会去描述它的细节，代码的注释里已经概括了每一种WaitStrategy的优点和缺点 。 接下来怎么做？ 接下来，消费者会一直原地停留，等待更多数据被写入Ring Buffer。并且，一旦数据写入后消费者会收到通知——节点9，10，11和12 已写入。现在序号12到了，消费者可以让ConsumerBarrier去拿这些序号节点里的数据了。 拿到了数据后，消费者(Consumer)会更新自己的标识(cursor)。 你应该已经感觉得到，这样做是怎样有助于平缓延迟的峰值了——以前需要逐个节点地询问“我可以拿下一个数据吗？现在可以了么？现在呢？”，消费者(Consumer)现在只需要简单的说“当你拿到的数字比我这个要大的时候请告诉我”，函数返回值会告诉它有多少个新的节点可以读取数据了。因为这些新的节点的确已经写入了数据（Ring Buffer本身的序号已经更新），而且消费者对这些节点的唯一操作是读而不是写，因此访问不用加锁。这太好了，不仅代码实现起来可以更加安全和简单，而且不用加锁使得速度更快。 另一个好处是——你可以用多个消费者(Consumer)去读同一个RingBuffer ，不需要加锁，也不需要用另外的队列来协调不同的线程(消费者)。这样你可以在Disruptor的协调下实现真正的并发数据处理。 BatchConsumer代码是一个消费者的例子。如果你实现了BatchHandler, 你可以用BatchConsumer来完成上面我提到的复杂工作。它很容易对付那些需要成批处理的节点（例如上文中要处理的9-12节点）而不用单独地去读取每一个节点。 更新：注意Disruptor 2.0版本使用了与本文不一样的命名。如果你对类名感到困惑，请阅读我的变更总结。 原文链接：http://ifeve.com/dissecting-the-disruptor-how-do-i-read-from-the-ring-buffer/ 译文链接：http://ifeve.com/dissecting_the_disruptor_how_doi_read_from_the_ring_buffer/","categories":[],"tags":[{"name":"concurrent","slug":"concurrent","permalink":"http://yoursite.com/tags/concurrent/"}]},{"title":"如何使用Disruptor（一）","slug":"disruptor1","date":"2019-11-18T11:35:08.000Z","updated":"2019-11-19T00:49:31.187Z","comments":true,"path":"2019/11/18/disruptor1/","link":"","permalink":"http://yoursite.com/2019/11/18/disruptor1/","excerpt":"Ringbuffer的特别之处 首先介绍ringbuffer。我对Disruptor的最初印象就是ringbuffer。但是后来我意识到尽管ringbuffer是整个模式（Disruptor）的核心，但是Disruptor对ringbuffer的访问控制策略才是真正的关键点所在。 作者：Trisha 寒桐译 最近，我们开源了LMAX Disruptor， 它是我们的交易系统吞吐量快（LMAX是一个新型的交易平台，","text":"Ringbuffer的特别之处 首先介绍ringbuffer。我对Disruptor的最初印象就是ringbuffer。但是后来我意识到尽管ringbuffer是整个模式（Disruptor）的核心，但是Disruptor对ringbuffer的访问控制策略才是真正的关键点所在。 作者：Trisha 寒桐译 最近，我们开源了LMAX Disruptor， 它是我们的交易系统吞吐量快（LMAX是一个新型的交易平台， 号称能够单线程每秒处理数百万的订单）的关键原因。为什么我们要将其开源？我们意识到对高性能编程领域的一些传统观点，有点不对劲。我们找到了一种更好、更快地在线程间共享数据的方法，如果不公开于业界共享的话，那未免太自私了。同时开源也让我 们觉得看起来更酷。 从这个站点，你可以下载到一篇解释什么是Disruptor及它为什么如此高性能的文档。这篇文档的编写过程，我并没有参与太多，只是简单地插入了一些标点符号和重组了一些我不懂的句子，但是非常高兴的是，我仍然从中提升了自己的写作水平。 我发现要把所有的事情一下子全部解释清楚还是有点困难的，所有我准备一部分一部分地解释它们，以适合我的NADD听众。 首先介绍ringbuffer。我对Disruptor的最初印象就是ringbuffer。但是后来我意识到尽管ringbuffer是整个模式（Disruptor）的核心，但是Disruptor对ringbuffer的访问控制策略才是真正的关键点所在。 ringbuffer到底是什么？ 嗯，正如名字所说的一样，它是一个环（首尾相接的环），你可以把它用做在不同上下文（线程）间传递数据的buffer。 （好吧，这是我通过画图板手画的，我试着画草图，希望我的强迫症不会让我画完美的圆和直线） 基本来说，ringbuffer拥有一个序号，这个序号指向数组中下一个可用的元素。（校对注：如下图右边的图片表示序号，这个序号指向数组的索引4的位置。） 随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。 要找到数组中当前序号指向的元素，可以通过mod操作： sequence mod array length = array index 以上面的ringbuffer为例（java的mod语法）：12 % 10 = 2。很简单吧。 事实上，上图中的ringbuffer只有10个槽完全是个意外。如果槽的个数是2的N次方更有利于基于二进制的计算机进行计算。 （校对注：2的N次方换成二进制就是1000，100，10，1这样的数字， sequence &amp; （array length－1） = array index，比如一共有8槽，3&amp;（8－1）=3，HashMap就是用这个方式来定位数组元素的，这种方式比取模的速度更快。） 那又怎么样？ 如果你看了维基百科里面的关于环形buffer的 词条，你就会发现，我们的实现方式，与其最大的区别在于：没有尾指针。我们只维护了一个指向下一个可用位置的序号。这种实现是经过深思熟虑的—我们选择用 环形buffer的最初原因就是想要提供可靠的消息传递。我们需要将已经被服务发送过的消息保存起来，这样当另外一个服务通过nak (校对注：拒绝应答信号)告诉我们没有成功收到消息时，我们能够重新发送给他们。 听起来，环形buffer非常适合这个场景。它维护了一个指向尾部的序号，当收到nak(校对注：拒绝应答信号)请求，可以重发从那一点到当前序号之间的所有消息： 我们实现的ring buffer和大家常用的队列之间的区别是，我们不删除buffer中的数据，也就是说这些数据一直存放在buffer中，直到新的数据覆盖他们。这就是 和维基百科版本相比，我们不需要尾指针的原因。ringbuffer本身并不控制是否需要重叠（决定是否重叠是生产者-消费者行为模式的一部分–如果你等 不急我写blog来说明它们，那么可以自行检出Disruptor项目）。 它为什么如此优秀？ 之所以ringbuffer采用这种数据结构，是因为它在可靠消息传递方面有很好的性能。这就够了，不过它还有一些其他的优点。 首先，因为它是数组，所以要比链表快，而且有一个容易预测的访问模式。（译者注：数组内元素的内存地址的连续性存储的）。这是对CPU缓存友好的—也就是说，在硬件级别，数组中的元素是会被预加载的，因此在ringbuffer当中，cpu无需时不时去主存加载数组中的下一个元素。（校对注：因为只要一个元素被加载到缓存行，其他相邻的几个元素也会被加载进同一个缓存行） 其次，你可以为数组预先分配内存，使得数组对象一直存在（除非程序终止）。这就意味着不需要花大量的时间用于垃圾回收。此外，不像链表那样，需要为每一个添加到其上面的对象创造节点对象—对应的，当删除节点时，需要执行相应的内存清理操作。 缺少的部分 我并没有在本文中介绍如何避免ringbuffer产生重叠，以及如何对ringbuffer进行读写操作。你可能注意到了我将ringbuffer和链表那样的数据结构进行比较，因为我并认为链表是实际问题的标准答案。 当你将Disruptor和基于 队列之类的实现进行比较时，事情将变得很有趣。队列通常注重维护队列的头尾元素，添加和删除元素等。所有的这些我都没有在ringbuffer里提到，这 是因为ringbuffer不负责这些事情，我们把这些操作都移到了数据结构（ringbuffer）的外部 原文链接：http://ifeve.com/ringbuffer/ 译文链接：http://ifeve.com/dissecting-disruptor-whats-so-special/","categories":[],"tags":[{"name":"concurrent","slug":"concurrent","permalink":"http://yoursite.com/tags/concurrent/"}]},{"title":"TF-IDF算法介绍","slug":"TF-IDF","date":"2019-11-18T11:14:08.000Z","updated":"2019-11-19T00:55:01.350Z","comments":true,"path":"2019/11/18/TF-IDF/","link":"","permalink":"http://yoursite.com/2019/11/18/TF-IDF/","excerpt":"TF-IDF是什么 TF-IDF是一种统计方法，用以评估一个词对于一篇文章或语料库中一篇文章的重要性。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。 TF-IDF的使用场景 TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了TF-IDF以外，因特网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜寻结果中出现的顺序。","text":"TF-IDF是什么 TF-IDF是一种统计方法，用以评估一个词对于一篇文章或语料库中一篇文章的重要性。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。 TF-IDF的使用场景 TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了TF-IDF以外，因特网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜寻结果中出现的顺序。 TF-IDF原理 TF（Term Frequency) 表示词频，即一个词在在一篇文章中出现的次数，但在实际应用时会有一个漏洞，就是篇幅长的文章给定词出现的次数会更多一点。因此我们需要对次数进行归一化，通常用给定词的次数除以文章的总词数。 这其中还有一个漏洞，就是 ”的“ ”是“ ”啊“ 等类似的词在文章中出现的此时是非常多的，但是这些大多都是没有意义词，对于判断文章的关键词几乎没有什么用处，我们称这些词为”停用词“，也就是说，在度量相关性的时候不应该考虑这些词的频率。 IDF（Inverse Document Frequency）逆文本频率指数，如果包含关键词w的文档越少，则说明关键词w具有很好的类别区分能力。某一关键词的IDF，可以用总的文章数量除以包含该关键词的文章的数量，然后对结果取对数得到 注：分母加1是为了避免没有包含关键词的文章时分母是0的情况 一个词预测主题的能力越强，权重就越大，反之，权重越小，因此一个词的TF-IDF就是： 实际应用 通常在新闻的分类，或者说文章的分类的时候我们会用到ID-IDF。如果让编辑来对新闻或者文章分类，他一定要先读懂文章，然后找出主题，最后根据主题的不同对文章进行分类。而让电脑对文章进行分类，就要求我们先把文字的文章变成一组可以计算的数字，然后通过算法来算出文章的相似性。 首先我们先来看怎么用一组数字（或者说一个向量）来表示一篇文章。对于一篇文章的所有实词（除去无意义的停用词），计算出他们的TF-IDF值，把这些值按照对应的实词在词汇表的位置依次排列，就得到了一个向量。比如，词汇表中有64000个词，其编号和词： 单词编号 汉字词 1 阿 2 啊 … … 789 服装 … … 64000 做作 在某一篇文章中，文章中的词的TF-IDF值对应为： 单词编号 TF-IDF 1 0 2 0.0034 … … 789 0.034 … … 64000 0.075 如果单词表的某个词在文章中没有出现，对应的值为零，这样我们就得到了一个64000维的向量，我们称为这篇文章的特征向量。然后每篇文章就可以用一个向量来表示，这样我们就可以计算文章之间的相似程度了。 向量的夹角是衡量两个向量相近程度的度量。因此，可以通过计算两篇文章的特征向量的夹角来判断两篇文章的主题的接近程度。那么我们就需要用余弦地理了。 ∠A的余弦值为： 如果将三角形的两边b和c看成是两个以A为起点的向量，那么上述公式等于： 其中，分母便是两个向量b和c的长度，分子表示两个向量的内积。假设文章X和文章Y对应的向量是 那么他们的夹角的余弦等于 由于向量中的每一个变量都是正数，所以余弦的取值在0到1之间。当两篇文章向量的余弦等于1时，这两个向量夹角为零，两篇文章完全相同；当夹角的余弦接近于1时两篇文章越相似，从而可以归成一类；夹角的余弦越小，夹角越大，两篇文章越不相关。 现在假定我们已知一些文章的特征向量，那么对于任何一个要被分类的文章，就很容易计算出它和各类文章的余弦相似性，并将其归入它该去的那一类中。 如果事先没有已知的文章的特征向量呢，可以用自底向上不断合并的方法。 计算所有文章之间凉凉的余弦相似性，把相似性大于一个阈值的合并成一小类 把每个小类中的所有文章作为一个整体，计算小类的特征向量，在计算小雷之间两两的余弦相似性，然后合并成一个大类 这样不断做下去，类别越来越少，而每个类越来越大。当某一类太大时，这一类里的文章的相似性就很小了，这时就要停止迭代过程了，然后完成分类。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"工具网站收藏","slug":"useful-website","date":"2019-11-18T08:28:03.000Z","updated":"2019-11-19T00:55:23.613Z","comments":true,"path":"2019/11/18/useful-website/","link":"","permalink":"http://yoursite.com/2019/11/18/useful-website/","excerpt":"Part1:前端工具 【1】字体图标生成网站：IconMoon：https://icomoon.io/ 【2】reset 和 globle CSS：https://meyerweb.com/eric/tools/css/reset/ 【3】阿里巴巴矢量图标库：https://www.iconfont.cn/","text":"Part1:前端工具 【1】字体图标生成网站：IconMoon：https://icomoon.io/ 【2】reset 和 globle CSS：https://meyerweb.com/eric/tools/css/reset/ 【3】阿里巴巴矢量图标库：https://www.iconfont.cn/ 【4】EChart：https://echarts.baidu.com/ 【5】iView：https://www.iviewui.com/ Part2:视频教程 【1】慕课网：https://www.imooc.com/ 【2】Siki学院：http://www.sikiedu.com/ 【3】Bilibili：https://www.bilibili.com/ Part3:实用网站 【1】国家哲学社会科学文献中心：http://www.ncpssd.org 【2】MSDN，我告诉你： https://msdn.itellyou.cn/","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"树莓派镜像制作","slug":"raspberry-blog1","date":"2019-11-18T05:21:43.000Z","updated":"2019-11-19T00:51:45.808Z","comments":true,"path":"2019/11/18/raspberry-blog1/","link":"","permalink":"http://yoursite.com/2019/11/18/raspberry-blog1/","excerpt":"【1】树莓派原始镜像烧录。 【2】中文字库以及中文拼音输入法下载： 启动后，开启Terminal终端，出现提示符时输入： 1sudo apt-get install ttf-wqy-zenhei","text":"【1】树莓派原始镜像烧录。 【2】中文字库以及中文拼音输入法下载： 启动后，开启Terminal终端，出现提示符时输入： 1sudo apt-get install ttf-wqy-zenhei 将安装文泉驿的开源中文字体，在这里向文泉驿表示致敬，貌似它是唯一一个开源的中文字体库。郭嘉有钱建孔子学院，但是从来不会有钱搞一套比较完整的开源中文字库出来的。 中文是可以显示啦，输入呢？Linux下早就有啦，叫SCIM（Smart Common Input Method ），所以只要输入： 1sudo apt-get install scim-pinyin 就会安装拼音输入法，安装完成后，可以直接打入scim激活，下次启动是会自动启动的。快捷键也是Ctrl+空格。或者直接点击右下角图标选择。 接着运行： 1sudo raspi-config 然后选择change_locale，在Default locale for the system environment:中选择zh_CN.UTF-8。然后重启机器，就发现整个环境变成中文的了。 【3】安装 Pi4j： Installation Easy/Preferred (NOTE: This installation method requires that your RaspberryPi is connected to the Internet.) The simplest method to install Pi4J on your RaspberryPi is to execute the following command directly on your RaspberryPi. 1curl -s get.pi4j.com | sudo bash This method will download and launch an installation script that perform the following steps: adds the Pi4J APT repository to the local APT repositories downloads and installs the Pi4J GPG public key for signature validation invokes the ‘apt-get update’ command on the Pi4J APT repository to update the local package database invokes the ‘apt-get install pi4j’ command to perform the download and installation Offline/Manual If you prefer/need to install Pi4J on a RaspberryPi device without an Internet connection, the following instructions provide the steps necessary to install Pi4J without requiring an Internet connection. First, download a copy of the latest Pi4J Debian/Raspian installer package (.deb) file to your local computer. You can download the Pi4J Debian/Raspian installer package (.deb) using your web browser at the following URL: http://get.pi4j.com/download/pi4j-1.2-SNAPSHOT.deb Next, you will need to transfer the download installer package over to your RaspberryPi. You can use any method you prefer to transfer the file (USB, SCP, FTP, etc.) (NOTE: If you have a previous version of Pi4J installed, you will need to uninstall it first.) Once the installer package is available on your RaspberryPi, use the following command on the Pi to perform the installation: 1sudo dpkg -i pi4j-1.2-SNAPSHOT.deb Upgrade Easy/Preferred If you originally installed Pi4J using the ‘easy’ method, then Pi4J upgrades will be available anytime you perform a system update using ‘sudo apt-get update’ and ‘sudo update-get upgrade’. If you wish to force an upgrade of the Pi4J package only, you can do so by executing the following command: 1sudo apt-get install pi4j or pi4j --update Offline/Manual If you originally installed Pi4J using the ‘offline’ method, then you will need to manually uninstall the Pi4J package and download, transfer, and install the new version package using the ‘offline’ uninstall and installation methods described here on this page. Uninstall Easy/Preferred If you originally installed Pi4J using the ‘easy’ method, then you can uninstall Pi4J simply by executing the following command on your RaspberryPi. 1sudo apt-get remove pi4j or pi4j --uninstall Complete/Full Removal If you originally installed Pi4J using the ‘easy’ method and you want to remove all traces of Pi4J, including the Pi4J repository in the APT repositories list and the Pi4J GPG signature, then simply execute the following command on your RaspberryPi. 1curl -s get.pi4j.com/uninstall | sudo bash Offline/Manual If you originally installed Pi4J using the ‘offline’ method, then you will need to manually uninstall the Pi4J package by executing the following command on your Raspberry Pi: 1sudo dpkg -r pi4j Installed Location / Example Files This will install the Pi4J libraries and example source files to: 12/opt/pi4j/lib /opt/pi4j/examples When attempting to compile a Java program using the Pi4J libraries, make sure to include the Pi4J lib folder in the classpath: 1javac -classpath .:classes:/opt/pi4j/lib/'*' ... When attempting to start a Java program using the Pi4J libraries, make sure to include the Pi4J lib folder in the classpath: 1sudo java -classpath .:classes:/opt/pi4j/lib/'*' ... If you would like to explore the examples, you can compile all the examples with the following commands: 1/opt/pi4j/examples/build Pi4j官网:https://pi4j.com 【4】安装 JavaFX 插件包： As you can read here, the most recent JDK versions for ARM don’t include JavaFX. If you want to use JavaFX in your Raspberry Pi, the solution is adding the missing JavaFX SDK. If you install the recent Oracle’s JDK for ARM from here (select jdk-8u111-linux-arm32-vfp-hflt.tar.gz), then you will need to download the JavaFX SDK from Gluon’s site (select JavaFX Embedded SDK for armv6 hard float). Once you have the file, unzip it, and copy the folders to your JDK. Assuming you have downloaded armv6hf-sdk-8.60.8.zip to your Pi/Downloads folder, and you have unzip it to a folder armv6hf-sdk, like in the following picture: using the following commands will allow you moving from command line the files to the JDK required folders. You can use a graphic tool for this as well. 12345678cd Downloads sudo chown -R root:root armv6hf-sdk cd armv6hf-sdk sudo mv lib/javafx-mx.jar /opt/jdk1.8.0_111/lib/ cd rt/lib/ sudo mv j* /opt/jdk1.8.0_111/jre/lib/ sudo mv arm/* /opt/jdk1.8.0_111/jre/lib/arm/ sudo mv ext/* /opt/jdk1.8.0_111/jre/lib/ext/ After that you should be able to run Java/JavaFX programs. 参考链接:https://stackoverflow.com/questions/40481455/running-javafx-gui-on-the-raspberry-pi/40483500#40483500 【5】解决树莓派图形渲染问题： JavaFX glGetError 0x505 You can try increase the available raspberry pi video memory using the sudo raspi-config tool. try change to the 50/50 memory spit. 参考链接:https://www.raspberrypi.org/forums/viewtopic.php?f=81&amp;t=60024#p448200 【6】树莓派播放视频： WebView and Media were never part of the JavaFX ARM distribution, but Gluon recently added it to the embedded SDK that can be downloaded from here and installed with a recent JDK for ARM, available here. Media requires a few extra steps as it depends in the native drivers that usually are not fully installed on a regular Jessie distribution. First install these drivers: 12sudo apt-get install gstreamer0.10-plugins-good sudo apt-get install gstreamer0.10-plugins-bad Now edit /etc/apt/sources.list and add at the end: 1deb http://ftp.uk.debian.org/debian/ wheezy main deb-src http://ftp.uk.debian.org/debian/ wheezy main Save the file (Ctrl+O, Ctrl+X). Finally update and install the drivers: 123sudo apt-get update sudo apt-get install gstreamer0.10-ffmpeg sudo apt-get install gstreamer0.10-alsa Now you can try to run again your JavaFX application. If you find again the same exception (MediaException: UNKNOWN), check if it shows this message: Error in GstPipelineFactory, notice the driver that is missing, and try to install it. 参考链接:https://stackoverflow.com/questions/42076680/play-a-video-using-javafx-on-raspberry-pi 【7】常用的设置树莓派自启动的方法： 这个方式不用修改 rc.local 文件。机制上类似于 Windows 的“开始”菜单中的“启动”菜单。方法如下： 在 /home/pi/.config 下创建一个文件夹，名称为 autostart，并在该文件夹下创建一个xxx.desktop文件（文件名以.desktop结尾，前面可以自定义），文件内容如下： 12345678910[Desktop Entry] Name=example Comment=My Python Program Exec=python /home/pi/example.py Icon=/home/pi/example.png Terminal=false MultipleArgs=false Type=Application Categories=Application;Development; StartupNotify=true 以上 Name、Comment、Icon 可以自定，分别表示这个启动项目的名称、备注以及显示的图标。Exec 表示调用的指令，和在终端输入运行脚本的指令格式一致。 参考链接：https://www.jianshu.com/p/1a160067d8fd 【8】用树莓派播放视频： 树莓派上可以播放 H264 和 mp4 等视频格式，1080p也没问题，因为这种格式的文件有硬件加速。 首先安装 安装 omxplayer ，这是一个命令行的播放器： 1sudo apt-get install omxplayer 然后就可以播放了，当然需要通过 HDMI 连接到显示器看： 1omxplayer -o hdmi /path/to/filename.mp4 -o hdmi 表示音频直接通过 HDMI 播放，播放时按左右箭头快进、按 q 退出。 更多命令行选项和播放时的控制快捷键请参考 omxplayer 的文档。 【9】树莓派安装 JDK： 首先是安装JDK 1sudo apt-get install oracle-java8-jdk 也可以在这个地方下载 修改环境变量，我用的版本是JDK8，arm版HFLT，代表arm架构硬件浮点运算，放在/usr/lib/jvm/jdk-8-oracle-arm-vfp-hflt这个文件夹了 1sudo nano /etc/profile 1234567[cc lang=\"php\"]#set java environmentJAVA_HOME=/usr/lib/jvm/jdk-8-oracle-arm-vfp-hfltCLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/toolPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH[/cc] 接下来是重启树莓派，看看版本号： 1java -version 【10】树莓派去黑边： 在使用树莓派连接HDMI电脑显示器的时候，可能会出现屏幕显示不全，有黑边的情况。这时候需要调节分辨率以适应屏幕。 进入树莓派系统，输入以下指令设置config.txt文件： 1sudo vi /boot/config.txt 调节任何参数时，将#号去除即可生效 123# uncomment to force a specific HDMI mode (this will force VGA) hdmi_group=2 //将显示模式切换成DMT（显示器模式） hdmi_mode=82 //1920x1080 60Hz 1080p 如果显示器不是1080P。则可以参考注1参数修改 这时候就将显示设置成1080P的分辨率，但是是不带声音的，如果你的显示器支持HDMI声音输出或者自带音响，则将如下代码参数去除#号解锁强制获取声音。 12# uncomment to force a HDMI mode rather than DVI. This can make audio work in # DMT (computer monitor) modes hdmi_drive=2 //HDMI模式 更多设置参考官方配置文档：https://www.raspberrypi.org/documentation/configuration/config-txt.md 注1： DMT模式分辨率参数 hdmi_mode resolution frequency notes 1 640x350 85Hz 2 640x400 85Hz 3 720x400 85Hz 4 640x480 60Hz 5 640x480 72Hz 6 640x480 75Hz 7 640x480 85Hz 8 800x600 56Hz 9 800x600 60Hz 10 800x600 72Hz 11 800x600 75Hz 12 800x600 85Hz 13 800x600 120Hz 14 848x480 60Hz 15 1024x768 43Hz incompatible with the Raspberry Pi 16 1024x768 60Hz 17 1024x768 70Hz 18 1024x768 75Hz 19 1024x768 85Hz 20 1024x768 120Hz 21 1152x864 75Hz 22 1280x768 reduced blanking 23 1280x768 60Hz 24 1280x768 75Hz 25 1280x768 85Hz 26 1280x768 120Hz reduced blanking 27 1280x800 reduced blanking 28 1280x800 60Hz 29 1280x800 75Hz 30 1280x800 85Hz 31 1280x800 120Hz reduced blanking 32 1280x960 60Hz 33 1280x960 85Hz 34 1280x960 120Hz reduced blanking 35 1280x1024 60Hz 36 1280x1024 75Hz 37 1280x1024 85Hz 38 1280x1024 120Hz reduced blanking 39 1360x768 60Hz 40 1360x768 120Hz reduced blanking 41 1400x1050 reduced blanking 42 1400x1050 60Hz 43 1400x1050 75Hz 44 1400x1050 85Hz 45 1400x1050 120Hz reduced blanking 46 1440x900 reduced blanking 47 1440x900 60Hz 48 1440x900 75Hz 49 1440x900 85Hz 50 1440x900 120Hz reduced blanking 51 1600x1200 60Hz 52 1600x1200 65Hz 53 1600x1200 70Hz 54 1600x1200 75Hz 55 1600x1200 85Hz 56 1600x1200 120Hz reduced blanking 57 1680x1050 reduced blanking 58 1680x1050 60Hz 59 1680x1050 75Hz 60 1680x1050 85Hz 61 1680x1050 120Hz reduced blanking 62 1792x1344 60Hz 63 1792x1344 75Hz 64 1792x1344 120Hz reduced blanking 65 1856x1392 60Hz 66 1856x1392 75Hz 67 1856x1392 120Hz reduced blanking 68 1920x1200 reduced blanking 69 1920x1200 60Hz 70 1920x1200 75Hz 71 1920x1200 85Hz 72 1920x1200 120Hz reduced blanking 73 1920x1440 60Hz 74 1920x1440 75Hz 75 1920x1440 120Hz reduced blanking 76 2560x1600 reduced blanking 77 2560x1600 60Hz 78 2560x1600 75Hz 79 2560x1600 85Hz 80 2560x1600 120Hz reduced blanking 81 1366x768 60Hz 82 1920x1080 60Hz 1080p 83 1600x900 reduced blanking 84 2048x1152 reduced blanking 85 1280x720 60Hz 720p 86 1366x768 reduced blanking 【11】OmxPlayer 调节声音大小： to provide more precise information for playing through scripts, there are 3 ways to change sound volume in current version of omxplayer, and values are not so intuitive: on starting command line, param –vol YYY, double millibels, default 0, range [-6000:0] by stdin interface, sending +/- to omxplayer will increase/decrease volume for 300 dmbels with DBUS interface, cmd ‘set volume’, value double:XXX, default 1, range [0:1] xxx to yyy relation is: XXX = 10 ^ (YYY / 2000) … according to omxplayer.cpp source code, reverse formula would be: YYY = 2000 * (log XXX). so if we need: volume 1%, XXX=0.01 and YYY=-4000 (10^(-4000/2000)=10^-2=0.01 volume 10%, XXX=0.1 and YYY=-2000 (10^(-2000/2000)=10^-1=0.1 volume 50%, XXX=0.5 and YYY=-602 (10^(-602/2000))~=0.5 volume 100%, XXX=1 and YYY=0 (10^(0/2000)=10^0=1) volume 150%, XXX=1.5 and YYY=352 … (for boost test, normal values are &lt;=100%) working bash script for dbus volume command: 123456export DBUS_SESSION_BUS_ADDRESS=$(cat /tmp/omxplayerdbus.$&#123;USER:-root&#125;) \\dbus-send --print-reply --session --reply-timeout=500 \\ --dest=org.mpris.MediaPlayer2.omxplayer \\ /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Set\\ string:\"org.mpris.MediaPlayer2.Player\" \\ string:\"Volume\" double:0.5 # &lt;-- XXX=0.5 (50% sound volume) equals to volume parameter at startup: 1omxplayer --vol -602 mediaFileName.mp4 … both sets sound volume to 50%. 【12】树莓派设置不休眠的方法 树莓派长时间没人操作时，会自动进入休眠状态，这是因为长时间无操作触发linux的节电休眠机制。所以当树莓派运行后台程序，比如用树莓派看视频时，时间一长就会自动黑屏，树莓派自动进入休眠状态。 怎么设置树莓派不休眠，其实通过建立和设置内置文件就行了，很简单。 以下是防止树莓派休眠的设置步骤： 1、用管理员root账户登录树莓派，在文件夹/etc/profile.d/里面新建内置文件screen.sh。 2、编辑文件screen.sh，写入以下两行内容: 12xset dpms 0 0 0xset s off 保存文件。 3、重启树莓派，就能实现永久禁用树莓派休眠。 【13】树莓派中的GPU渲染内存设置 为了平衡树莓派CPU运行内存和GPU渲染内存，将GPU的MemorySplit设置成320M这个经验值（总内存1GB，GPU分得320M，则CPU持有704M）是一个不错的选择，设置方法如下： raspi-config&gt;&gt;Advanced Options&gt;&gt;Memory Split&gt;&gt;更改内存为320","categories":[],"tags":[{"name":"raspberry","slug":"raspberry","permalink":"http://yoursite.com/tags/raspberry/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-18T02:02:50.485Z","updated":"2019-11-18T07:27:27.737Z","comments":true,"path":"2019/11/18/hello-world/","link":"","permalink":"http://yoursite.com/2019/11/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}