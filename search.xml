<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL基础</title>
    <url>/2019/12/16/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p> 关系数据库的几种设计范式介绍</p>
<p>1、第一范式（1NF）</p>
<p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<a id="more"></a>

<p>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。例如，对于图3-2 中的员工信息表，不能将员工信息都放在一列中显示，也不能将其中的两列或多列在一列中显示；员工信息表的每一行只表示一个员工的信息，一个员工的信息在表中只出现一次。简而言之，第一范式就是无重复的列。</p>
<p>2、第二范式（2NF）</p>
<p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。如图3-2 员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。</p>
<p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p>
<p>3、第三范式（3NF）</p>
<p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在图3-2的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。</p>
<p><strong>为什么要有数据库：文件 管理数据的问题：</strong></p>
<p>1.数据冗余和不一致性</p>
<p>2.大数据访问困难</p>
<p>3.数据孤立</p>
<p>4.完整性和原子性</p>
<p>5.并发访问异常</p>
<p>6.安全性问题</p>
<p>由此，有了数据库。。。</p>
<p><strong>数据库概述</strong></p>
<p>数据库：指的是以一定方式存储在一起、能为多个用户共享，具有尽可能小的冗余度的特点、是与应用程序彼此独立的数据集合。</p>
<p><strong>数据库服务器的基本概念</strong></p>
<p>数据库</p>
<p>​    DBMS 数据库管理系统（能够操作和管理数据库的大型软件）</p>
<p>​    RDBMS 关系式数据库（=DBMS）</p>
<p>​       1.数据以表格的形式出现</p>
<p>​       2.每行为各种记录名称</p>
<p>​       3.每列为记录名称所对应的数据域</p>
<p>​       4.许多的行和列组成一张表单</p>
<p>​       5.若干的表单组成database</p>
<p>数据表</p>
<p>​    数据（记录）</p>
<p>​    字段（id name ….）</p>
<p>​    类型（定义字段中的内容）</p>
<p>​    主键（检索时用）</p>
<p><strong>数据库的三种基本形式</strong></p>
<p>层次模型：</p>
<p>按照层次结构的形式组织数据库数据的模型</p>
<p>缺点：冗余数据</p>
<p>网状模型:</p>
<p>按照网状结构的形式组织数据库数据的模型</p>
<p>缺点：后期维护困难</p>
<p>关系模型：</p>
<p>按照关系结构的形式组织数据库数据的模型</p>
<p><strong>sql语句：</strong></p>
<p>结构化查询语句</p>
<p><strong>sql类型：</strong></p>
<p>DML   数据操作语言：用来操作数据库中的数据</p>
<p>​    INSERT</p>
<p>​    DELETE</p>
<p>​    SELECT</p>
<p>​    UPDATE</p>
<p>DDL    数据描述语言：用来建立数据库、定义数据关系</p>
<p>​    CREATE</p>
<p>​    DROP</p>
<p>​    ALTER</p>
<p>DCL     数据控制语言：用来控制数据库组建的权限</p>
<p>​    GRANT</p>
<p>​    REVOKE</p>
<p><strong>关系式数据库结构</strong></p>
<p>文件逻辑关系：</p>
<p>上层：文件</p>
<p>底层：二进制的方式存储在硬盘的数据块中</p>
<p>中间层：文件系统</p>
<p>数据库逻辑关系：</p>
<p>上层：数据表</p>
<p>底层：文件</p>
<p>中间层：存储引擎（提供存储、创建、更新、查询数据的实现方法）</p>
<p><strong>mysql 支持的存储引擎</strong>：</p>
<p>MYISAM</p>
<p>默认引擎、插入和查询速度较快</p>
<p>不支持事务、行级锁和外键约束等功能</p>
<p>注：</p>
<p>事务：一段sql语句的批处理、为了保证数据原子性</p>
<p>锁：行级锁（冲突少、速度慢）；表级锁（冲突多、速度快）；页级锁（折中方案）</p>
<p>​           约束</p>
<p>​              域约束：数据类型约束</p>
<p>​              外键约束：引用完整性约束</p>
<p>​              主键约束：某字段能惟一标识此字段所属的实体，并且不允许为空</p>
<p>​               一张表中只能有一个主键</p>
<p>​              惟一性约束：每一行的某字段都不允许出现相同值，可以为空</p>
<p>​               一张表中可以有多个</p>
<p>​              检查性约束: age: int</p>
<p>INNODB </p>
<p>​       支持事务、行级锁和外键约束等功能</p>
<p>MEMORY</p>
<p>工作在内存中，通过散列保存数据，速度快、不能永久保存数据</p>
<p><strong>数据的存储和查询</strong></p>
<p>存储管理器（实现存储的功能，通过DDL创建数据表的结构，再通过DML来保存数据）</p>
<p>事务管理器：提供事务功能</p>
<p>文件管理器：保存数据库数据和文件的对应关系</p>
<p>权限及完整性管理器：设置存储权限</p>
<p>缓冲管理器：管理缓冲空间</p>
<p>查询管理器（实现查询的功能，接收用户的查询请求、理解用户查询请求，将查询请求提交给存储管理器、实现最终存储）</p>
<p>DDL 、DML解释器</p>
<p>查询执行引擎</p>
<p><strong>数据库工作模式</strong>：</p>
<p>单进程多线程的工作模式</p>
<p>守护线程</p>
<p>应用线程（用户线程）</p>
<p>补充：apache的工作模式:</p>
<p>一个进程处理一个请求</p>
<p>一个线程处理一个请求</p>
<p>一个线程处理多个请求</p>
<p><strong>mysql优化</strong></p>
<p>1.垂直扩展</p>
<p>2.线程重用</p>
<p>3.缓存机制（nosql &lt; memcache redis mongodb &gt;）</p>
<p>SMP : 对称多处理器架构</p>
<p><strong>3.</strong> <strong>E-R模型</strong></p>
<p>实体关系建模</p>
<p>实体：数据对象，即看得见摸得着</p>
<p>联系：表示一个或多个实体之间的关联</p>
<p>属性：实体的某一特性</p>
<p>数据库—基本概述</p>
<p><strong>数据库的版本</strong></p>
<p>1.社区版</p>
<p>2.企业版</p>
<p>3.集群版</p>
<p><strong>数据库的安装</strong></p>
<ol>
<li>专用软件包管理器（二进制）</li>
</ol>
<p>deb 、rpm等</p>
<p>mysql         MySQL客户端程序和共享库</p>
<p>mysql-server      MySQL服务器需要的相关程序</p>
<ol>
<li>源代码软件包（编译安装）</li>
</ol>
<p>configure、cmake</p>
<p>数据库常用的配置选项</p>
<p>-DCMAKE_INSTALL_PREFIX=/usr/local/mysql  —-指定残可安装路径（默认的就是/usr/local/mysql）</p>
<p>-DMYSQL_DATADIR=/data/mysql          —-mysql的数据文件路径</p>
<p>-DSYSCONFDIR=/etc                   —-配置文件路径</p>
<p>-DWITH_INNOBASE_STORAGE_ENGINE=1    —-使用INNOBASE存储引擎</p>
<p>-DWITH_ARCHIVE_STORAGE_ENGINE=1     —-常应用于日志记录和聚合分析，不支持索引</p>
<p>-DWITH_BLACKHOLE_STORAGE_ENGINE=1   —-黑洞存储引擎</p>
<p>-DWITHOUT_EXAMPLE_STORAGE_ENGINE=1 编译过程中取消一些存储引擎指令介绍</p>
<p>-DWITHOUT_FEDERATED_STORAGE_ENGINE=1</p>
<p>-DWITHOUT_PARTITION_STORAGE_ENGINE=1</p>
<p>-DWITH_READLINE=1   —-支持批量导入mysql数据</p>
<p>-DWITH_SSL=system   —-mysql支持ssl会话，实现基于ssl的数据复</p>
<p>-DWITH_ZLIB=system   —-压缩库</p>
<p>-DWITH_LIBWRAP=0    —-是否可以基于WRAP实现访问控制</p>
<p>-DMYSQL_TCP_PORT=3306         —-默认端口</p>
<p>-DMYSQL_UNIX_ADDR=/tmp/mysql.sock   —-默认套接字文件路径</p>
<p>-DENABLED_LOCAL_INFILE=1        —-是否启用LOCAL_INFILE功能</p>
<p>-DEXTRA_CHARSETS=all                 —-是否支持额外的字符集</p>
<p>-DDEFAULT_CHARSET=utf8         —-默认编码机制</p>
<p>-DDEFAULT_COLLATION=utf8_general_ci  —-设定默认语言的排序规则</p>
<p>-DWITH_DEBUG=0             —-DEBUG功能设置</p>
<p> -DENABLE_PROFILING=1          —-性能分析功能是否启用</p>
<ol>
<li>服务：mysqld</li>
<li>端口：3306</li>
<li>主配置文件：/etc/my.cnf</li>
<li>脚本：mysql_install_db</li>
<li>mysqld_safe</li>
<li>数据目录 ：/var/lib/mysql</li>
<li>套接字文件：/var/lib/mysql/mysql.sock</li>
<li>当意外关闭数据库时，再开启时假如开启不了，找到这个，删除再启动</li>
<li>进程文件：/var/run/mysqld/mysqld.pid</li>
</ol>
<p><strong>登录及退出mysql环境</strong></p>
<p>a)   设置密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin   -uroot      password ‘123’</span><br></pre></td></tr></table></figure>

<p>b)   登录       </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u 用户名 -p</span><br></pre></td></tr></table></figure>

<p>-p 用户密码 </p>
<p>-h 登陆位置（主机名或ip地址）</p>
<p>-P 端口号（3306改了就不是了）</p>
<p>-S 套接字文件（/var/lib/mysql/mysql.sock）</p>
<p>c)  退出      </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>d)  创建登录用户  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create user 用户名@’%’ identified by ‘密码’</span><br></pre></td></tr></table></figure>

<p>e)  修改密码    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set password=password(‘新密码’)</span><br><span class="line">set password for 用户@登录位置=password(‘新密码’)   — — — root用户为其他用户找回密码</span><br></pre></td></tr></table></figure>

<p>当管理员把自己密码忘记了，怎么找回？？？</p>
<p>1）关闭数据库</p>
<p>2）修改主配置文件（/etc/my.cnf）&lt;—— skip-grant-tables</p>
<p>3）启动数据库</p>
<p>4）空密码登录并修改密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update mysql.user set password=password(‘新密码’) where user=’root’;</span><br></pre></td></tr></table></figure>

<p>5）删除skip-grant-tables,重启数据库验证新密码</p>
<p><strong>SQL语句</strong></p>
<p>关于库的操作：</p>
<table>
<thead>
<tr>
<th>Mysql命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>show databases</td>
<td>查看服务器中当前有哪些数据库</td>
</tr>
<tr>
<td>use 数据库名</td>
<td>选择所使用的数据库</td>
</tr>
<tr>
<td>create database 数据库名</td>
<td>创建数据库</td>
</tr>
<tr>
<td>drop database 数据库名</td>
<td>删除指定的数据库</td>
</tr>
</tbody></table>
<p>关于表的操作</p>
<table>
<thead>
<tr>
<th>MySQL命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>create table 表名 (字段1 类型1，…)</td>
<td>在当前数据库中创建数据表</td>
</tr>
<tr>
<td>show tables</td>
<td>显示当前数据库中有哪些数据表</td>
</tr>
<tr>
<td>describe 表名</td>
<td>显示当前或指定数据库中指定数据表的结构(字段)信息</td>
</tr>
<tr>
<td>drop table 表名</td>
<td>删除当前或指定数据库中指定的数据表</td>
</tr>
<tr>
<td>alter table 旧表名 rename 新表名</td>
<td>修改数据表的名称</td>
</tr>
<tr>
<td>alter table 表名 modify 字段 类型</td>
<td>修改字段的类型</td>
</tr>
<tr>
<td>alter table 表名 change 旧字段名 新字段名 类型</td>
<td>修改字段</td>
</tr>
<tr>
<td>alter table 表名 add 字段 类型（first/after）</td>
<td>增加字段</td>
</tr>
<tr>
<td>alter table 表名 drop 字段</td>
<td>删除字段</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>MySQL命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>insert into 表名(字段1,字段2,……) values(字段1的值, 字段2的值,……)</td>
<td>向数据表中插入新的记录</td>
</tr>
<tr>
<td>update 表名 set 字段名 =新数据 where 条件表达式</td>
<td>修改、更新数据表中的记录</td>
</tr>
<tr>
<td>select 字段名1,字段名2……from 表名 where 条件表达式</td>
<td>从数据表中查找符合条件的记录</td>
</tr>
<tr>
<td>select * from 表名</td>
<td>显示当前数据库的表中的记录</td>
</tr>
<tr>
<td>delete from 表名 where 条件表达式 between…and…</td>
<td>在数据表中删除指定的记录指定范围</td>
</tr>
<tr>
<td>delete from 表名</td>
<td>将当前数据库表中记录清空</td>
</tr>
</tbody></table>
<p>注：库和表的删除用drop,记录删除用delete</p>
<p><strong>权限</strong></p>
<p>grant 权限1，权限2，…… on 数据库.数据表 to 用户@登录位置 (identified by ‘密码’)；</p>
<p>revoke 取消的权限1，取消的权限2，…… on 数据库.数据表 from 用户@登录位置；</p>
<p>show grants for 用户@登录位置；</p>
<p><strong>备份和还原</strong></p>
<p>冷备份：把数据库关闭，离线备份（使用cp、tar等命令直接备份数据库所存放的目录）</p>
<p>FRM 结构</p>
<p>MYI 索引</p>
<p>MYD 数据</p>
<p>快照备份：（利用逻辑卷）</p>
<p>逻辑备份：</p>
<p>mysqldump</p>
<p>备份：mysqldump -u 用户名 -p 数据库名 &gt; /备份路径/备份文件名（备份单个数据库）</p>
<p>mysqldump -u 用户名 -p 数据库名 表名 &gt; /备份路径/备份文件名（备份数据表）</p>
<p>–databases 库1，库2 (此时还原—&gt;mysql &lt; 备份文件)</p>
<p>–all-databases —备份服务器中的所有数据库内容</p>
<p>还原：mysql 数据库 &lt; 备份文件</p>
<p>mysqlhotcopy</p>
<p>备份：mysqlhotcopy –flushlog -u=’用户’ -p=’密码’ –regexp=正则 备份目录</p>
<p>还原：cp -rpf 备份目录 数据目录（/var/lib/mysql）</p>
<p><strong>补充的备份机制</strong></p>
<p>1.日志备份</p>
<p>&gt;mysql show global variables like ‘%log%’</p>
<p>列出mysql中和日志相关的变量</p>
<p>错误日志</p>
<p>服务器启动和关闭时的信息</p>
<p>服务器运行过程中的错误信息</p>
<p>从服务器启动从服务器进程时产生的信息</p>
<p>log-error   错误日志的路径</p>
<p>一般日志（不启用）</p>
<p>记录用户对数据库的查询操作</p>
<p>general-log=ON 启动一般查询日志</p>
<p>log=ON       全局日志开关</p>
<p>log-output     日志的记录类型</p>
<p>慢查询日志</p>
<p>记录需要较长时间的查询操作</p>
<p>log-slow-queries=保存路径 启动慢查询日志，并设置个路径</p>
<p>二进制日志</p>
<p>所有对数据库状态更改的操作（create、drop、update等）</p>
<p>log-bin=位置 启动二进制日志</p>
<p>&gt;mysql show binary logs 查看当前使用的二进制日志</p>
<p>&gt;mysql show binlog events in ‘二进制日志(mysql-bin.000001)’ 查看二进制日志的内容</p>
<p>还原：(mysqlbinlog)</p>
<p>按时间还原：</p>
<p>mysqlbinlog –start-datetime ‘YY-MM-DD HH:MM:SS’ –stop-datetime ‘YY-MM-DD HH:MM:SS’ 二进制日志 | mysql(-urot -p)  </p>
<p> 按文件大小还原：</p>
<p>–start-position</p>
<p>–stop-position</p>
<p>事务日志：记录事务相关的日志信息</p>
<p>中继日志：记录从服务器的备份信息</p>
<p>2.多机备份</p>
<p>主从配置：实时备份</p>
<p>主主配置：（配置了2遍的主从）实时备份、负载均衡</p>
<p>多从一主：实时备份（更多的备份节点）</p>
<p>多主一从：实时备份、节约成本</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java正则表达式</title>
    <url>/2019/12/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式定义了字符串的模式。</p>
<p>正则表达式可以用来搜索、编辑或处理文本。</p>
<p>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。</p>
<a id="more"></a>

<h3 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h3><p>一个字符串其实就是一个简单的正则表达式，例如 <strong>Hello World</strong> 正则表达式匹配 “Hello World” 字符串。</p>
<p><strong>.</strong>（点号）也是一个正则表达式，它匹配任何一个字符如：”a” 或 “1”。</p>
<p>下表列出了一些正则表达式的实例及描述：</p>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">this is text</td>
<td align="left">匹配字符串 “this is text”</td>
</tr>
<tr>
<td align="left">this\s+is\s+text</td>
<td align="left">注意字符串中的 <strong>\s+</strong>。匹配单词 “this” 后面的 <strong>\s+</strong> 可以匹配多个空格，之后匹配 is 字符串，再之后 <strong>\s+</strong> 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text</td>
</tr>
<tr>
<td align="left">^\d+(.\d+)?</td>
<td align="left">^ 定义了以什么开始\d+ 匹配一个或多个数字? 设置括号内的选项是可选的. 匹配 “.”可以匹配的实例：”5”, “1.5” 和 “2.21”。</td>
</tr>
</tbody></table>
<p>Java 正则表达式和 Perl 的是最为相似的。</p>
<p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li><p>Pattern 类：</p>
<p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>
</li>
<li><p>Matcher 类：</p>
<p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
</li>
<li><p>PatternSyntaxException：</p>
<p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</li>
</ul>
<p>以下实例中使用了正则表达式 <strong>.*runoob.*</strong> 用于查找字符串中是否包了 <strong>runoob</strong> 子串：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegexExample1</span></span>&#123;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;      </span><br><span class="line">		String content = <span class="string">"I am noob "</span> + <span class="string">"from runoob.com."</span>;       </span><br><span class="line">		String pattern = <span class="string">".*runoob.*"</span>;       </span><br><span class="line">		<span class="keyword">boolean</span> isMatch = Pattern.matches(pattern, content);      </span><br><span class="line">		System.out.println(<span class="string">"字符串中是否包含了 'runoob' 子字符串? "</span> + isMatch);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">字符串中是否包含了 <span class="string">'runoob'</span> 子字符串? <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p>
<p>例如，正则表达式 (dog) 创建了单一分组，组里包含”d”，”o”，和”g”。</p>
<p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p>
<ul>
<li>((A)(B(C)))</li>
<li>(A)</li>
<li>(B(C))</li>
<li>(C)</li>
</ul>
<p>可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。</p>
<p>还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>下面的例子说明如何从一个给定的字符串中找到数字串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 按指定模式在字符串查找</span></span><br><span class="line">      String line = <span class="string">"This order was placed for QT3000! OK?"</span>;</span><br><span class="line">      String pattern = <span class="string">"(\\D*)(\\d+)(.*)"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">      Pattern r = Pattern.compile(pattern);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 现在创建 matcher 对象</span></span><br><span class="line">      Matcher m = r.matcher(line);</span><br><span class="line">      <span class="keyword">if</span> (m.find( )) &#123;</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">0</span>) );</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">1</span>) );</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">2</span>) );</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">3</span>) ); </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">"NO MATCH"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Found value: This order was placed <span class="keyword">for</span> QT3000! OK?</span><br><span class="line">Found value: This order was placed <span class="keyword">for</span> QT</span><br><span class="line">Found value: <span class="number">3000</span></span><br><span class="line">Found value: ! OK?</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>在其他语言中，<strong>\</strong> 表示：<strong>我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。</strong></p>
<p>在 Java 中，<strong>\</strong> 表示：<strong>我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</strong></p>
<p>所以，在其他的语言中（如Perl），一个反斜杠 <strong>\</strong> 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 <strong>\</strong> 代表其他语言中的一个 <strong>\</strong>，这也就是为什么表示一位数字的正则表达式是 <strong>\d</strong>，而表示一个普通的反斜杠是 <strong>\\</strong>。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\“匹配”\“，”\(“匹配”(“。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td align="left">{<em>n</em>}</td>
<td align="left"><em>n</em> 是非负整数。正好匹配 <em>n</em> 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td>
</tr>
<tr>
<td align="left">{<em>n</em>,}</td>
<td align="left"><em>n</em> 是非负整数。至少匹配 <em>n</em> 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td>
</tr>
<tr>
<td align="left">{<em>n</em>,<em>m</em>}</td>
<td align="left"><em>m</em> 和 <em>n</em> 是非负整数，其中 <em>n</em> &lt;= <em>m</em>。匹配至少 <em>n</em> 次，至多 <em>m</em> 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">当此字符紧随任何其他限定符（<em>、+、?、{*n</em>}、{<em>n</em>,}、{<em>n</em>,<em>m</em>}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td>
</tr>
<tr>
<td align="left">(<em>pattern</em>)</td>
<td align="left">匹配 <em>pattern</em> 并捕获该匹配的子表达式。可以使用 <strong>$0…$9</strong> 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</td>
</tr>
<tr>
<td align="left">(?:<em>pattern</em>)</td>
<td align="left">匹配 <em>pattern</em> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</td>
</tr>
<tr>
<td align="left">(?=<em>pattern</em>)</td>
<td align="left">执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <em>pattern</em> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td align="left">(?!<em>pattern</em>)</td>
<td align="left">执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <em>pattern</em> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td align="left"><em>x</em>|<em>y</em></td>
<td align="left">匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</td>
</tr>
<tr>
<td align="left">[<em>xyz</em>]</td>
<td align="left">字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td>
</tr>
<tr>
<td align="left">[^<em>xyz</em>]</td>
<td align="left">反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td>
</tr>
<tr>
<td align="left">[<em>a-z</em>]</td>
<td align="left">字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td>
</tr>
<tr>
<td align="left">[^<em>a-z</em>]</td>
<td align="left">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td>
</tr>
<tr>
<td align="left">\c<em>x</em></td>
<td align="left">匹配 <em>x</em> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<em>x</em> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">数字字符匹配。等效于 [0-9]。</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">非数字字符匹配。等效于 [^0-9]。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符匹配。与 \x0b 和 \cK 等效。</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td align="left">\x<em>n</em></td>
<td align="left">匹配 <em>n</em>，此处的 <em>n</em> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td align="left">*num*</td>
<td align="left">匹配 <em>num*，此处的 *num</em> 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="left">*n*</td>
<td align="left">标识一个八进制转义码或反向引用。如果 *n* 前面至少有 <em>n</em> 个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em> 是八进制数 (0-7)，那么 <em>n</em>是八进制转义码。</td>
</tr>
<tr>
<td align="left">*nm*</td>
<td align="left">标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 <em>nm</em> 个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 *nm* 前面至少有 <em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符 <em>m</em>。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 <em>nm*，其中 *n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td align="left">\nml</td>
<td align="left">当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数 (0-7) 时，匹配八进制转义码 <em>nml</em>。</td>
</tr>
<tr>
<td align="left">\u<em>n</em></td>
<td align="left">匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
</tbody></table>
<blockquote>
<p>根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 “\b” 与单个退格字符匹配，而 “\b” 与单词边界匹配。字符串字面值 “(hello)“ 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 “\(hello\)”。</p>
</blockquote>
<hr>
<h2 id="Matcher-类的方法"><a href="#Matcher-类的方法" class="headerlink" title="Matcher 类的方法"></a>Matcher 类的方法</h2><h2 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h2><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public int start()</strong>  返回以前匹配的初始索引。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public int start(int group)</strong>  返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public int end()</strong> 返回最后匹配字符之后的偏移量。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public int end(int group)</strong> 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td>
</tr>
</tbody></table>
<h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><p>研究方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public boolean lookingAt()</strong>   尝试将从区域开头开始的输入序列与该模式匹配。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public boolean find()</strong>  尝试查找与该模式匹配的输入序列的下一个子序列。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public boolean find(int start**</strong>）** 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public boolean matches()</strong>  尝试将整个区域与模式匹配。</td>
</tr>
</tbody></table>
<h2 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h2><p>替换方法是替换输入字符串里文本的方法：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public Matcher appendReplacement(StringBuffer sb, String replacement)</strong> 实现非终端添加和替换步骤。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public StringBuffer appendTail(StringBuffer sb)</strong> 实现终端添加和替换步骤。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public String replaceAll(String replacement)</strong>   替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public String replaceFirst(String replacement)</strong>  替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public static String quoteReplacement(String s)</strong> 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</td>
</tr>
</tbody></table>
<h2 id="start-和-end-方法"><a href="#start-和-end-方法" class="headerlink" title="start 和 end 方法"></a>start 和 end 方法</h2><p>下面是一个对单词 “cat” 出现在输入字符串中出现次数进行计数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REGEX = <span class="string">"\\bcat\\b"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT =</span><br><span class="line">                                    <span class="string">"cat cat cat cattie cat"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span>&#123;</span><br><span class="line">       Pattern p = Pattern.compile(REGEX);</span><br><span class="line">       Matcher m = p.matcher(INPUT); <span class="comment">// 获取 matcher 对象</span></span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">         count++;</span><br><span class="line">         System.out.println(<span class="string">"Match number "</span>+count);</span><br><span class="line">         System.out.println(<span class="string">"start(): "</span>+m.start());</span><br><span class="line">         System.out.println(<span class="string">"end(): "</span>+m.end());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Match number <span class="number">1</span></span><br><span class="line">start(): <span class="number">0</span></span><br><span class="line">end(): <span class="number">3</span></span><br><span class="line">Match number <span class="number">2</span></span><br><span class="line">start(): <span class="number">4</span></span><br><span class="line">end(): <span class="number">7</span></span><br><span class="line">Match number <span class="number">3</span></span><br><span class="line">start(): <span class="number">8</span></span><br><span class="line">end(): <span class="number">11</span></span><br><span class="line">Match number <span class="number">4</span></span><br><span class="line">start(): <span class="number">19</span></span><br><span class="line">end(): <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>可以看到这个例子是使用单词边界，以确保字母 “c” “a” “t” 并非仅是一个较长的词的子串。它也提供了一些关于输入字符串中匹配发生位置的有用信息。</p>
<p>Start 方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end 方法最后一个匹配字符的索引加 1。</p>
<h2 id="matches-和-lookingAt-方法"><a href="#matches-和-lookingAt-方法" class="headerlink" title="matches 和 lookingAt 方法"></a>matches 和 lookingAt 方法</h2><p>matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求。</p>
<p>lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。</p>
<p>这两个方法经常在输入字符串的开始使用。</p>
<p>我们通过下面这个例子，来解释这个功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REGEX = <span class="string">"foo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT = <span class="string">"fooooooooooooooooo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT2 = <span class="string">"ooooofoooooooooooo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pattern pattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Matcher matcher;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Matcher matcher2;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span>&#123;</span><br><span class="line">       pattern = Pattern.compile(REGEX);</span><br><span class="line">       matcher = pattern.matcher(INPUT);</span><br><span class="line">       matcher2 = pattern.matcher(INPUT2);</span><br><span class="line"> </span><br><span class="line">       System.out.println(<span class="string">"Current REGEX is: "</span>+REGEX);</span><br><span class="line">       System.out.println(<span class="string">"Current INPUT is: "</span>+INPUT);</span><br><span class="line">       System.out.println(<span class="string">"Current INPUT2 is: "</span>+INPUT2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">       System.out.println(<span class="string">"lookingAt(): "</span>+matcher.lookingAt());</span><br><span class="line">       System.out.println(<span class="string">"matches(): "</span>+matcher.matches());</span><br><span class="line">       System.out.println(<span class="string">"lookingAt(): "</span>+matcher2.lookingAt());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Current REGEX is: foo</span><br><span class="line">Current INPUT is: fooooooooooooooooo</span><br><span class="line">Current INPUT2 is: ooooofoooooooooooo</span><br><span class="line">lookingAt(): <span class="keyword">true</span></span><br><span class="line">matches(): <span class="keyword">false</span></span><br><span class="line">lookingAt(): <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="replaceFirst-和-replaceAll-方法"><a href="#replaceFirst-和-replaceAll-方法" class="headerlink" title="replaceFirst 和 replaceAll 方法"></a>replaceFirst 和 replaceAll 方法</h2><p>replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。</p>
<p>下面的例子来解释这个功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String REGEX = <span class="string">"dog"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String INPUT = <span class="string">"The dog says meow. "</span> +</span><br><span class="line">                                    <span class="string">"All dogs say meow."</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String REPLACE = <span class="string">"cat"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Pattern p = Pattern.compile(REGEX);</span><br><span class="line">       <span class="comment">// get a matcher object</span></span><br><span class="line">       Matcher m = p.matcher(INPUT); </span><br><span class="line">       INPUT = m.replaceAll(REPLACE);</span><br><span class="line">       System.out.println(INPUT);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The cat says meow. All cats say meow.</span><br></pre></td></tr></table></figure>

<h2 id="appendReplacement-和-appendTail-方法"><a href="#appendReplacement-和-appendTail-方法" class="headerlink" title="appendReplacement 和 appendTail 方法"></a>appendReplacement 和 appendTail 方法</h2><p>Matcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换：</p>
<p>看下面的例子来解释这个功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String REGEX = <span class="string">"a*b"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String INPUT = <span class="string">"aabfooaabfooabfoobkkk"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String REPLACE = <span class="string">"-"</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Pattern p = Pattern.compile(REGEX);</span><br><span class="line">      <span class="comment">// 获取 matcher 对象</span></span><br><span class="line">      Matcher m = p.matcher(INPUT);</span><br><span class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">      <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">         m.appendReplacement(sb,REPLACE);</span><br><span class="line">      &#125;</span><br><span class="line">      m.appendTail(sb);</span><br><span class="line">      System.out.println(sb.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-foo-foo-foo-kkk</span><br></pre></td></tr></table></figure>

<h2 id="PatternSyntaxException-类的方法"><a href="#PatternSyntaxException-类的方法" class="headerlink" title="PatternSyntaxException 类的方法"></a>PatternSyntaxException 类的方法</h2><p>PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。</p>
<p>PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public String getDescription()</strong> 获取错误的描述。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public int getIndex()</strong>   获取错误的索引。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public String getPattern()</strong>  获取错误的正则表达式模式。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public String getMessage()</strong>  返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Python编程：从入门到实践》</title>
    <url>/2019/12/16/PythonProgram/</url>
    <content><![CDATA[<h3 id="【1】变量的命名和使用"><a href="#【1】变量的命名和使用" class="headerlink" title="【1】变量的命名和使用"></a>【1】变量的命名和使用</h3><p>在 Python 中使用变量时，需要遵守一些规则和指南。违反这些规则将引发错误，而指南旨在让你编写的代码更容易阅读和理解。请务必牢记下述有关变量的规则。</p>
<ul>
<li>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为 message_1 ，但不能将其命名为 1_message 。</li>
</ul>
<a id="more"></a>

<ul>
<li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名 greeting_message 可行，但变量名 greeting message 会引发错误。</li>
<li>不要将 Python 关键字和函数名用作变量名，即不要使用 Python 保留用于特殊用途的单词，如 print （请参见附录 A.4 ）。</li>
<li>变量名应既简短又具有描述性。例如， name 比 n 好， student_name 比 s_n 好， name_length 比 length_of_persons_name 好。</li>
<li>慎用小写字母 l 和大写字母 O ，因为它们可能被人错看成数字 1 和 0 。</li>
</ul>
<h3 id="【2】字符串"><a href="#【2】字符串" class="headerlink" title="【2】字符串"></a>【2】字符串</h3><ul>
<li>大小写转换：</li>
</ul>
<p>name = “ada lovelace”</p>
<p>print(name.title())</p>
<p>print(name.upper())</p>
<p>print(name.lower())</p>
<p>输出：</p>
<p>Ada Lovelace</p>
<p>ADA LOVELACE</p>
<p>ada lovelace</p>
<p>存储数据时，方法 lower() 很有用。很多时候，你无法依靠用户来提供正确的大小写，因此需要    </p>
<p>将字符串先转换为小写，再存储它们。以后需要显示这些信息时，再将其转换为最合适的大小写</p>
<p>方式。</p>
<ul>
<li>合并（拼接）字符串：</li>
</ul>
<p>使用 “<strong>+</strong>”：</p>
<p>first_name = “ada”</p>
<p>last_name = “lovelace”</p>
<p>full_name = first_name + “ “ + last_name</p>
<p>print(full_name)</p>
<ul>
<li>使用制表符或换行符来添加空白</li>
</ul>
<p>&gt;&gt;&gt; print(“Languages:\n\tPython\n\tC\n\tJavaScript”)</p>
<p>Languages:</p>
<p>Python</p>
<p>C</p>
<p>JavaScript</p>
<ul>
<li>删除空白</li>
</ul>
<p>你还可以剔除字符串开头的空白，或同时剔除字符串两端的空白。为此，可分别使用方法 </p>
<p><strong>lstrip()</strong> 和 <strong>strip()</strong> ：</p>
<p>&gt;&gt;&gt; favorite_language = ‘ python ‘</p>
<p>&gt;&gt;&gt; favorite_language.<strong>rstrip()</strong></p>
<p>‘ python’</p>
<p>&gt;&gt;&gt; favorite_language.<strong>lstrip()</strong></p>
<p>‘python ‘</p>
<p>&gt;&gt;&gt; favorite_language.<strong>strip()</strong></p>
<p>‘python’</p>
<ul>
<li>单引号和双引号</li>
</ul>
<p><strong>‘</strong> Albert Einstein said, <strong>“</strong>A person who never made a mistake never tried anything new<strong>“</strong> <strong>‘</strong></p>
<p><strong>“</strong> Albert Einstein said, <strong>‘</strong>A person who never made a mistake never tried anything new<strong>‘</strong> <strong>“</strong></p>
<h3 id="【3】数字"><a href="#【3】数字" class="headerlink" title="【3】数字"></a>【3】数字</h3><ul>
<li>整数</li>
</ul>
<p>&gt;&gt;&gt; 2 + 3</p>
<p>5</p>
<p>&gt;&gt;&gt; 3 - 2</p>
<p>1</p>
<p>&gt;&gt;&gt; 2 * 3</p>
<p>6</p>
<p>&gt;&gt;&gt; 3 / 2</p>
<p>1.5</p>
<p>在终端会话中， Python 直接返回运算结果。 Python 使用两个乘号表示乘方运算：</p>
<p>&gt;&gt;&gt; 3 ** 2</p>
<p>9</p>
<p>&gt;&gt;&gt; 3 ** 3</p>
<p>27</p>
<p>&gt;&gt;&gt; 10 ** 6</p>
<p>1000000</p>
<ul>
<li>浮点数</li>
</ul>
<p>&gt;&gt;&gt; 0.1 + 0.1</p>
<p>0.2</p>
<p>&gt;&gt;&gt; 0.2 + 0.2</p>
<p>0.4</p>
<p>&gt;&gt;&gt; 2 * 0.1</p>
<p>0.2</p>
<p>&gt;&gt;&gt; 2 * 0.2</p>
<p>0.4</p>
<ul>
<li>使用函数 str()  将数值转化为字符串，避免类型错误</li>
</ul>
<p>age = 23</p>
<p>message = “Happy “ + <strong>str</strong>(age) + “rd Birthday!”</p>
<p>print(message)</p>
<h3 id="【4】注释"><a href="#【4】注释" class="headerlink" title="【4】注释"></a>【4】注释</h3><p>#  向大家问好</p>
<p>print(“Hello Python people!”)</p>
<h3 id="【5】python-之禅"><a href="#【5】python-之禅" class="headerlink" title="【5】python 之禅"></a>【5】python 之禅</h3><p>&gt;&gt;&gt;import this</p>
<p>The Zen of Python, by Tim Peters</p>
<ul>
<li><strong>Beautiful is better than ugly.</strong></li>
</ul>
<p>Python 程序员笃信代码可以编写得漂亮而优雅。编程是要解决问题的，设计良好、高效而漂亮的解决方案都会让程序员心生敬意。随着你对 Python 的认识越来越深入，并使用它来编写越来越多的代码，有一天也许会有人站在你后面惊呼： “ 哇，代码编写得真是漂亮！ </p>
<ul>
<li><strong>Explicit is better than implicit.</strong></li>
<li><strong>Simple is better than complex.</strong></li>
</ul>
<p>如果有两个解决方案，一个简单，一个复杂，但都行之有效，就选择简单的解决方案吧。这样，你编写的代码将更容易维护，你或他人以后改进这些代码时也会更容易。</p>
<ul>
<li><strong>Complex is better than complicated.</strong></li>
</ul>
<p>现实是复杂的，有时候可能没有简单的解决方案。在这种情况下，就选择最简单可行的解决方案吧。</p>
<ul>
<li><strong>Flat is better than nested.</strong></li>
<li><strong>Sparse is better than dense.</strong></li>
<li><strong>Readability counts.</strong></li>
</ul>
<p>即便是复杂的代码，也要让它易于理解。开发的项目涉及复杂代码时，一定要为这些代码编写有益的注释。</p>
<ul>
<li><strong>Special cases aren’t special enough to break the rules.</strong></li>
<li><strong>Although practicality beats purity.</strong></li>
<li><strong>Errors should never pass silently.</strong></li>
<li><strong>Unless explicitly silenced.</strong></li>
<li><strong>In the face of ambiguity, refuse the temptation to guess.</strong></li>
<li><strong>There should be one– and preferably only one –obvious way to do it.</strong></li>
</ul>
<p>如果让两名 Python 程序员去解决同一个问题，他们提供的解决方案应大致相同。这并不是说编程没有创意空间，而是恰恰相反！然而，大部分编程工作都是使用常见解决方案来解</p>
<p>决简单的小问题，但这些小问题都包含在更庞大、更有创意空间的项目中。在你的程序中，各种具体细节对其他 Python 程序员来说都应易于理解。</p>
<ul>
<li><strong>Although that way may not be obvious at first unless you’re Dutch.</strong></li>
<li><strong>Now is better than never.</strong></li>
</ul>
<p>你可以将余生都用来学习 Python 和编程的纷繁难懂之处，但这样你什么项目都完不成。不要企图编写完美无缺的代码；先编写行之有效的代码，再决定是对其做进一步改进，还是</p>
<p>转而去编写新代码。</p>
<ul>
<li><strong>Although never is often better than *right* now.</strong></li>
<li><strong>If the implementation is hard to explain, it’s a bad idea.</strong></li>
<li><strong>If the implementation is easy to explain, it may be a good idea.</strong></li>
<li><strong>Namespaces are one honking great idea – let’s do more of those!</strong></li>
</ul>
<h3 id="【6】列表"><a href="#【6】列表" class="headerlink" title="【6】列表"></a>【6】列表</h3><p><strong>列表</strong> 由一系列按特定顺序排列的元素组成。你可以创建包含字母表中所有字母、数字 0~9 或所有家庭成员姓名的列表；也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。鉴于列表通常包含多个元素，给列表指定一个表示复数的名称（如 letters 、 digits 或 names ）是个不错的主意。<strong>列表是可修改的</strong>。</p>
<p>bicycles = [‘trek’, ‘cannondale’, ‘redline’, ‘specialized’]</p>
<p>print(<strong>bicycles</strong>)</p>
<p>print(<strong>bicycles[0]</strong>)    #访问第一个元素（下标从0开始）</p>
<p>print(<strong>bicycles[-1]</strong>)    #访问最后一个元素（-1为最后一个，-2为倒数第二个，以此类推）</p>
<ul>
<li>列表增删改查</li>
</ul>
<p>motorcycles = [‘honda’, ‘yamaha’, ‘suzuki’]</p>
<p>print(motorcycles)</p>
<p><strong>motorcycles[0] = ‘ducati’</strong>    #修改第一个元素</p>
<p>print(motorcycles)</p>
<p>motorcycles.<strong>append</strong>(‘ducati’)    #在列表末尾添加元素</p>
<p>print(motorcycles)</p>
<p>motorcycles.<strong>insert</strong>(0, ‘ducati’)    # 在索引 0 处添加元素，并将值 ‘ducati’ 存储到这个地方。这种操作将列表中既有的每个元素都右移一个位置</p>
<p>print(motorcycles)</p>
<p><strong>del</strong> motorcycles[0]    #删除索引 0 处的元素</p>
<p>print(motorcycles)</p>
<p>popped_motorcycle = motorcycles.<strong>pop()</strong>    #弹出栈顶元素，删除列表末尾元素</p>
<p>print(motorcycles)</p>
<p>print(popped_motorcycle)</p>
<p>first_owned = motorcycles.<strong>pop(0)</strong>    #弹出指定索引处的元素</p>
<p>print(‘The first motorcycle I owned was a ‘ + first_owned.title() + ‘.’)</p>
<p>#每当你使用 pop() 时，被弹出的元素就不再在列表中了。</p>
<p>motorcycles.<strong>remove(‘ducati’)</strong>    # 根据值删除元素</p>
<p>print(motorcycles)</p>
<p>#方法 remove() 只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。</p>
<h3 id="【7】组织列表"><a href="#【7】组织列表" class="headerlink" title="【7】组织列表"></a>【7】组织列表</h3><p>cars = [‘bmw’，’audi’，’toyota’，‘subaru’]</p>
<p>cars.<strong>sort()</strong>    #按字母顺序永久排列</p>
<p>cars.<strong>sort(reverse = True)</strong>    #按字母顺序相反的顺序永久排列</p>
<p>print(<strong>sorted(cars)</strong>)        #按特定顺序临时排列</p>
<p>cars.<strong>reverse()</strong>        #永久反转列表排列顺序</p>
<p>cars.<strong>reverse()</strong>        #反转恢复</p>
<p><strong>len(cars)</strong>        #获取列表长度</p>
<h3 id="【8】操作列表"><a href="#【8】操作列表" class="headerlink" title="【8】操作列表"></a>【8】操作列表</h3><p>Python根据缩进来判断代码行与前一个代码行的关系。例如：</p>
<p>magicians = [‘alice’，’david’，’carolina’]</p>
<p><strong>for</strong> magician <strong>in</strong> magicians<strong>：</strong></p>
<p>print(magician.title() + “，that was great trick!”)    #开头缩进，属于前面的 for 循环</p>
<p>print(“I can’t wait to see you again!”)    #开头未缩进，不属于 for 循环</p>
<h3 id="【9】range-的使用"><a href="#【9】range-的使用" class="headerlink" title="【9】range 的使用"></a>【9】range 的使用</h3><p>for value in <strong>range(1,5)</strong>:    #打印数字1到4</p>
<p>print(value)            # 1，2，3，4</p>
<p>numbers = <strong>list(range(1,6))</strong>    #创建一个列表</p>
<p>print(numbers)                #[1，2，3，4，5]</p>
<p>even_numbers = <strong>list(range(2,11,2))</strong>    #指定步长</p>
<p>print(even_numbers)                #[2，4，6，8，10]</p>
<p>squares = [<strong>value\</strong>2 for value in range(1,11)**]    #列表解析</p>
<p>print(squares)</p>
<h3 id="【10】切片"><a href="#【10】切片" class="headerlink" title="【10】切片"></a>【10】切片</h3><p>players = [‘charles’, ‘martina’, ‘michael’, ‘florence’, ‘eli’]</p>
<p>print(<strong>players[0:3]</strong>)    #切片，输出下标 0~2（3之前）的值，即 [‘charles’, ‘martina’, ‘michael’]</p>
<p>print(<strong>players[:3]</strong>)    #从头开始到3之前</p>
<p>print(<strong>players[-3:]</strong>)    #输出最后3个元素</p>
<p>my_foods = [‘pizza’, ‘falafel’, ‘carrot cake’]</p>
<p><strong>friend_foods = my_foods[:]</strong>    #复制列表，生成一个独立的列表副本，与原列表不相关</p>
<h3 id="【11】元组"><a href="#【11】元组" class="headerlink" title="【11】元组"></a>【11】元组</h3><p>python将不能修改的值称为不可变的，而<strong>不可变的列表被称为元组</strong>。</p>
<p>dimensions = <strong>(200, 50)</strong></p>
<p>print(dimensions[0])        #元组第一个元素，200</p>
<p>print(dimensions[1])        #元组第二个元素，50</p>
<p>for dimension in dimensions:    #遍历元组</p>
<p>print(dimension)</p>
<p>dimensions = <strong>(400, 100)</strong>    #虽然不能修改元组的元素（<strong>dimensions[0]=400是非法的</strong>），但可以    </p>
<p>给存储元组的变量赋值</p>
<p>print(dimensions[0])        #元组第一个元素，400</p>
<p>print(dimensions[1])        #元组第二个元素，100</p>
<h3 id="【12】格式设置"><a href="#【12】格式设置" class="headerlink" title="【12】格式设置"></a>【12】格式设置</h3><p>1.PEP 8 建议每级缩进都使用四个空格，这既可提高可读性，又留下了足够的多级缩进空间。</p>
<p>\2. PEP 8 还建议注释的行长都不超过 72 字符，因为有些工具为大型项目自动生成文档时，会在每行注释开头添加格式化字符。</p>
<p>3.要将程序的不同部分分开，可使用空行。</p>
<h3 id="【13】python-语法"><a href="#【13】python-语法" class="headerlink" title="【13】python 语法"></a>【13】python 语法</h3><p> &gt;&gt;&gt; age_0 &gt;= 21 <strong>and</strong> age_1 &gt;= 21    #and</p>
<p>&gt;&gt;&gt; age_0 &gt;= 21 <strong>or</strong> age_1 &gt;= 21        #or</p>
<p>&gt;&gt;&gt; requested_toppings = [‘mushrooms’, ‘onions’, ‘pineapple’]</p>
<p>&gt;&gt;&gt; ‘mushrooms’ <strong>in</strong> requested_toppings    #in</p>
<p>if user <strong>not in</strong> banned_users:                #not in</p>
<p>print(user.title() + “, you can post a response if you wish.”)</p>
<p>&gt;&gt;&gt;game_active = <strong>True</strong>    #bool</p>
<p><strong>if-elseif-else:</strong></p>
<p>age = 12</p>
<p>if age &lt; 4:</p>
<p>price = 0</p>
<p>elif age &lt; 18:</p>
<p>price = 5</p>
<p>elif age &lt; 65:</p>
<p>price = 10</p>
<p>elif age &gt;= 65:</p>
<p>price = 5</p>
<p>print(“Your admission cost is $” + str(price) + “.”)</p>
<h3 id="【14】字典"><a href="#【14】字典" class="headerlink" title="【14】字典"></a>【14】字典</h3><p>alien_0 = <strong>{‘color’: ‘green’, ‘points’: 5}</strong>    #字典以键-值对的模式存储数据，类似于 Map</p>
<p>print<strong>(alien_0[‘color’])</strong>                #获取 alien_0 中 color 键对应的值，即 green</p>
<p>print(alien_0[‘points’])</p>
<p><strong>alien_0[‘x_position’] = 0</strong>            #动态添加新键 x_position</p>
<p>alien_0[‘y_position’] = 25</p>
<p><strong>alien_0 = {}</strong>                        #创建空字典</p>
<p>alien_0[‘color’] = ‘green’                #为字典赋值</p>
<p>alien_0[‘points’] = 5</p>
<p>print(alien_0)</p>
<p>alien_0[‘color’] = <strong>‘red’</strong>                #动态修改 alien_0[‘color’] 的值为 red</p>
<p><strong>del</strong> alien_0[‘color’]                    #删除键值 ‘color’</p>
<p>favorite_languages = {                #多对象存储</p>
<p><strong>‘jen’: ‘python’,</strong></p>
<p>‘sarah’: ‘c’,</p>
<p>‘edward’: ‘ruby’,</p>
<p>‘phil’: ‘python’,</p>
<p>}</p>
<p><strong>for name, language in favorite_languages.**</strong>items<strong>**():</strong>        #遍历字典</p>
<p>print(name.title() + “‘s favorite language is “ +</p>
<p>language.title() + “.”)</p>
<p><strong>for name in favorite_languages.**</strong>keys<strong>**():</strong>                #遍历所有键</p>
<p>print(name.title())</p>
<p><strong>for name in</strong> <strong>sorted**</strong>(favorite_languages.keys()):**            #按特定的顺序遍历字典</p>
<p>print(name.title() + “, thank you for taking the poll.”)</p>
<p><strong>for language in favorite_languages.**</strong>values<strong>**():</strong>            #遍历所有的值</p>
<p>print(language.title())</p>
<p><strong>for language in</strong> <strong>set**</strong>(favorite_languages.values()):**        #通过对包含重复元素的列表调用 </p>
<p>set() ，可让 Python 找出列表中独一无二的元素，并使用这些元素来创建一个集合。</p>
<p>print(language.title())</p>
<p>alien_0 = {‘color’: ‘green’, ‘points’: 5}</p>
<p>alien_1 = {‘color’: ‘yellow’, ‘points’: 10}</p>
<p>alien_2 = {‘color’: ‘red’, ‘points’: 15}</p>
<p><strong>aliens = [alien_0, alien_1, alien_2]</strong>                    #字典嵌套</p>
<p> pizza = {</p>
<p>‘crust’: ‘thick’,</p>
<p><strong>‘toppings’: [‘mushrooms’, ‘extra cheese’],</strong>            #字典中存储列表</p>
<p>}</p>
<h3 id="【15】用户输入和-while-循环"><a href="#【15】用户输入和-while-循环" class="headerlink" title="【15】用户输入和 while 循环"></a>【15】用户输入和 while 循环</h3><p>message = <strong>input</strong>(“Tell me something, and I will repeat it back to you: “)    #用户输入（python3），<strong>python2.7使用 raw_input()</strong></p>
<p>print(message)</p>
<p>&gt;&gt;&gt; age = input(“How old are you? “)</p>
<p>How old are you? 21</p>
<p>&gt;&gt;&gt; age = <strong>int</strong>(age)            #int() 将字符串转换成了数值表示</p>
<p>&gt;&gt;&gt; age &gt;= 18</p>
<p>True</p>
<p>&gt;&gt;&gt; <strong>4 % 3</strong>                #求模运算</p>
<p>1</p>
<p><strong>While 使用：</strong></p>
<p>prompt = “\nPlease enter the name of a city you have visited:”</p>
<p>prompt += “\n(Enter ‘quit’ when you are finished.) “</p>
<p><strong>while True:</strong></p>
<p>city = input(prompt)</p>
<p>if city == ‘quit’:</p>
<p><strong>break</strong>            #直接退出循环</p>
<p>else:</p>
<p>print(“I’d love to go to “ + city.title() + “!”)</p>
<p>-————————————-</p>
<p>current_number = 0</p>
<p>while current_number &lt; 10:</p>
<p>current_number += 1</p>
<p>if current_number % 2 == 0:</p>
<p><strong>continue</strong>            #返回到循环开头继续执行，并不直接退出</p>
<p>print(current_number)</p>
<h3 id="【16】函数"><a href="#【16】函数" class="headerlink" title="【16】函数"></a>【16】函数</h3><p><strong>def</strong> describe_pet(pet_name, animal_type=’dog’):</p>
<p>“”” 显示宠物的信息 “””</p>
<p>print(“\nI have a “ + animal_type + “.”)</p>
<p>print(“My “ + animal_type + “‘s name is “ + pet_name.title() + “.”)</p>
<p>#  一条名为 Willie 的小狗</p>
<p>describe_pet(‘willie’)        #以下为等效调用</p>
<p>describe_pet(pet_name=’willie’)</p>
<p>#  一只名为 Harry 的仓鼠</p>
<p>describe_pet(‘harry’, ‘hamster’)</p>
<p>describe_pet(pet_name=’harry’, animal_type=’hamster’)</p>
<p>describe_pet(animal_type=’hamster’, pet_name=’harry’)</p>
<p>-————————————————————————</p>
<p>def build_person(first_name, last_name):</p>
<p>“”” 返回一个字典，其中包含有关一个人的信息 “””</p>
<p><strong>person = {‘first’: first_name, ‘last’: last_name}</strong>    #返回字典</p>
<p>return person</p>
<p>-————————————————————————</p>
<p>print_models(<strong>unprinted_designs[:],</strong> completed_models)    #切片生成列表副本进行操作，原</p>
<p>列表不受影响</p>
<p>-————————————————————————</p>
<p>def make_pizza(<strong>*toppings</strong>):    #形参名 *toppings 中的星号让 Python 创建一个名为 toppings 的</p>
<p>空元组，并将收到的所有值都封装到这个元组中。</p>
<p>“”” 概述要制作的比萨 “””</p>
<p>print(“\nMaking a pizza with the following toppings:”)</p>
<p>for topping in toppings:</p>
<p>print(“- “ + topping)</p>
<p>make_pizza(‘pepperoni’)</p>
<p>make_pizza(‘mushrooms’, ‘green peppers’, ‘extra cheese’)</p>
<p>-————————————————————————-</p>
<p>def build_profile(first, last, <strong><em>\</em>user_info</strong>):        #形参 **user_info 中的两个星号让 Python 创建一</p>
<p>个名为 user_info 的空字典，并将收到的所有名称 — 值对都封装到这个字典中。</p>
<p>“”” 创建一个字典，其中包含我们知道的有关用户的一切 “””</p>
<p>profile = {}</p>
<p>profile[‘first_name’] = first</p>
<p>profile[‘last_name’] = last</p>
<p>for key, value in user_info.items():</p>
<p>profile[key] = value</p>
<p>return profile</p>
<p>user_profile = build_profile(‘albert’, ‘einstein’,</p>
<p>location=’princeton’,</p>
<p>field=’physics’)</p>
<p>print(user_profile)</p>
<h3 id="【17】函数与模块导入"><a href="#【17】函数与模块导入" class="headerlink" title="【17】函数与模块导入"></a>【17】函数与模块导入</h3><p><strong>import pizza</strong></p>
<p><strong>pizza.make_pizza</strong>(16, ‘pepperoni’)</p>
<p>pizza.make_pizza(12, ‘mushrooms’, ‘green peppers’, ‘extra cheese’)</p>
<p>Python 读取这个文件时，代码行 import pizza 让 Python 打开文件 pizza.py ，并将其中的所有函数都复制到这个程序中。你看不到复制的代码，因为这个程序运行时， Python 在幕后复制这些代码。你只需知道，在 making_pizzas.py 中，可以使用 pizza.py 中定义的所有函数。</p>
<p><strong>from module_name import function_name</strong></p>
<p><strong>make_pizza</strong>(16, ‘pepperoni’)</p>
<p>make_pizza(12, ‘mushrooms’, ‘green peppers’, ‘extra cheese’)</p>
<p>若使用这种语法，调用函数时就无需使用句点。由于我们在 import 语句中显式地导入了函数 make_pizza() ，因此调用它时只需指定其名称。</p>
<p><strong>from pizza import make_pizza</strong> <strong>as</strong> <strong>mp</strong></p>
<p><strong>mp</strong>(16, ‘pepperoni’)</p>
<p>mp(12, ‘mushrooms’, ‘green peppers’, ‘extra cheese’)</p>
<p>上面的 import 语句将函数 make_pizza() 重命名为 mp() ；在这个程序中，每当需要调用 make-_pizza() 时，都可简写成 mp() ，而 Python 将运行 make_pizza() 中的代码，这可避免与这个程序可能包含的函数 make_pizza() 混淆。</p>
<p><strong>import pizza</strong> <strong>as</strong> <strong>p</strong></p>
<p><strong>p</strong>.make_pizza(16, ‘pepperoni’)</p>
<p>p.make_pizza(12, ‘mushrooms’, ‘green peppers’, ‘extra cheese’)</p>
<p>上述 import 语句给模块 pizza 指定了别名 p ，但该模块中所有函数的名称都没变。</p>
<p><strong>from pizza import *</strong></p>
<p>make_pizza(16, ‘pepperoni’)</p>
<p>make_pizza(12, ‘mushrooms’, ‘green peppers’, ‘extra cheese’)</p>
<p>import 语句中的星号让 Python 将模块 pizza 中的每个函数都复制到这个程序文件中。</p>
<h3 id="【18】类"><a href="#【18】类" class="headerlink" title="【18】类"></a>【18】类</h3><p> <strong>class Dog():</strong></p>
<p>“”” 一次模拟小狗的简单尝试 “””</p>
<p>def <strong><strong>init</strong></strong>(self, name, age):        #初始化方法（相当于构造函数）前后都是<strong>两个下划线</strong></p>
<p>“”” 初始化属性 name 和 age”””</p>
<p>self.name = name</p>
<p>self.age = age</p>
<p>def <strong>sit</strong>(self):                    # self 代表类实例的本身，相当于 this</p>
<p>“”” 模拟小狗被命令时蹲下 “””</p>
<p>print(self.name.title() + “ is now sitting.”)</p>
<p>def <strong>roll_over</strong>(self):</p>
<p>“”” 模拟小狗被命令时打滚 “””</p>
<p>print(self.name.title() + “ rolled over!”)</p>
<p>my_dog = <strong>Dog</strong>(‘willie’, 6)            #根据类创建实例</p>
<p>my_dog.sit()                    #调用方法</p>
<p>my_dog.roll_over()</p>
<h3 id="【19】类的继承"><a href="#【19】类的继承" class="headerlink" title="【19】类的继承"></a>【19】类的继承</h3><p><strong>python3：</strong></p>
<p>-———————————————————————————</p>
<p><strong>class Car():</strong>        #父类</p>
<p>“”” 一次模拟汽车的简单尝试 “””</p>
<p>def <strong>init</strong>(self, make, model, year):</p>
<p>self.make = make</p>
<p>self.model = model</p>
<p>self.year = year</p>
<p>self.odometer_reading = 0</p>
<p>def get_descriptive_name(self):</p>
<p>long_name = str(self.year) + ‘ ‘ + self.make + ‘ ‘ + self.model</p>
<p>return long_name.title()</p>
<p>def read_odometer(self):</p>
<p>print(“This car has “ + str(self.odometer_reading) + “ miles on it.”)</p>
<p>def update_odometer(self, mileage):</p>
<p>if mileage &gt;= self.odometer_reading:</p>
<p>self.odometer_reading = mileage</p>
<p>else:</p>
<p>print(“You can’t roll back an odometer!”)</p>
<p>def increment_odometer(self, miles):</p>
<p>self.odometer_reading += miles</p>
<p>-————————————————————————————</p>
<p><strong>class ElectricCar(Car):</strong>        #子类</p>
<p>“”” 电动汽车的独特之处 “””</p>
<p>def <strong>init</strong>(self, make, model, year):</p>
<p>“”” 初始化父类的属性 “””</p>
<p><strong>super().<strong>init</strong>(make, model, year)</strong></p>
<p>my_tesla = ElectricCar(‘tesla’, ‘model s’, 2016)</p>
<p>print(my_tesla.get_descriptive_name())</p>
<p><strong>python2.7：</strong></p>
<p>-————————————————————————————–</p>
<p><strong>class Car(object):</strong>            #父类，需指定object</p>
<p>def <strong>init</strong>(self, make, model, year):</p>
<p>–snip–</p>
<p><strong>class ElectricCar(Car):</strong>        #子类</p>
<p>def <strong>init</strong>(self, make, model, year):</p>
<p><strong>super(ElectricCar, self).<strong>init</strong>(make, model, year)</strong></p>
<p>–snip–</p>
<h3 id="【20】从模块中导入类"><a href="#【20】从模块中导入类" class="headerlink" title="【20】从模块中导入类"></a>【20】从模块中导入类</h3><p>导入单个类：</p>
<p><strong>from car import Car</strong></p>
<p>import 语句让 Python 打开模块 car ，并导入其中的 Car 类。这样我们就可以使用 Car 类了，就像它是在这个文件中定义的一样。</p>
<p>导入多个类：</p>
<p><strong>from car import Car, ElectricCar</strong></p>
<p>从一个模块中导入多个类时，用逗号分隔了各个类。导入必要的类后，就可根据需要创建每个类的任意数量的实例。</p>
<p>导入整个模块：</p>
<p><strong>import car</strong></p>
<p>my_beetle = <strong>car.Car</strong>(‘volkswagen’, ‘beetle’, 2016)</p>
<p>print(my_beetle.get_descriptive_name())</p>
<p>my_tesla = <strong>car.ElectricCar</strong>(‘tesla’, ‘roadster’, 2016)</p>
<p>print(my_tesla.get_descriptive_name())</p>
<p>导入了整个 car 模块，并使用语法 module_name.class_name  访问需要的类。</p>
<p>导入模块中所有的类：</p>
<p><strong>from module_name import *</strong></p>
<p>不推荐使用这种导入方式，其原因有二。首先，如果只要看一下文件开头的 import 语句，就能清楚地知道程序使用了哪些类，将大有裨益；但这种导入方式没有明确地指出你使用了模块中的哪些类这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其他东西同名的类将引发难以诊断的错误。</p>
<p>在一个模块中导入另一个模块：</p>
<p><strong>from car import Car</strong></p>
<p><strong>from electric_car import ElectricCar</strong></p>
<p>从模块 car 中导入了 Car 类，并从模块 electric_car 中导入 ElectricCar 类。</p>
<h3 id="【21】Python标准库举例"><a href="#【21】Python标准库举例" class="headerlink" title="【21】Python标准库举例"></a>【21】Python标准库举例</h3><p>from collections import <strong>OrderedDict</strong></p>
<p><strong>favorite_languages = OrderedDict()</strong>    # OrderedDict 实例记录了键 — 值对的添加顺序</p>
<p>favorite_languages[‘jen’] = ‘python’</p>
<p>favorite_languages[‘sarah’] = ‘c’</p>
<p>favorite_languages[‘edward’] = ‘ruby’</p>
<p>favorite_languages[‘phil’] = ‘python’</p>
<p>for name, language in favorite_languages.items():</p>
<p>print(name.title() + “‘s favorite language is “ + language.title() + “.”)</p>
<h3 id="【22】读取文件"><a href="#【22】读取文件" class="headerlink" title="【22】读取文件"></a>【22】读取文件</h3><p>with <strong>open</strong>(‘pi_digits.txt’) <strong>as</strong> file_object:    #打开文件并返回文件对象 file_object</p>
<p>contents = file_object.<strong>read()</strong>         #读取文件对象的所有内容</p>
<p>print(contents)</p>
<p>with open(<strong>‘text_files**</strong>/<strong>**filename.txt’</strong>) as file_object:        #Linux文件路径</p>
<p>with open(<strong>‘text_files**</strong>*<strong>*filename.txt’</strong>) as file_object:        #Windows文件路径</p>
<p>-—————————————-</p>
<p>filename = ‘pi_digits.txt’</p>
<p>with open(filename) as file_object:</p>
<p><strong>for line in file_object:</strong>        #逐行读取</p>
<p>print(<strong>line.rstrip()</strong>)         #行的末尾都有一个看不见的换行符，而 print 语句也会加上</p>
<p>一个换行符，用rstrip()函数可以去除换行符</p>
<p>-—————————————-</p>
<p>filename = ‘pi_digits.txt’</p>
<p>with open(filename) as file_object:</p>
<p>lines = file_object.<strong>readlines()</strong>        # readlines() 从文件中读取每一行，并将其存储在一个列表中</p>
<p>for line in lines:</p>
<p>print(line.rstrip())</p>
<h3 id="【23】写入文件"><a href="#【23】写入文件" class="headerlink" title="【23】写入文件"></a>【23】写入文件</h3><p>filename = ‘programming.txt’</p>
<p><strong>with open(filename,</strong> <strong>‘w’**</strong>) as file_object:**        #以 写入模式 打开这个文件</p>
<p>file_object.<strong>write</strong>(“I love programming.”)</p>
<p>打开文件的模式有：<strong>读取模式 （ ‘r’ ）</strong>、 <strong>写入模式 （ ‘w’ ）</strong>、 <strong>附加模式 （ ‘a’ ）</strong>或让你能够<strong>读取和写入文件的模式（ ‘r+’ ）.</strong></p>
<p>以写入（ ‘w’ ）模式打开文件时千万要小心，因为如果指定的<strong>文件已经存在</strong>， Python 将在返回文件对象前<strong>清空该文件**</strong>。**</p>
<p>filename = ‘programming.txt’</p>
<p>with open(filename, ‘w’) as file_object:</p>
<p>file_object.write(“I love programming<strong>.\n</strong>“)        #写入多行，换行符 \n</p>
<p>file_object.write(“I love creating new games<strong>.\n</strong>“)</p>
<p>filename = ‘programming.txt’</p>
<p>with <strong>open(filename,</strong> <strong>‘a’**</strong>)** as file_object:        #以附加模式写入文件，原来的文件不清空</p>
<p>file_object.write(“I also love finding meaning in large datasets.\n”)</p>
<p>file_object.write(“I love creating apps that can run in a browser.\n”)</p>
<h3 id="【24】异常"><a href="#【24】异常" class="headerlink" title="【24】异常"></a>【24】异常</h3><p>print(“Give me two numbers, and I’ll divide them.”)</p>
<p>print(“Enter ‘q’ to quit.”)</p>
<p>while True:</p>
<p>first_number = input(“\nFirst number: “)</p>
<p>if first_number == ‘q’:</p>
<p>break</p>
<p>second_number = input(“Second number: “)</p>
<p><strong>try:</strong></p>
<p>answer = int(first_number) / int(second_number)</p>
<p><strong>except</strong> ZeroDivisionError:</p>
<p>print(“You can’t divide by 0!”)</p>
<p><strong>else:</strong></p>
<p>print(answer)</p>
<h3 id="【25】存储数据"><a href="#【25】存储数据" class="headerlink" title="【25】存储数据"></a>【25】存储数据</h3><p>import json</p>
<p>numbers = [2, 3, 5, 7, 11, 13]</p>
<p>filename = ‘numbers.json’</p>
<p>with open(filename, ‘w’) as f_obj:</p>
<p><strong>json.dump</strong>(numbers, f_obj)        #用 json.dump() 来存储数字列表</p>
<p>with open(filename) as f_obj:</p>
<p>numbers = <strong>json.load</strong>(f_obj)        #用函数 json.load() 加载存储在numbers.json 中的信        </p>
<p>息，并将其存储到变量 numbers 中</p>
<p>print(numbers)</p>
<h3 id="【26】测试函数"><a href="#【26】测试函数" class="headerlink" title="【26】测试函数"></a>【26】测试函数</h3><p>-——————————————————-</p>
<p><strong>import unittest</strong>        #导入单元测试模块</p>
<p>from name_function import get_formatted_name</p>
<p>class NamesTestCase(<strong>unittest.TestCase</strong>):    #单元测试类继承自 <strong>unittest.TestCase</strong></p>
<p>“”” 测试 name_function.py”””</p>
<p>def <strong>test</strong>_first_last_name(self):        #待测试的方法均要求以 <strong>test</strong> 开头</p>
<p>“”” 能够正确地处理像 Janis Joplin 这样的姓名吗？ “””</p>
<p>formatted_name = get_formatted_name(‘janis’, ‘joplin’)</p>
<p>self.<strong>assertEqual</strong>(formatted_name, ‘Janis Joplin’)    #用断言判断测试结果是否正确</p>
<p><strong>unittest.main()</strong>        #让 Python 运行这个文件中的测试</p>
<p><img src="../../../../asserts/233.jpg" alt="img"></p>
<p>-————————————————————–</p>
<p>import unittest</p>
<p>from survey import AnonymousSurvey</p>
<p>class TestAnonymousSurvey(unittest.TestCase):</p>
<p>“”” 针对 AnonymousSurvey 类的测试 “””</p>
<p><strong>def setUp(self):</strong></p>
<p>“”” 创建一个调查对象和一组答案，供使用的测试方法使用 “””</p>
<p>question = “What language did you first learn to speak?”</p>
<p>self.my_survey = AnonymousSurvey(question)</p>
<p>self.responses = [‘English’, ‘Spanish’, ‘Mandarin’]</p>
<p>def test_store_single_response(self):</p>
<p>“”” 测试单个答案会被妥善地存储 “””</p>
<p>self.my_survey.store_response(self.responses[0])</p>
<p>self.assertIn(self.responses[0], self.my_survey.responses)</p>
<p>def test_store_three_responses(self):</p>
<p>“”” 测试三个答案会被妥善地存储 “””</p>
<p>for response in self.responses:</p>
<p>self.my_survey.store_response(response)</p>
<p>for response in self.responses:</p>
<p>self.assertIn(response, self.my_survey.responses)</p>
<p>unittest.main()</p>
<pre><code>unittest.TestCase 类包含方法 **setUp()** ，让我们**只需创建这些对象一次**，并在每个测试方法中使用它们。如果你在 TestCase 类中包含了方法 setUp() ， Python 将先运行它，再运行各个以 test_ 打头的方法。这样，在你编写的每个测试方法中都可使用在方法 setUp() 中创建的对象了。</code></pre><h3 id="【27】项目：外星人入侵"><a href="#【27】项目：外星人入侵" class="headerlink" title="【27】项目：外星人入侵"></a>【27】项目：外星人入侵</h3><p>安装<strong>pip:</strong><a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener"><strong>https://pip.pypa.io/en/stable/installing/</strong></a></p>
<p>安装 <strong>Pygame:**</strong>$ sudo apt-get install python-pygam**</p>
<p>具体项目编程过程略。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty相关</title>
    <url>/2019/12/12/Netty/</url>
    <content><![CDATA[<p>记录 Netty 学习及使用过程中的问题。</p>
<a id="more"></a>

<p>【1】默认情况下，Netty服务端起多少线程？何时启动？</p>
<p>默认创建2倍CPU个数的NioEventLoop(当nThread参数为默认值0时)线程，在首次调用execute方法时启动线程。如果是当前NioEventLoop线程，则先判断当前线程是否已经启动，未启动则启动线程；如果是外部线程调用execute方法，则调用startThread()方法，判断当前线程是否启动，未启动则启动当前线程。</p>
<p>【2】Netty是如何解决jdk空轮询bug的？</p>
<p>判断当前时间减去Selector阻塞获取的时间与超时时间比较，如果大于超时时间，则表明是一次正常的轮询，selectCnt++，否则表明此次轮询为空轮询。当空轮询次数大于一个阈值（默认512）时，创建一个新的Selector，并将旧的参数全部复制到新的Selector上，使用新的Selector进行后续的操作，取消旧的Selector继续进行空轮询操作。</p>
<p>【3】Netty如何保证异步串行无锁化？</p>
<p>首先当前成调用Channel相关方法的时候，使用inEventLoop方法判断是内部线程还是外部线程，Netty将外部线程封装成Task，放入一个特定的队列中，在NioEventLoop执行的特殊阶段挨个执行这些外部线程（Task）,保证异步串行无锁化。</p>
<p>【4】Netty是在哪里检测有新连接介入的？</p>
<p>【5】新连接是怎样注册到NioEventLoop线程的？</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Fiddler 简单使用</title>
    <url>/2019/12/10/Fiddler/</url>
    <content><![CDATA[<p>本篇记录一下使用 Fiddler 抓取网站 WebAPI 做一个抓取网页图片的小爬虫程序的大致过程，涉及到的步骤大致有以下几步：</p>
<ol>
<li><p>Fiddler 获取网页访问特定网址的动作极其参数和返回，对于 JSON 格式的 WebAPI 返回值进行分析。</p>
</li>
<li><p>通过在线 JSON 转 POJO 工具进行 Java Bean 的生成。</p>
</li>
<li><p>使用 Retrofit2 封装对 WebAPI 的访问，结合SpringBoot JPA将信息存储到 MySQL 数据库。</p>
<a id="more"></a>
</li>
<li><p>对于未登录状态的 WebAPI 访问，进行 Cookie 的获取以及设置。</p>
</li>
<li><p>多线程并发查询，加快数据的获取速度。</p>
</li>
<li><p>已获取到的WebAPI示例。</p>
</li>
</ol>
<p><strong>一、Fiddler抓取WebAPI接口</strong></p>
<p>Fiddler是一款网络抓包分析工具，与WireShark一样，都可以抓取主机访问网络的数据流，具体的使用过程网上有很多资料，这里就不详细描述了。</p>
<p>在这里以下面的网址为例，来分析网站相关页面的WebAPI：</p>
<p><a href="https://bcy.net/" target="_blank" rel="noopener">https://bcy.net/</a></p>
<p>打开Fiddler，设置过滤条件，将与我们的目标返回无关的信息过滤掉，然后访问上面的主页，即可在Fiddler界面上看到访问链接以及返回信息：</p>
<p><img src="../../../../asserts/image-20191212084609656.png" alt="image-20191212084609656"></p>
<p><strong>二、JSON返回值在线解析生成JavaBean</strong></p>
<p>双击左侧的访问链接，在右侧就会显示Request和Response，其中Request中有访问的Header详细信息，Response中有返回数据的具体内容。我们这里以JSON数据为例：</p>
<p><img src="../../../../asserts/image-20191212085656079.png" alt="image-20191212085656079"></p>
<p>在网上搜索在线JSON转实体类网站，将Response返回的JSON数据输入解析框，设置好Class名称以及包名，生成JavaBean即可下载由JSON转化成的Java POJO，后面就可以使用这些POJO结合Retrofit的Gson解析获取最终的存储对象。</p>
<p><strong>三、Retrofit2对WebAPI访问的封装，以及SpringBoot JPA 对获取到的结果的存储</strong></p>
<p>Retrofit2是一个网络访问框架，具体的使用细节网上也有很多资料，这里也不详细展开，下面主要分析大致的使用过程以及遇到的一些问题。</p>
<p>首先设计访问接口的Service：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BcyRequestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RxJava 模式下获取指定的 Tag 标签下的 Works</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> circleId 指定 Tag 的 ID（eg: circle_id=71978）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> since 起始页（eg: since=rec:3）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sortType 排序规则（eg: sort_type=1）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gridType 单页显示数量（eg: grid_type=10）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JsonBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"common/circleFeed"</span>)</span><br><span class="line">    <span class="function">Observable&lt;TagsAnalyResult&gt; <span class="title">getBcyTagDetail</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Query(<span class="string">"circle_id"</span>)</span> String circleId,</span></span><br><span class="line"><span class="function">            @<span class="title">Query</span><span class="params">(<span class="string">"since"</span>)</span> String since,</span></span><br><span class="line"><span class="function">            @<span class="title">Query</span><span class="params">(<span class="string">"sort_type"</span>)</span> String sortType,</span></span><br><span class="line"><span class="function">            @<span class="title">Query</span><span class="params">(<span class="string">"grid_type"</span>)</span> String gridType</span></span><br><span class="line"><span class="function">    )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定的 Tag 标签下的 Works</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> circleId 指定 Tag 的 ID（eg: circle_id=71978）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> since 起始页（eg: since=rec:3）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sortType 排序规则（eg: sort_type=1）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gridType 单页显示数量（eg: grid_type=10）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JsonBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"common/circleFeed"</span>)</span><br><span class="line">    <span class="function">Call&lt;TagsAnalyResult&gt; <span class="title">getBcyTagDetailCommon</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Query(<span class="string">"circle_id"</span>)</span> String circleId,</span></span><br><span class="line"><span class="function">            @<span class="title">Query</span><span class="params">(<span class="string">"since"</span>)</span> String since,</span></span><br><span class="line"><span class="function">            @<span class="title">Query</span><span class="params">(<span class="string">"sort_type"</span>)</span> String sortType,</span></span><br><span class="line"><span class="function">            @<span class="title">Query</span><span class="params">(<span class="string">"grid_type"</span>)</span> String gridType</span></span><br><span class="line"><span class="function">    )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对Retrofit2客户端进行初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRetrofitAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                <span class="comment">// 设置OKHttpClient,如果不设置会提供一个默认的</span></span><br><span class="line">                .client(getClient())</span><br><span class="line">                <span class="comment">//设置baseUrl</span></span><br><span class="line">                .baseUrl(BASE_API_URL)</span><br><span class="line">                <span class="comment">//添加Gson转换器</span></span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        bcyApiService = retrofit.create(BcyRequestService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 getClient() 方法是自定义的一个HttpClient，主要是针对Cookie的获取与设置进行了一些修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 OkHttpClient</span></span><br><span class="line"><span class="comment">     *添加Cookie拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OkHttpClient.Builder client = <span class="keyword">new</span> OkHttpClient().newBuilder();</span><br><span class="line"></span><br><span class="line">        client.interceptors().add(<span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// 获取 Cookie</span></span><br><span class="line">                okhttp3.Response resp = chain.proceed(chain.request());</span><br><span class="line">                List&lt;String&gt; cookies = resp.headers(<span class="string">"Set-Cookie"</span>);</span><br><span class="line">                String cookieStr = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span> (cookies != <span class="keyword">null</span> &amp;&amp; cookies.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookies.size(); i++) &#123;</span><br><span class="line">                        cookieStr += cookies.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                   log.info(<span class="string">"COOKIE-SET-&gt;"</span> + cookieStr);</span><br><span class="line">                    UserUtil.getSingletonInstance().setCookie(cookieStr.split(<span class="string">";"</span>)[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        client.interceptors().add(<span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// 设置 Cookie</span></span><br><span class="line">                String cookieStr = UserUtil.getSingletonInstance().getCookie();</span><br><span class="line">                log.info(<span class="string">"COOKIE-GET-&gt;"</span> + cookieStr);</span><br><span class="line">                <span class="keyword">if</span> (!cookieStr.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> chain.proceed(chain.request().newBuilder().header(<span class="string">"Cookie"</span>, cookieStr).build());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> chain.proceed(chain.request());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        client.connectTimeout(TIMOUT, TimeUnit.MILLISECONDS);</span><br><span class="line">        client.writeTimeout(TIMOUT, TimeUnit.MILLISECONDS);</span><br><span class="line">        client.readTimeout(TIMOUT, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> client.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后进行WebAPI的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**同步访问*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBcyTagDetailsCommon</span><span class="params">(String id, <span class="keyword">int</span> page, BcyCallback&lt;Picture&gt; callback)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Call&lt;TagsAnalyResult&gt; call = bcyApiService.getBcyTagDetailCommon(id,<span class="string">"rec:"</span>+ String.valueOf(page), <span class="string">"1"</span>, <span class="string">"10"</span>);</span><br><span class="line">        <span class="keyword">int</span> items_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (call != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Response&lt;TagsAnalyResult&gt; response = call.execute();</span><br><span class="line">            <span class="keyword">for</span> (Items items : response.body().getData().getItems()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Image_list img : items.getItem_detail().getImage_list()) &#123;</span><br><span class="line">                    Picture picture = <span class="keyword">new</span> Picture();</span><br><span class="line">                    picture.setUserName(items.getItem_detail().getUname());</span><br><span class="line">                    picture.setUid(String.valueOf(items.getItem_detail().getUid()));</span><br><span class="line">                    picture.setAlbumName(items.getItem_detail().getWork());</span><br><span class="line">                    picture.setAlbumId(String.valueOf(items.getItem_detail().getWid()));</span><br><span class="line">                    picture.setCover(items.getItem_detail().getCover());</span><br><span class="line">                    picture.setStars(items.getItem_detail().getLike_count());</span><br><span class="line">                    StringBuilder tags = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">for</span> (Post_tags tag : items.getItem_detail().getPost_tags()) &#123;</span><br><span class="line">                        tags.append(tag.getTag_name());</span><br><span class="line">                        tags.append(<span class="string">";"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    picture.setTags(tags.toString());</span><br><span class="line">                    picture.setPath(img.getPath());</span><br><span class="line">                    picture.setOriginPath(covert2OriginPath(img.getPath()));</span><br><span class="line">                    callback.onNet(picture);</span><br><span class="line">                    items_count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            callback.onSuccess(<span class="string">"Completed! ItemsCount="</span> + String.valueOf(items_count));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback.onFailure(<span class="string">"CallbackBULL-&gt;[since=rec:"</span> + String.valueOf(page) + <span class="string">"; circle_id="</span> + id + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获取到Picture对象之后就可以进行对象的存储了。</p>
<p>基本逻辑已经确立，在进行WebAPI查询的过程中可能存在一个比较严重的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected a string but was BEGIN_OBJECT at line <span class="number">1</span> column <span class="number">57992</span> path $.data.items[<span class="number">19</span>].item_detail.replies[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>这个异常产生的原因是：在使用JSON字符串产生JavaBean时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item_detail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String item_id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> uid;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line">    <span class="keyword">private</span> String odin_uid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value_user;</span><br><span class="line">    <span class="keyword">private</span> String vu_description;</span><br><span class="line">    <span class="keyword">private</span> String follow_state;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Rights&gt; rights;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> ctime;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String plain;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> word_count;</span><br><span class="line">    <span class="keyword">private</span> String cover;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Multi&gt; multi;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pic_num;</span><br><span class="line">    <span class="keyword">private</span> String work;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> wid;</span><br><span class="line">    <span class="keyword">private</span> String real_name;</span><br><span class="line">    <span class="keyword">private</span> String work_cover;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Post_tags&gt; post_tags;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> like_count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> user_liked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> reply_count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> share_count;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Props&gt; props;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; replies;	<span class="comment">//此处存在异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> visible_level;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> user_favored;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Image_list&gt; image_list;</span><br><span class="line">    <span class="keyword">private</span> Top_list_detail top_list_detail;</span><br><span class="line">    <span class="keyword">private</span> Extra_properties extra_properties;</span><br><span class="line">    <span class="keyword">private</span> String editor_status;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> repostable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> repost_count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> visible_status;</span><br><span class="line">    <span class="keyword">private</span> String visible_status_msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 “private List<String> replies;” 参数将Replie类型解析成为了String类型。</p>
<p>由于我们获取到的JSON返回是用一个特定的Request得到的，所以获取到的JSON字符串中的列表很可能为空，比如像下面的一个列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">replies : []</span><br></pre></td></tr></table></figure>

<p>这种情况下，Gson就会将replies列表解析成为List<String>。我们不知道列表里面具体的类型是什么，所以当生成的JavaBean中出现String列表的时候就要注意了，绝大部分情况下这个列表不是String列表，而是有一个实体类与之对应，我们能做的就是遇到这个错误的时候找到对应的实体类，并将String列表修改成为对应的实体列表。</p>
<p>当然，如果已知具体的WebAPI定义，则不存在这个问题。</p>
<p><strong>四、Cookie设置</strong></p>
<p>在进行Request访问时，会从服务端获取Cookie，再将Cookie中的用户信息设置到Request的Cookie中，达到认证的功能，以下为Response中获取的Cookie以及Request Header中发送的Cookie示例：</p>
<p>Request Header:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET https://bcy.net/apiv3/common/hotCircleList?offset=20&amp;_signature=aHtaaAAgEBWDbr3j6eLWfmh7WnAADWO HTTP/1.1</span><br><span class="line">Host: bcy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Referer: https://bcy.net/</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: tt_webid=6765672592922707470; Hm_lvt_330d168f9714e3aa16c5661e62c00232=1575255918,1575350791,1575681218,1575889227; SLARDAR_WEB_ID=cd3a2238-841b-4e08-b0c1-6e077f3ae418; lang_set=zh; _ga=GA1.2.734520056.1575263761; msh=36tNx_itQKzpF5GLXfBTVteDxk8; passport_auth_status=e3d3ca9ace75ac8ef9c00b53a30bc837%2C; sid_guard=e64f91b94ddd3984e4fbf4fed0d03d12%7C1575266305%7C5184000%7CFri%2C+31-Jan-2020+05%3A58%3A25+GMT; uid_tt=708b99c250828a189dce12014f8aa356; sid_tt=e64f91b94ddd3984e4fbf4fed0d03d12; sessionid=e64f91b94ddd3984e4fbf4fed0d03d12; main_sid=e8e9945d541b8d962ea745142ade2547; __tea_sdk__ssid=undefined; _bcy_user_id=U2FsdGVkX181UhlS1LtAL1QLNCWhGcQ9annTwWC4+Y9epGqhfOuRucw7bG53x39Ir/aB5WPSHpE12Y9e7HPKOh1Qom0CfKObsfqjQV9AkcA=; _csrf_token=156c84b03e3a2808639f8fe166752c11; mobile_set=no</span><br></pre></td></tr></table></figure>

<p>Response Cookie：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Response sent 203 bytes of Cookie data:</span><br><span class="line">	Set-Cookie: _bcy_user_id=U2FsdGVkX19ubdzzra5Tgm3KwME9JQ9OfpCFJv/rkGFYdgwhONE8I/gtcEB50/xfInpY2Mya73UajXPQZ1NGxzKSVUuJLPPseohWU//YKrw=; path=/; expires=Thu, 12 Dec 2019 04:35:24 GMT; domain=.bcy.net; secure; httponly</span><br><span class="line"></span><br><span class="line">Response sent 95 bytes of Cookie data:</span><br><span class="line">	Set-Cookie: mobile_set=no; path=/; expires=Thu, 12 Dec 2019 04:35:24 GMT; domain=.bcy.net; secure; httponly</span><br><span class="line"></span><br><span class="line">Response sent 100 bytes of Cookie data:</span><br><span class="line">	Set-Cookie: tt_webid=6765672592922707470; path=/; expires=Sun, 15 Dec 2019 15:52:12 GMT; domain=.bcy.net; secure</span><br><span class="line"></span><br><span class="line">This response did not contain a P3P Header.</span><br></pre></td></tr></table></figure>

<p>需要注意的是，我们初次访问一个WebAPI接口的时候，Request Header Cookie中的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_bcy_user_id=U2FsdGVkX181UhlS1LtAL1QLNCWhGcQ9annTwWC4+Y9epGqhfOuRucw7bG53x39Ir/aB5WPSHpE12Y9e7HPKOh1Qom0CfKObsfqjQV9AkcA=; _csrf_token=156c84b03e3a2808639f8fe166752c11;</span><br></pre></td></tr></table></figure>

<p>字段是为空的，需要在Response Cookie中的 “Set-Cookie” 获取，是一种先登录，后访问的模式。具体的设置Request Header Cookie方法以及获取Response Cookie的方法在Retrofit2的初始化getClient()方法里面有详细的过程。</p>
<p><strong>五、多线程并发查询</strong></p>
<p>在SpringBoot的入口类开启异步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BcyappserverApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(BcyappserverApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后再需要异步处理的方法上添加异步注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asynGetBcyTagDetailPictures</span><span class="params">(String tagId, <span class="keyword">int</span> pageIndex, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        getBcyTagDetailCommon(tagId, pageIndex);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        log.info(<span class="string">"CountDownLatch --- "</span>+countDownLatch.getCount() + <span class="string">" --- completed!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的 CountDownLatch 对象保证多线程访问时所有的线程任务全部处理完毕之后才退出主线程，避免子线程刚开启时主线程退出造成所有的子线程全部退出，任务不能正常执行的情况。</p>
<p>对于多线程数据存储的情况，将存储方法用 synchronized 加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">savePicture</span><span class="params">(Picture pic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( pictureRepository.findByPath(pic.getPath()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pictureRepository.save(pic);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免数据的重复插入。</p>
<p><strong>六、已获取到的WebAPI示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【1】HotTag获取</span><br><span class="line">https://bcy.net/apiv3/common/hotTags</span><br><span class="line">【2】hotCircleList获取</span><br><span class="line">https://bcy.net/apiv3/common/hotCircleList?offset=20</span><br><span class="line">【3】circle解析</span><br><span class="line">https://bcy.net/apiv3/common/circleFeed?circle_id=71978&amp;since=rec:3&amp;sort_type=1&amp;grid_type=10</span><br><span class="line">【4】用户Works获取</span><br><span class="line">https://bcy.net/apiv3/user/selfPosts?uid=221571</span><br><span class="line">【5】Search搜索</span><br><span class="line">https://bcy.net/search/all?k=%E6%B5%85%E6%B5%85ASAKI</span><br><span class="line">【6】RankWeekly周榜</span><br><span class="line">首页：https://bcy.net/apiv3/rank/list/channelItemInfo?channel_id=6618800694038102275&amp;ttype=cos&amp;sub_type=week</span><br><span class="line">详情页：https://bcy.net/apiv3/rank/list/itemInfo?p=2&amp;ttype=cos&amp;sub_type=week&amp;date=20191202</span><br><span class="line">【7】RankLastDay日榜</span><br><span class="line">首页：https://bcy.net/apiv3/rank/list/channelItemInfo?channel_id=6618800694038102275&amp;ttype=cos&amp;sub_type=lastday</span><br><span class="line">【8】详情页：https://bcy.net/apiv3/rank/list/itemInfo?p=2&amp;ttype=cos&amp;sub_type=lastday&amp;date=20191202</span><br><span class="line">【9】RankNewPeople新人榜</span><br><span class="line">首页：https://bcy.net/apiv3/rank/list/channelItemInfo?channel_id=6618800694038102275&amp;ttype=cos&amp;sub_type=newPeople</span><br><span class="line">详情页：https://bcy.net/apiv3/rank/list/itemInfo?p=2&amp;ttype=cos&amp;sub_type=newPeople&amp;date=20191202</span><br><span class="line">【10】用户作品获取：以最后一个Item的since标记为下一页的请求起始</span><br><span class="line">https://bcy.net/apiv3/user/selfPosts?uid=221571</span><br><span class="line">https://bcy.net/apiv3/user/selfPosts?uid=221571&amp;since=6218245164293447438</span><br><span class="line">https://bcy.net/apiv3/user/selfPosts?uid=221571&amp;since=6168849853523713806</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《乡土中国》</title>
    <url>/2019/12/10/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>《代谢增长论》</title>
    <url>/2019/12/10/%E4%BB%A3%E8%B0%A2%E5%A2%9E%E9%95%BF%E8%AE%BA/</url>
    <content><![CDATA[<p>【1】历史作为检验经济学理论的自然实验：历史可以看做最好的自然实验。</p>
<p>【2】即使后来被证明是错误的思路，也给了后人“此路不通”的警示。</p>
<a id="more"></a>

<p>【3】哈里斯人为：猪肉是一种可口的食物，能量转化率非常高，但猪不爱运动，喜欢潮湿，而对一个游牧民族来说，干旱草场的载畜量有限，要经常迁徙。若喜欢上猪肉的话，老百姓就不愿意迁徙，就会危及到他们的生活方式。所以当猪肉变成一种贵族的奢侈品，价格昂贵到大众无法消费的时候，就变成了一种禁忌。</p>
<p>【4】李约瑟讲到：在传统中国的许多发明中，凡是通过吸收人力增加产量的技术，就很容易被吸收，而节省人力的机械技术却难以在中国推广。</p>
<p>【5】发现一种界线，便是发现一种规律。</p>
<p>【6】稳定与发展，安全与机会是此消彼长的关系，有如鱼和熊掌不可兼得。</p>
<p>【7】在环境涨落明显，资源有限的条件下，保守者将战胜冒险者；在环境涨落不大、不断出现新资源的条件下，爱好风险的人更有机会探索新的资源。</p>
<p>【8】一个非常紧迫的任务就是要尽可能地搜集和保存生物基因，建立保存和积累这些基因的长期的文明宝库，很难将它们未来何时有价值。（云南种质资源库？！）</p>
<p>【9】新的更一般的理论可以把对立派别中的有益部分作为特殊情形包括在新理论之中。</p>
<p>【10】翻万卷书，游万里路，会百家才。</p>
<p>【11】毕达哥拉斯和柏拉图的信念：世界的规律可以用数学来完美地描述。</p>
<p>【12】中国的经验科学强调整体的复杂性，但是始终不去寻找解开复杂，简化运动的科学方法。</p>
<p>【13】科学实践上总是取应用最广泛、计算最简单的一种，除非新的实验事实迫使人们做进一步地修正。</p>
<p>【14】科学部门的出现成为第四次社会大分工，即信息生产和物质生产的分离。</p>
<p>【15】科学发展所依赖的基本规律可以作为历史现象分析的重要标准之一。</p>
<p>【16】对技术革命的分类论：1）技术路线论 2）技术倾向论 3）综合体系论</p>
<p>【17】技术革命分期论：</p>
<ul>
<li><p>第一次技术革命—-工作机革命（1764~1830）</p>
</li>
<li><p>第二次技术革命—-传输机革命（1830~1945）</p>
<p>–集中全力解决物质、能量、信息的传输问题。（交通网、能源网、信息网络、天基互联、地基增强）</p>
</li>
<li><p>第三次技术革命—-控制机革命（1945至今）</p>
</li>
</ul>
<p>【18】能否健康消化外国技术，取决于自己科技政策和组织体制的适宜，而不在资本和技术本身。</p>
<p>【19】各部门、企业之间的隔绝和保密是技术进步的大敌。</p>
<p>【20】现实的经济系统是市场经济与计划经济的有机结合。</p>
<p>【21】只要我们把所有权和管理权分开处理，经济体制的改革就易于解放思想，广开门路。</p>
<p>【22】井田制的瓦解不是生产力发展引起的生产关系的变革，而是土地危机的加深逐渐造成的农业经济结构的恶化。</p>
<p>【23】从现代科学的观点来看，事务适度的稳定性和进化度是任何一个生物物种或社会组织能否具有生命力的首要特征。</p>
<p>【24】生态破坏是难以逆转的演化过程。</p>
<p>【25】我国农业发展的限制：</p>
<ul>
<li>多山少地的自然条件形成的精耕细作的生产方式</li>
<li>缺少优良海港和路上交通网</li>
</ul>
<p>【26】从长远来看，正确的方针是不能因为交通困难而要求牧区粮食自给，反对南粮北调，反对进口粮食；而是恰恰相反，应该大力发展交通网，以促进多种经营、区域分工，发展商品生产和规模经济。如果能够充分利用国际市场，则我国的林、牧、渔业和经济作物会大有发展的余地，即使粮食生产暂时缩减也是值得的，粮食可以部分依赖进口。算大账，这是更有利的。</p>
<p>【27】那高出地平面约10米的地上黄河比核战争的威胁更为现实。</p>
<p>【28】不大力发展农用公路和农用汽车，不建立汽车和拖拉机的合理比例，钢材、燃料都会产生极大的浪费。</p>
<p>【29】要想把我国产品打入国际市场，落后的交通系统是目前的主要障碍。</p>
<p>【30】要想办法改变目前以燃烧固态煤为主的能源结构，发展便于传输的其它能源。（国家电网？！可再生能源）</p>
<p>【31】经济结构是决定社会生产力的一个重要因素，同时对生产关系也产生一定的影响。</p>
<p>【32】“人们必须首先吃、喝、住、穿，然后才能从事政治、科学、艺术、宗教等”。</p>
<p>【33】欧洲史上不存在中国封建王朝那种无节制的横征暴敛，其原因不在于统治者的“慈善”，而在于无法长期保存肉奶制品，征收的实物数量只能以适时消费为限，经济技术结构本身的性质对统治阶级的行为产生了制约。</p>
<p>【34】海运和铁路是决定竞争效率的经济动脉。</p>
<p>【35】伊斯兰教更侧重军事冒险，基督教更维护商业竞争。</p>
<p>【36】只有铁路、公路联系每一个村庄，电话和电视机普及每一个家庭，中国小农的保守心理才有可能得到根本改造。（五通工程，天朝基建，举世无双！）</p>
<p>【37】开放经济和封闭经济的差别是西欧商品经济体系和亚细亚生产方式之间最本质的差别。</p>
<p>【38】罗马帝国的灭亡、统治阶级的腐化和对外战争的失败只是表面现象，根本原因在于罗马帝国以牧为主的混合经济支撑不了庞大国家机器的负担，无法用军事力量维持庞大的帝国。</p>
<p>【39】资本主义的统一市场，特别是传输机革命的结果，真正造成了国家统一的经济基础。</p>
<p>【40】中国封建统一的力量在于军队而不在于商业联系或者儒家文化。</p>
<p>【41】运输和通信工具的发展比铁器的使用更能影响一国的命运。</p>
<p>【42】我国整个历史上充满的起义和内战，归根到底是一种周期性的土地危机或粮食危机。</p>
<p>【43】东方世界不同于西方世界的主要历史根源仍在于经济而不是政治或文化。</p>
<p>【44】只有大力发展铁路、公路和通信系统，发展便于传输的电力、煤气、石油等二次能源，才能开发内地资源，发展商品生产。</p>
<p>【45】我们定义经济结构为生产过程中（不考虑分配过程），人、技术、自然之间的相互关系，并且具体地把它区分为三个层次，即生态经济结构、技术经济结构和经济管理结构。</p>
<p>【46】生产力的因素包括劳动对象、生产工具和劳动者。考虑到劳动生产力的高低是生产力发展水平的标志，可以推广马克思的思想，把经济结构作为生产力发展的第四因素。</p>
<p>【47】我们必须充分掌握世界发展的信息，研究鼓励多样化发展的决策，把全国人民都动员起来加入国际经济竞争。只有在竞争中学习，才知道对我国适宜的发展道路何在；只有在竞争中胜利，才能增强民族的信息和自尊心。</p>
<p>【48】在东西方文化对资源的竞争中，不断创新起到生死存亡的作用。</p>
<p>【49】劳动分工不可能在一个保守型的文化中出现。</p>
<p>【50】学习不仅仅是个决定论过程，机会在个人发展中也起到了关键性的作用。</p>
<p>【51】分岔、多峰分布等非线性数学的概念在描述社会现象时是非常有用的。</p>
<p>【52】一般斯密定理：劳动分工受市场规模、资源种类和环境涨落的三重限制。</p>
<p>【53】劳动分工的竞争机制和生态约束是理解当代演化经济学若干基本问题的关键。简单组织和复杂组织共存的关键在稳定性和复杂性之间的消长关系。</p>
<p>【54】两个使用统一资源的完全竞争者不可能共存。（中国王朝更迭）</p>
<p>【55】个人主义的文化比集体主义的文化需要更大的生存空间。（西方人少地多但是仍然热衷于殖民扩张，东方人多地少确仍热衷于生息繁衍）</p>
<p>【56】文化形态是由生存所需的食物结构所决定的。</p>
<p>【57】找到不同于西方的节省资源、开发智力和多样发展的技术，才能使资源短缺、人口众多、地域多样的中国得到多样的发展。</p>
<p>【58】假如立业或者立国的稳定有一定的临界规模存在，则集体主义种群抵抗外敌或灾害的稳定性要比个人主义种群为高。</p>
<p>【59】集体主义文化比个人主义文化要求的资源差距或者学习效率的差距小得多，甚至可能在稍微落后的情形下，接近和取代富有的种群。</p>
<p>【60】稳定性的增加以牺牲复杂性为代价，而多样性的发展又以降低系统的稳定性为代价。</p>
<p>【61】从稳定性和复杂性之间的消长关系出发，我们可以分析公司兼并或公司分拆的经济背景，判断市场份额和进入时机。如果能抓住新技术和新市场，进取型的策略就可能成功；如果面对的是停滞的市场和社会的动荡，保守型的战略更易使公司生存。</p>
<p>【62】我国可以采取紧跟战略，即投入小量资金作研究开发，以培养人才、组织队伍、观察动向、追踪发展。在科学教育上必须追求多元化。但在工业政策上，不可完全自由放任。</p>
<p>【63】我们可以建立科学界和政府间的紧密合作，在新技术刚刚进入实用阶段，还未达到垄断的规模经济时，就立即不失时机的加以引进和推广，配合标准指定、金融扶助、税收优待等配套措施，以达到迅速赶超和占领市场的目的。（5G？！）</p>
<p>【64】经济能否持续增长，取决于新的技术更新能否发现更大的资源，以摆脱旧资源报酬递减的限制。</p>
<p>【65】我国小农经济的资源限制和保守倾向，阻碍了劳动分工和科学文化的多样发展。</p>
<p>【66】我国的法制建设是和经济发展并进的共生演化过程，而不是全盘西化的移植过程。这也是我国改革的重要经验之一。</p>
<p>【67】在文明发展的早期，生态环境对技术的选择起决定作用，但工业革命产生以后，技术选择日益受国际竞争的格局和科学教育的影响。技术成型后，文化制度的演化又会对生态环境产生深远的影响。这种相互作用在某一历史时期总能识别主要的决定机制。</p>
<p>【68】社会演化是：生态—技术—经济—文化—制度相互作用的多层次、多样化和演化的。</p>
<p>【69】两个认识：1）观察—问题—模型—检验 2）特殊—一般—特殊。</p>
<p>【70】社会演化并非一个“不可避免”的决定性过程。资本主义与科学的产生在历史长河中是一个罕见的时间。（文明分岔演化）</p>
<p>【71】复杂系统比简单系统更不稳定是普遍正确的。</p>
<p>【72】保守族群和进取族群的混合社会比两个进取族群的混合社会更加稳定。</p>
<p>【73】在一个社会主义国家，可行的改革方案必须是小心细致的混合经济模式。开放的程度和方式取决于历史的国际环境与自身的竞争力。不稳定不仅意味着风险，也意味着机会。重点不是消灭差别，而是管理合理的差别，使其不至于扩大为社会冲突。</p>
<p>【74】我国对分权试验及新制度的渐进演化持宽容的态度，这是与东欧俄罗斯相比经济改革取得成功的主要原因。</p>
<p>【75】创新和科技进步本质上是不稳定的，其经济特征表现为创造性毁灭和技术更替。</p>
<p>【76】开放竞争的方向决定之后，时机的把握和战略的选择就成为竞争胜败的决定性因素。</p>
<p>【77】历史因素会构成政府行为的“路径依赖”。</p>
<p>【78】如果国有企业或者乡镇企业在新产品市场上取得成功，就用股份制的办法承认新兴的企业家和经理人的贡献；如果企业改革失败，就让国有银行承担主要的改制成本。</p>
<p>【79】计划经济的主要问题不是缺乏竞争激励，而是闭关政策所造成的技术停滞和组织老化。</p>
<p>【80】影响上市公司业绩的主要因素是科技、管理、公司战略和规模经济等，所有制形式的影响并不显著。</p>
<p>【81】如何判断不同的指标体系的真实性和误差水平呢？——–多数老百姓的生活感觉比经济学家的理论更加靠谱。</p>
<p>【82】高价商品不用排队，不等于改善人民生活，更不等于改善经济的国际竞争力。</p>
<p>【83】邓公大胆放开出国留学政策，相信中国改革开放的成功最终会吸引留学生回国，使中国在获得西方技术的同时也赢得了中国知识分子的人心。</p>
<p>【84】分工加市场不等于协作。</p>
<p>【85】在国际竞争的条件下，降低利率可能引发资本外逃，流向投资回报率更高的地区。并不一定如教科书所说的，降低利息等于降低投资成本，必然增加投资，刺激经济增长。</p>
<p>【86】政府和非营利性的大学等社会组织在产业研发的初期起重大作用，在产业衰落的转型期也起重要作用。</p>
<p>【87】我国的有为政府和以天下为己任的科学家、实业家，有教育的工人、农民合作奋斗的积极性，是西方经济学所讲的劳力、资本、资源三要素之外，更重要的比较优势。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>《八次危机》</title>
    <url>/2019/12/10/%E5%85%AB%E6%AC%A1%E5%8D%B1%E6%9C%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>自动更新模块问题记录</title>
    <url>/2019/12/10/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>ESOP上线使用已经有一段时间了，期间也遇到了许许多多的问题，最近在解决问题的时候发现一个当初设计的时候存在的一个十分严重的错误，再此记录一下问题与解决方法，给自己一个提醒，在后续的工作中注意这方面的问题。</p>
<a id="more"></a>

<h3 id="问题一：配置文件读取"><a href="#问题一：配置文件读取" class="headerlink" title="问题一：配置文件读取"></a>问题一：配置文件读取</h3><p>当前配置文件存储与读取有两种方式：1）创建properties文件；2）使用Preferences对象存储</p>
<p>当初使用properties文件时虽然已经将properties文件的读取范围限制到最小，仅读取“globleconfig.properties”文件，并且限制操作为只读取，不写入，然而在最近的使用过程中依然出现了properties文件被破坏的情况，分析原因，发现当初在写properties的读写方法时存在一个严重的缺陷：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readValue</span><span class="params">(String filePath, String key)</span> </span>&#123;</span><br><span class="line">		String res = <span class="string">""</span>;</span><br><span class="line">		Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">		InputStream in = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(filePath));</span><br><span class="line">			props.load(in);</span><br><span class="line">			String value = props.getProperty(key);</span><br><span class="line">			<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">				res = value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					in.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当初在读写时，InputStream在操作完成之后并未释放！</p>
<h3 id="问题二：Launcher程序需要更新时的处理"><a href="#问题二：Launcher程序需要更新时的处理" class="headerlink" title="问题二：Launcher程序需要更新时的处理"></a>问题二：Launcher程序需要更新时的处理</h3><p>此问题与问题一也是相关的，当“globleconfig.properties”文件被破坏，造成配置文件内容清空的时候，Launcher启动时会直接卡在更新界面不能向下执行，涉及到Launcher的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LauncherHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((!FileUtil.getAppNameFromProperties().isEmpty()&amp;&amp;  </span><br><span class="line">	(!FileUtil.getLineCodeFromProperties().isEmpty())&amp;&amp;  </span><br><span class="line">	(!FileUtil.getDisplayNumber().isEmpty())) &#123;</span><br><span class="line">		<span class="keyword">if</span> (CommonUtil.getValueFromPreference(FileUtil.getAppNameFromProperties())  </span><br><span class="line">		.isEmpty()) &#123;</span><br><span class="line">			CommonUtil.saveValue2Preference(FileUtil.getAppNameFromProperties(),  </span><br><span class="line">            FileUtil.getDefaultPath(FileUtil.getAppNameFromProperties()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!CommonUtil.getValueFromPreference(<span class="string">"LINECODE"</span>).equals(  </span><br><span class="line">		FileUtil.getLineCodeFromProperties())) &#123;</span><br><span class="line">			CommonUtil.saveValue2Preference(<span class="string">"LINECODE"</span>,  </span><br><span class="line">			FileUtil.getLineCodeFromProperties());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!CommonUtil.getValueFromPreference(<span class="string">"DNUMBER"</span>).equals(   </span><br><span class="line">		FileUtil.getDisplayNumber())) &#123;</span><br><span class="line">			CommonUtil.saveValue2Preference(<span class="string">"DNUMBER"</span>, FileUtil.getDisplayNumber());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!CommonUtil.getValueFromPreference(<span class="string">"MYAPP"</span>).equals(  </span><br><span class="line">		FileUtil.getAppNameFromProperties())) &#123;</span><br><span class="line">				CommonUtil.saveValue2Preference(<span class="string">"MYAPP"</span>,  </span><br><span class="line">				FileUtil.getAppNameFromProperties());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"GlobleSetting file crashed!"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当时设计的时候并未考虑“globleconfig.properties”被破坏并清空的情况，所以在构造函数中未添加对properties文件的内容非空检测，造成后续将properties文件中的配置写入Preference时将空值写入，覆盖了之前的正常值。</p>
<p>那么问题来了，当初在设计自动更新程序的时候是采用以下的模式：</p>
<p><img src="../../../../asserts/image-20191210102546228.png" alt="image-20191210102546228"></p>
<p>默认Launcher加载器是不更新的，每次启动时，ESOP程序通过Launcher查询SMES，比对当前版本后由Launcher通过FTP的方式将更新文件拉取下来，完成显示端程序的更新，这个过程是单向的，只能由Launcher来更新。在Launcher本身出现异常的时候就无法通过自动更新程序来解决了。</p>
<p>此时有两种解决方式：</p>
<p>1）由Launcher更新ESOP程序，再在ESOP程序内设置配置文件反过来更新Launcher</p>
<p>这种方式可以覆盖之前已安装的硬件设备的程序，但是存在一个大的风险点：如果更新之后的Launcher程序由于BUG将前端访问逻辑截断，则会完全堵死由自动更新程序进行后续更新操作的可能性。</p>
<p>2）重新设计Launcher自更新逻辑，可以先自动更新Launcher，再由Launcher更新后续ESOP的主程序</p>
<p>这种方式可以对Launcher程序有很灵活的把控，但是对于已安装的硬件设备，由于自更新逻辑未添加，则比较难处理。</p>
<p>综合上述两种处理方式，可以使用第一种方案的方式将更新过自更新逻辑的Launcher文件更新到已安装的硬件，后续安装的新终端则直接使用第二种方案，实现Launcher与ESOP的同步更新。</p>
<p>这里还要注意一点，设计Launcher程序的时候要做到尽量精简，尽量降低Launcher出现BUG的可能性，由于大量硬件已安装，所以这里的更新程序不能像手机中的APP更新程序，在一个大版本更新生成的时候提示用户先卸载旧程序，再下载新程序来更新程序到最新版本。这也是一个需要注意的十分重要的问题。</p>
<h3 id="问题三：文件拷贝时的路径问题"><a href="#问题三：文件拷贝时的路径问题" class="headerlink" title="问题三：文件拷贝时的路径问题"></a>问题三：文件拷贝时的路径问题</h3><p>在文件拷贝的时候，对于更新后的文件，之前默认使用的是相对路径，但是拷贝之后发现使用相对路径很容易出现问题，后面就使用绝对路径来进行程序的拷贝与读取，以下是获取Jar包所在绝对路径的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRealPathOfTheJar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String jarWholePath = FileUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getProtectionDomain</span>().<span class="title">getCodeSource</span>().<span class="title">getLocation</span>().<span class="title">getFile</span>()</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jarWholePath = java.net.URLDecoder.decode(jarWholePath, <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; System.out.println(e.toString()); &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(jarWholePath).getParentFile().getAbsolutePath();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其中 FileUtils.class 为Jar包里面的类文件。</p>
]]></content>
      <tags>
        <tag>raspberry</tag>
        <tag>problems</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存雪崩和缓存击穿</title>
    <url>/2019/12/10/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    <content><![CDATA[<p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p>
<a id="more"></a>

<p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。本篇文章，并不是要更加完美的解决这三个问题，也不是要颠覆业界流行的解决方案。而是，从实际代码操作，来演示这三个问题现象。之所以要这么做，是因为，仅仅看这些问题的学术解释，脑袋里很难有一个很形象的概念，有了实际的代码演示，可以加深对这些问题的理解和认识。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h3><p>缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。</p>
<p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3117417475,1030280178&fm=173&app=49&f=JPEG?w=640&h=421&s=A8C29745DAAC976C5CD9DD0E0000E0C3" alt="img"></p>
<p>代码流程:</p>
<p>参数传入对象主键ID根据key从缓存中获取对象如果对象不为空，直接返回如果对象为空，进行数据库查询如果从数据库查询出的对象不为空，则放入缓存（设定过期时间）想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是一定不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行攻击。</p>
<p>小编在工作中，会采用缓存空值的方式，也就是【代码流程】中第5步，如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。</p>
<p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=779177724,27899716&fm=173&app=49&f=JPEG?w=640&h=379&s=A8C297471EEC856C04F9110F0000E0C2" alt="img"></p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p>
<p>小编在做电商项目的时候，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个<strong>随机因子</strong>。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。</p>
<p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1749289407,1350360731&fm=173&app=49&f=JPEG?w=640&h=311&s=A0C097471EE4956C04580C0B0000F0C1" alt="img"></p>
<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，那么那个时候数据库能顶住压力，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h3><p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>小编在做电商项目的时候，把这货就成为“爆款”。</p>
<p>其实，大多数情况下这种爆款很难对数据库服务器造成压垮性的压力。达到这个级别的公司没有几家的。所以，务实主义的小编，对主打商品都是早早的做好了准备，让缓存永不过期。即便某些商品自己发酵成了爆款，也是直接设为永不过期就好了。</p>
<p>大道至简，mutex key互斥锁真心用不上。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h3><p>在流行的问题面前一定有流行的解决方案，但有时候，也要根据自己的实际情况酌情处理。大胆设计，说不定你的解决方案就会被流行呢？</p>
<p>原文链接：<a href="https://baijiahao.baidu.com/s?id=1619572269435584821&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1619572269435584821&amp;wfr=spider&amp;for=pc</a></p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式锁的正确实现方式（Java版）</title>
    <url>/2019/12/10/RedisLock/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。</p>
<a id="more"></a>

<hr>
<h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ol>
<li><strong>互斥性。</strong>在任意时刻，只有一个客户端能持有锁。</li>
<li><strong>不会发生死锁。</strong>即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li><strong>具有容错性。</strong>只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li>
<li><strong>解铃还须系铃人。</strong>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
</ol>
<hr>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h2><p>首先我们要通过Maven引入<code>Jedis</code>开源组件，在<code>pom.xml</code>文件加入下面的代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="加锁代码"><a href="#加锁代码" class="headerlink" title="加锁代码"></a>加锁代码</h2><h3 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>Talk is cheap, show me the code。先展示代码，再带大家慢慢解释为什么这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：</p>
<ul>
<li>第一个为key，我们使用key来当锁，因为key是唯一的。</li>
<li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件<strong>解铃还须系铃人</strong>，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li>
<li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li>
<li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li>
<li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li>
</ul>
<p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p>
<p>心细的童鞋就会发现了，我们的加锁代码满足我们<strong>可靠性</strong>里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p>
<h3 id="错误示例1"><a href="#错误示例1" class="headerlink" title="错误示例1"></a>错误示例1</h3><p>比较常见的错误示例就是使用<code>jedis.setnx()</code>和<code>jedis.expire()</code>组合实现加锁，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p>
<h3 id="错误示例2"><a href="#错误示例2" class="headerlink" title="错误示例2"></a>错误示例2</h3><p>这一种错误示例就比较难以发现问题，而且实现也比较复杂。实现思路：使用<code>jedis.setnx()</code>命令实现加锁，其中key是锁，value是锁的过期时间。执行过程：1. 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。2. 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">wrongGetLock2</span><span class="params">(Jedis jedis, String lockKey, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> expires = System.currentTimeMillis() + expireTime;</span><br><span class="line">    String expiresStr = String.valueOf(expires);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (jedis.setnx(lockKey, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果锁存在，获取锁的过期时间</span></span><br><span class="line">    String currentValueStr = jedis.get(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">        String oldValueStr = jedis.getSet(lockKey, expiresStr);</span><br><span class="line">        <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">            <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 其他情况，一律返回加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这段代码问题在哪里？1. 由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步。 2. 当锁过期的时候，如果多个客户端同时执行<code>jedis.getSet()</code>方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁。</p>
<h2 id="解锁代码"><a href="#解锁代码" class="headerlink" title="解锁代码"></a>解锁代码</h2><h3 id="正确姿势-1"><a href="#正确姿势-1" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>还是先展示代码，再带大家慢慢解释为什么这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到<code>jedis.eval()</code>方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p>
<p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读<a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#releaseLock-wrongDemo2" target="_blank" rel="noopener">【解锁代码-错误示例2】</a> 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p>
<h3 id="错误示例1-1"><a href="#错误示例1-1" class="headerlink" title="错误示例1"></a>错误示例1</h3><p>最常见的解锁代码就是直接使用<code>jedis.del()</code>方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock1</span><span class="params">(Jedis jedis, String lockKey)</span> </span>&#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="错误示例2-1"><a href="#错误示例2-1" class="headerlink" title="错误示例2"></a>错误示例2</h3><p>这种解锁代码乍一看也是没问题，甚至我之前也差点这样实现，与正确姿势差不多，唯一区别的是分成两条命令去执行，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 判断加锁与解锁是不是同一个客户端</span></span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">        <span class="comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span></span><br><span class="line">        jedis.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码注释，问题在于如果调用<code>jedis.del()</code>方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行<code>jedis.del()</code>之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了如何使用Java代码正确实现Redis分布式锁，对于加锁和解锁也分别给出了两个比较经典的错误示例。其实想要通过Redis实现分布式锁并不难，只要保证能满足可靠性里的四个条件。互联网虽然给我们带来了方便，只要有问题就可以google，然而网上的答案一定是对的吗？其实不然，所以我们更应该时刻保持着质疑精神，多想多验证。</p>
<p>如果你的项目中Redis是多机部署的，那么可以尝试使用<code>Redisson</code>实现分布式锁，这是Redis官方提供的Java组件，链接在<strong><a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#参考阅读" target="_blank" rel="noopener">参考阅读</a></strong>章节已经给出。</p>
<hr>
<h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h1><p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">[1] Distributed locks with Redis</a></p>
<p><a href="https://redis.io/commands/eval" target="_blank" rel="noopener">[2] EVAL command</a></p>
<p><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">[3] Redisson</a></p>
<p>原文链接：<a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#%E5%8F%82%E8%80%83%E9%98%85%E8%AF%BB" target="_blank" rel="noopener">https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#%E5%8F%82%E8%80%83%E9%98%85%E8%AF%BB</a></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2019/11/25/BloomFilter/</url>
    <content><![CDATA[<p>布隆过滤器 (Bloom Filter)是由Burton Howard Bloom于1970年提出，它是一种space efficient的概率型数据结构，用于判断一个元素是否在集合中。在垃圾邮件过滤的黑白名单方法、爬虫(Crawler)的网址判重模块中等等经常被用到。哈希表也能用于判断元素是否在集合中，但是布隆过滤器只需要哈希表的1/8或1/4的空间复杂度就能完成同样的问题。布隆过滤器可以插入元素，但不可以删除已有元素。其中的元素越多，false positive rate(误报率)越大，但是false negative (漏报)是不可能的。</p>
 <a id="more"></a>

<p>本文将详解布隆过滤器的相关算法和参数设计，在此之前希望大家可以先通过谷歌黑板报的<a href="http://www.google.com.hk/ggblog/googlechinablog/2007/07/bloom-filter_7469.html" target="_blank" rel="noopener">数学之美系列二十一 － 布隆过滤器（Bloom Filter）</a>来得到些基础知识。</p>
<p><strong>一. 算法描述</strong></p>
<p>一个empty bloom filter是一个有m bits的bit array，每一个bit位都初始化为0。并且定义有k个不同的hash function，每个都以uniform random distribution将元素hash到m个不同位置中的一个。在下面的介绍中n为元素数，m为布隆过滤器或哈希表的slot数，k为布隆过滤器重hash function数。</p>
<p>为了add一个元素，用k个hash function将它hash得到bloom filter中k个bit位，将这k个bit位置1。</p>
<p>为了query一个元素，即判断它是否在集合中，用k个hash function将它hash得到k个bit位。若这k bits全为1，则此元素在集合中；若其中任一位不为1，则此元素比不在集合中（因为如果在，则在add时已经把对应的k个bits位置为1）。</p>
<p>不允许remove元素，因为那样的话会把相应的k个bits位置为0，而其中很有可能有其他元素对应的位。因此remove会引入false negative，这是绝对不被允许的。</p>
<p>当k很大时，设计k个独立的hash function是不现实并且困难的。对于一个输出范围很大的hash function（例如MD5产生的128 bits数），如果不同bit位的相关性很小，则可把此输出分割为k份。或者可将k个不同的初始值（例如0,1,2, … ,k-1）结合元素，feed给一个hash function从而产生k个不同的数。</p>
<p>当add的元素过多时，即n/m过大时（n是元素数，m是bloom filter的bits数），会导致false positive过高，此时就需要重新组建filter，但这种情况相对少见。</p>
<p><strong>二. 时间和空间上的优势</strong></p>
<p>当可以承受一些误报时，布隆过滤器比其它表示集合的数据结构有着很大的空间优势。例如self-balance BST, tries, hash table或者array, chain，它们中大多数至少都要存储元素本身，对于小整数需要少量的bits，对于字符串则需要任意多的bits（tries是个例外，因为对于有相同prefixes的元素可以共享存储空间）；而chain结构还需要为存储指针付出额外的代价。对于一个有1%误报率和一个最优k值的布隆过滤器来说，无论元素的类型及大小，每个元素只需要9.6 bits来存储。这个优点一部分继承自array的紧凑性，一部分来源于它的概率性。如果你认为1%的误报率太高，那么对每个元素每增加4.8 bits，我们就可将误报率降低为原来的1/10。add和query的时间复杂度都为O(k)，与集合中元素的多少无关，这是其他数据结构都不能完成的。</p>
<p>如果可能元素范围不是很大，并且大多数都在集合中，则使用确定性的bit array远远胜过使用布隆过滤器。因为bit array对于每个可能的元素空间上只需要1 bit，add和query的时间复杂度只有O(1)。注意到这样一个哈希表（bit array）只有在忽略collision并且只存储元素是否在其中的二进制信息时，才会获得空间和时间上的优势，而在此情况下，它就有效地称为了k=1的布隆过滤器。</p>
<p>而当考虑到collision时，对于有m个slot的bit array或者其他哈希表（即k=1的布隆过滤器），如果想要保证1%的误判率，则这个bit array只能存储m/100个元素，因而有大量的空间被浪费，同时也会使得空间复杂度急剧上升，这显然不是space efficient的。解决的方法很简单，使用k&gt;1的布隆过滤器，即k个hash function将每个元素改为对应于k个bits，因为误判度会降低很多，并且如果参数k和m选取得好，一半的m可被置为为1，这充分说明了布隆过滤器的space efficient性。</p>
<p><strong>三. 举例说明</strong></p>
<p>以垃圾邮件过滤中黑白名单为例：现有1亿个email的黑名单，每个都拥有8 bytes的指纹信息，则可能的元素范围为 </p>
<p><img src="../../../../asserts/162318584027.png" alt="img"></p>
<p> ，对于bit array来说是根本不可能的范围，而且元素的数量（即email列表）为 </p>
<p><img src="../../../../asserts/162318585390.png" alt="img"></p>
<p> ，相比于元素范围过于稀疏，而且还没有考虑到哈希表中的collision问题。</p>
<p>若采用哈希表，由于大多数采用open addressing来解决collision，而此时的search时间复杂度为 ：</p>
<p><img src="../../../../asserts/162318595880.png" alt="img"></p>
<p>即若哈希表半满(n/m = 1/2)，则每次search需要probe 2次，因此在保证效率的情况下哈希表的存储效率最好不超过50%。此时每个元素占8 bytes，总空间为：</p>
<p><img src="../../../../asserts/162318599402.png" alt="img"></p>
<p>若采用Perfect hashing（这里可以采用Perfect hashing是因为主要操作是search/query，而并不是add和remove），虽然保证worst-case也只有一次probe，但是空间利用率更低，一般情况下为50%，worst-case时有不到一半的概率为25%。</p>
<p>若采用布隆过滤器，取k=8。因为n为1亿，所以总共需要 </p>
<p><img src="../../../../asserts/216231900208.png" alt="img"></p>
<p> 被置位为1，又因为在保证误判率低且k和m选取合适时，空间利用率为50%（后面会解释），所以总空间为：</p>
<p><img src="../../../../asserts/162319003174.png" alt="img"></p>
<p>所需空间比上述哈希结构小得多，并且误判率在万分之一以下。</p>
<p><strong>四. 误判概率的证明和计算</strong></p>
<p>假设布隆过滤器中的hash function满足simple uniform hashing假设：每个元素都等概率地hash到m个slot中的任何一个，与其它元素被hash到哪个slot无关。若m为bit数，则对某一特定bit位在一个元素由某特定hash function插入时没有被置位为1的概率为：</p>
<p><img src="../../../../asserts/162319014536.png" alt="img"></p>
<p>则k个hash function中没有一个对其置位的概率为：</p>
<p><img src="../../../../asserts/162319024470.png" alt="img"></p>
<p>如果插入了n个元素，但都未将其置位的概率为：</p>
<p><img src="../../../../asserts/162319021057.png" alt="img"></p>
<p>则此位被置位的概率为：</p>
<p><img src="../../../../asserts/162319026007.png" alt="img"></p>
<p>现在考虑query阶段，若对应某个待query元素的k bits全部置位为1，则可判定其在集合中。因此将某元素误判的概率为：</p>
<p><img src="../../../../asserts/162319039321.png" alt="img"></p>
<p>由于 </p>
<p><img src="../../../../asserts/162319043367.png" alt="img"></p>
<p>，并且 </p>
<p><img src="../../../../asserts/162319045809.png" alt="img"></p>
<p> 当m很大时趋近于0，所以</p>
<p><img src="../../../../asserts/162319058775.png" alt="img"></p>
<p>从上式中可以看出，当m增大或n减小时，都会使得误判率减小，这也符合直觉。</p>
<p>现在计算对于给定的m和n，k为何值时可以使得误判率最低。设误判率为k的函数为：</p>
<p><img src="../../../../asserts/162319062089.png" alt="img"></p>
<p>设 </p>
<p><img src="../../../../asserts/162319061466.png" alt="img"></p>
<p> ， 则简化为</p>
<p><img src="../../../../asserts/102162319075.png" alt="img"></p>
<p>，两边取对数</p>
<p><img src="../../../../asserts/162319071367.png" alt="img"></p>
<p> , 两边对k求导</p>
<p><img src="../../../../asserts/162319087921.png" alt="img"></p>
<p>下面求最值</p>
<p><img src="../../../../asserts/162319093395.png" alt="img"></p>
<p><img src="../../../../asserts/162319091169.png" alt="img"></p>
<p><img src="../../../../asserts/162319103296.png" alt="img"></p>
<p><img src="../../../../asserts/162319101070.png" alt="img"></p>
<p><img src="../../../../asserts/162319111004.png" alt="img"></p>
<p><img src="../../../../asserts/162319117591.png" alt="img"></p>
<p><img src="../../../../asserts/162319122541.png" alt="img"></p>
<p><img src="../../../../asserts/162319127492.png" alt="img"></p>
<p><img src="../../../../asserts/162319134918.png" alt="img"></p>
<p><img src="../../../../asserts/162319136280.png" alt="img"></p>
<p><img src="../../../../asserts/162319143182.png" alt="img"></p>
<p><img src="../../../../asserts/162319143673.png" alt="img"></p>
<p><img src="../../../../asserts/162319158067.png" alt="img"></p>
<p><img src="../../../../asserts/162319159637.png" alt="img"></p>
<p><img src="../../../../asserts/162319164554.png" alt="img"></p>
<p>因此，即当 </p>
<p><img src="../../../../asserts/162319171980.png" alt="img"></p>
<p> 时误判率最低，此时误判率为：</p>
<p><img src="../../../../asserts/162319184946.png" alt="img"></p>
<p>可以看出若要使得误判率≤1/2，则：</p>
<p><img src="../../../../asserts/162319181848.png" alt="img"></p>
<p>这说明了若想保持某固定误判率不变，布隆过滤器的bit数m与被add的元素数n应该是线性同步增加的。</p>
<p><strong>五. 设计和应用布隆过滤器的方法</strong></p>
<p>应用时首先要先由用户决定要add的元素数n和希望的误差率P。这也是一个设计完整的布隆过滤器需要用户输入的仅有的两个参数，之后的所有参数将由系统计算，并由此建立布隆过滤器。</p>
<p>系统首先要计算需要的内存大小m bits:</p>
<p><img src="../../../../asserts/162319199274.png" alt="img"></p>
<p>再由m，n得到hash function的个数：</p>
<p><img src="../../../../asserts/162319207779.png" alt="img"></p>
<p>至此系统所需的参数已经备齐，接下来add n个元素至布隆过滤器中，再进行query。</p>
<p>根据公式，当k最优时：</p>
<p><img src="../../../../asserts/162319219076.png" alt="img"></p>
<p><img src="../../../../asserts/162319227515.png" alt="img"></p>
<p>因此可验证当P=1%时，存储每个元素需要9.6 bits：</p>
<p><img src="../../../../asserts/162319233238.png" alt="img"></p>
<p>而每当想将误判率降低为原来的1/10，则存储每个元素需要增加4.8 bits：</p>
<p><img src="../../../../asserts/162319248156.png" alt="img"></p>
<p>这里需要特别注意的是，9.6 bits/element不仅包含了被置为1的k位，还把包含了没有被置为1的一些位数。此时的</p>
<p><img src="../../../../asserts/162319257533.png" alt="img"></p>
<p>才是每个元素对应的为1的bit位数。</p>
<p><img src="../../../../asserts/162319256072.png" alt="img"></p>
<p>  从而使得P(error)最小时，我们注意到：</p>
<p><img src="../../../../asserts/162319266562.png" alt="img"></p>
<p> 中的 </p>
<p><img src="../../../../asserts/162319269877.png" alt="img"></p>
<p> ，即</p>
<p><img src="../../../../asserts/162319272003.png" alt="img"></p>
<p>此概率为某bit位在插入n个元素后未被置位的概率。因此，想保持错误率低，布隆过滤器的空间使用率需为50%。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>《EffectiveJava》（五）</title>
    <url>/2019/11/23/EffectiveJava4/</url>
    <content><![CDATA[<h4 id="【68】executor-和-task-优先于线程"><a href="#【68】executor-和-task-优先于线程" class="headerlink" title="【68】executor 和 task 优先于线程"></a>【68】executor 和 task 优先于线程</h4><p>创建工作队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor()；</span><br><span class="line"></span><br><span class="line">executor.execute(runnable)；<span class="comment">//执行提交一个 runnable 方法</span></span><br><span class="line"></span><br><span class="line">executor.shutdown()；<span class="comment">//优雅地终止</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果编写的是小程序，或者是轻载的服务器，使用 Executors.newCachedThreadPool 通常是个不错的选择，因为它不需要配置，并且在一般的情况下能够正确的完成工作。但在大负载的产品服务其中，最好使用 Executors.newFixedThreadPool，它为你提供了一个包含固定线程数目的线程池，或者为了最大限度地控制它，就直接使用 ThreadPoolExecutor。</p>
<p>ScheduledThradPoolExecutor 是用来代替 java.util.Timer 的东西。timer 只用一个线程来执行任务，这在面对长期运行的任务时，会影响到定时的准确性。如果 timer 唯一的线程抛出未被捕获的异常，timer 就会停止执行。被调度的线程池 executor 支持多个线程，并优雅地从抛出未受检异常的任务中恢复。</p>
<h4 id="【69】并发工具优先于-wait-和-notify"><a href="#【69】并发工具优先于-wait-和-notify" class="headerlink" title="【69】并发工具优先于 wait 和 notify"></a>【69】并发工具优先于 wait 和 notify</h4><p>在并发情境中，除非不得以，否则应该优先使用 ConcurrentHashMap，而不是使用 Collection.-synchronizedMap 或者 Hashtable。只要用并发 Map 替换老式的同步 Map，就可以极大的提升并发应用程序的性能。更一般地，应该优先使用并发集合，而不是使用外部同步集合。</p>
<p>同步器是一些使线程能够等待另一个线程的对象，允许他们协调动作。最常用的同步器是 Count-DownLatch 和 Semaphore，较不常用的是 CyclicBarrier 和 Exchanger。</p>
<p>倒计数锁存器（CountDownLatch）是一次性的障碍，允许一个或者多个线程等待一个或者其它线程来做某些事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentTimer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConcurrentTimer</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">// Noninstantiable</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">time</span><span class="params">(Executor executor, <span class="keyword">int</span> concurrency,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Runnable action)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch ready = <span class="keyword">new</span> CountDownLatch(concurrency);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch done = <span class="keyword">new</span> CountDownLatch(concurrency);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; concurrency; i++) &#123;</span><br><span class="line"></span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    ready.countDown(); <span class="comment">// Tell timer we're ready</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        start.await(); <span class="comment">// Wait till peers are ready</span></span><br><span class="line"></span><br><span class="line">                        action.run();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                        done.countDown();  <span class="comment">// Tell timer we're done</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ready.await();     <span class="comment">// Wait for all workers to be ready</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startNanos = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        start.countDown(); <span class="comment">// And they're off!</span></span><br><span class="line"></span><br><span class="line">        done.await();      <span class="comment">// Wait for all workers to finish</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - startNanos;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于间歇式的定时，始终应该优先使用 System.nanoTime，而不是使用 System.currentTime-Mills。System.nanoTime 更加准确也更加精确，它不受系统的实时时钟的调整所影响。</p>
<p>使用 wait 方法的标准模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (&lt;condition does not hold&gt;) &#123;</span><br><span class="line"></span><br><span class="line">		obj.wait()；<span class="comment">// (Release lock，and reacquires on wakeup)</span></span><br><span class="line"></span><br><span class="line">		... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，直接使用 wait 和 notify 就像用 “并发汇编语言” 进行编程一样，而 java.util.concurr-ent则提供了更高级的语言。没有理由在新代码中使用 wait 和 notify，即使有，也是极少的。如果你在维护使用 wait 和 notify 的代码，务必确保始终是利用标准的模式从 while 循环的内部调用 wait。一般情况下，你应该优先使用 notifyAll，而不是使用 notify。如果使用 notify，请一定要小心，以确保程序的活性。</p>
<h4 id="【70】线程安全性的文档化"><a href="#【70】线程安全性的文档化" class="headerlink" title="【70】线程安全性的文档化"></a>【70】线程安全性的文档化</h4><p>线程安全性的级别：</p>
<p>1.不可变的（immutable）——这个类的实力是不可变的。所以不需要外部的同步。这样的例子包括 String、Long 和 BigInteger。</p>
<p>2.无条件的线程安全（unconditionally thread-safe）——这个类的实例是可变的，但是这个类有着足够的内部同步，所以它的实例可以被并发使用而无需任何外部同步。其例子包括 Random 和 Co-ncurrentHashMap。</p>
<p>3.有条件的线程安全（conditionally thread-safe）——除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件线程安全相同。这样的例子包括 Collection.synchroni-zed 包装返回的集合，它的迭代器要求外部同步。</p>
<p>4.非线程安全（not thread-safe）——这个类的实例是可变的。为了并发的使用他们，客户必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如 ArrayList 和 HashMap。</p>
<p>5.线程对立的（thread-hostile）——这个类不能安全的被多个线程并发使用，即使所有的方法调用都被外部同步包围。在 Java 平台类库中，线程对立的类或者方法非常少。System.runFinalizers-OnExit 方法是线程对立的，但已经被废除了。</p>
<p>私有锁对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object()；</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>私有锁对象不能被这个类的客户端程序所访问，所以它们不可能妨碍对象的同步。</p>
<p>简而言之，每个类都应该利用详细的说明或者线程安全注解，清楚地在文档中说明它的线程安全属性。synchronized 修饰符与这个文档毫无关系。有条件的线程安全类必须在文档中指明“哪个方法调用序列需要外部同步，以及在执行这些序列的时候要获得哪把锁”。如果你编写的是无条件的线程安全类，就应该考虑使用私有的锁对象来代替同步的方法。这样可以防止客户端程序和子类的不同步干扰，让你能够在后续的版本中灵活地对并发控制采用更加复杂的方法。</p>
<h4 id="【71】慎用延迟初始化"><a href="#【71】慎用延迟初始化" class="headerlink" title="【71】慎用延迟初始化"></a>【71】慎用延迟初始化</h4><p>延迟初始化（lazy initialization）是延迟到需要的域的值时才将它初始化的这种行为。在大多数情况下，正常的初始化要优先于延迟初始化。</p>
<p>正常初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FieldType field = computeFieldValue()；</span><br></pre></td></tr></table></figure>

<p>利用延迟优化来破坏初始化的循环，就要使用同步访问方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> FieldType field；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (field == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">		field = computeFieldValue()；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> field；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果出于性能的考虑而需要对<strong>静态域</strong>使用延迟初始化，就使用 <strong>lazy initialization holder class</strong> 模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue()；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> **FieldHolder.field**；&#125;</span><br></pre></td></tr></table></figure>

<p>如果出于性能的考虑而需要对<strong>实例域</strong>使用延迟初始化，就使用双重检查模式（double check idiom）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field；</span><br><span class="line"></span><br><span class="line"><span class="function">FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	FieldType result = field；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;	<span class="comment">// First check (no locking)</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">			result = field；</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;	<span class="comment">// Second check (with locking)</span></span><br><span class="line"></span><br><span class="line">				field = result = computeFieldValue()；</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要延迟初始化一个<strong>可以接受重复初始化的实例域</strong>，就可以使用单重检查模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field；</span><br><span class="line"></span><br><span class="line"><span class="function">FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	FieldType result = field；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;	<span class="comment">// single check </span></span><br><span class="line"></span><br><span class="line">		field = result = computeFieldValue()；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，大多数的域应该正常的进行初始化，而不是延迟初始化。如果为了达到性能目标，或者为了破坏有害的初始化循环，而必须延迟初始化一个域，就可以使用相应的延迟初始化方法。对于实例域，就使用双重检查模式；对于静态域，则使用 lazy initialization holder class idiom。对于可以接受重复初始化的实例域，也可以考虑单重检查模式。</p>
<h4 id="【72】不要依赖于线程调度器"><a href="#【72】不要依赖于线程调度器" class="headerlink" title="【72】不要依赖于线程调度器"></a>【72】不要依赖于线程调度器</h4><p>任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的。要编写健壮的、可移植的多线程应用程序，最好的办法是确保可运行线程的平均数量不明显多于处理器的数量。保持可运行线程数量尽可能少的主要方法是，让每个线程做些有意义的工作，然后等待更多有意义的工作。如果线程没有在做有意义的工作，就不应该运行。</p>
<p>对于大多数程序员来说，Thread.yield 的唯一用途是在测试期间人为地增加程序的并发性。但是它从来不能保证一定可行。因此，应该使用 Thread.sleep(1) 代替 Thread.yield 来进行并发测试。</p>
<p>简而言之，不要让应用程序的正确性依赖于线程调度器。否则结果得到的应用程序将既不健壮，也不具有可移植性。作为推论，不要依赖于 Thread.yield 或者线程优先级。这些设施仅仅对调度器做些暗示。<strong>线程优先级可以用来提高一个已经能够正常工作的程序的服务质量，但永远不应该用来“修正”一个原本不能工作的程序。</strong></p>
<h4 id="【73】避免使用线程组"><a href="#【73】避免使用线程组" class="headerlink" title="【73】避免使用线程组"></a>【73】避免使用线程组</h4><p>我们最好把线程组看作是一个不成功的试验，你可以忽略它们，就当它们更笨不存在一样。</p>
<p><strong>十二、序列化：</strong></p>
<h4 id="【74】谨慎地实现-Serializable-接口"><a href="#【74】谨慎地实现-Serializable-接口" class="headerlink" title="【74】谨慎地实现 Serializable 接口"></a>【74】谨慎地实现 Serializable 接口</h4><p>对象序列化提供了一个框架，用来将对象编码成字节流，并从字节流编码中重新构建对象。对象被序列化后，它的编码就可以从一台正在运行的虚拟机被传递到另一台虚拟机上，或者被存储到磁盘上。实现序列化的代价有：</p>
<p>(1)实现 Serializable 接口而付出最大的代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。</p>
<p>序列化会使类的演变受到限制，这种限制的一个例子与流的唯一标识符有关，通常也被称为序列版本 UID。如果没有现实的指定这个 UID，系统会自动生成该标识号，它的值与类的各个部分都有着复杂的关系，如果类改变，这个 UID 也会跟着改变，结果就会出现兼容性问题。</p>
<p>(2)第二个代价是，它增加了出现 BUG 和安全漏洞的可能性。</p>
<p>(3)第三个代价是，随着类发行新的版本，相关的测试负担也增加了。</p>
<p>根据经验，比如 Date 和 BigInteger 这样的值应该实现 Serializable，大多数的集合类也应该如此。代表活动的实体类，比如线程池，一般不应该实现 Serializable。</p>
<p>为了继承而设计的类应该尽可能地少地去实现 Serializable 接口，用户的接口也应该尽可能少的继承 Serializable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFoo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;  <span class="comment">// Our state</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This enum and field are used to track initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> State &#123; NEW, INITIALIZING, INITIALIZED &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;State&gt; init =</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> AtomicReference&lt;State&gt;(State.NEW);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractFoo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; initialize(x, y); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This constructor and the following method allow</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// subclass's readObject method to initialize our state.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractFoo</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!init.compareAndSet(State.NEW, State.INITIALIZING))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"></span><br><span class="line">                <span class="string">"Already initialized"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do anything else the original constructor did</span></span><br><span class="line"></span><br><span class="line">        init.set(State.INITIALIZED);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// These methods provide access to internal state so it can</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// be manually serialized by subclass's writeObject method.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; checkInit(); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; checkInit(); <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Must call from all public and protected instance methods</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (init.get() != State.INITIALIZED)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Uninitialized"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remainder omitted</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>checkInit</strong> 方法在其它方法工作之前调用，用来保证子类初始化之前调用相关方法就可以快速而干净地失败。</p>
<h4 id="【75】考虑使用自定义的序列化形式"><a href="#【75】考虑使用自定义的序列化形式" class="headerlink" title="【75】考虑使用自定义的序列化形式"></a>【75】考虑使用自定义的序列化形式</h4><p>一般来讲，只有当你自行设计的自定义序列化形式与默认的序列化形式基本相同时，才能接受默认的序列化形式。</p>
<p>对于一个对象来说，理想的序列化形式应该只包含该对象所表示的逻辑数据，而逻辑数据与物理表示法应该是各自独立的。如果一个对象物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式（POJO类？）。</p>
<p>即使你确定了默认的序列化形式是合适的，通常还必须提供一个 readObject 方法以保证约束关系和安全性。</p>
<p><strong>transient</strong> 修饰符表明这个实例域将从一个类的默认序列化形式中省略掉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringList with a reasonable custom serialized form</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No longer Serializable!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String data;</span><br><span class="line"></span><br><span class="line">        Entry  next;</span><br><span class="line"></span><br><span class="line">        Entry  previous;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Appends the specified string to the list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Implementation omitted</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * Serialize this &#123;<span class="doctag">@code</span> StringList&#125; instance.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The size of the list (the number of strings</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * it contains) is emitted (&#123;<span class="doctag">@code</span> int&#125;), followed by all of</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * its elements (each a &#123;<span class="doctag">@code</span> String&#125;), in the proper</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * sequence.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = head; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line"></span><br><span class="line">            s.writeObject(e.data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numElements = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements and insert them in list</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++)</span><br><span class="line"></span><br><span class="line">            add((String) s.readObject());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">93248094385L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remainder omitted</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管 StringList 的所有域都是瞬时的（transient），但 writeObject 方法的首要任务仍是调用 de-faultWriteObject，readObject 方法的首要任务仍是调用 defaultReadObject。如果所有的域都是瞬时的，从技术角度而言，不调用 <strong>defaultWriteObject</strong> 和 <strong>defaultReadObject</strong> 也是允许的，但是不推荐这样做。</p>
<p>不管你选择了那种序列化形式，都要为自己编写的每个可序列化的类声明一个显示的序列版本<strong>UID。</strong>这样可以避免序列版本UID成为潜在的不兼容根源。</p>
<p><strong>private static final long serialVersionUID = randomLongValue；</strong></p>
<h4 id="【76】保护性地编写-readObject-方法"><a href="#【76】保护性地编写-readObject-方法" class="headerlink" title="【76】保护性地编写 readObject 方法"></a>【76】保护性地编写 readObject 方法</h4><p>readObject 方法实际上相当于另一个公有的构造器，如同其它的构造器一样，它也要求注意同样的所有注意事项。构造器必须检查其参数的有效性，并且在必要的时候对参数进行保护性拷贝，同样的，readObject 方法也需要这样做。</p>
<p>readObject 方法可以首先调用 defaultReadObject，然后检查被反序列化之后的对象有效性。如果有效性检测失败，readObject 方法就抛出一个 InvalidObjectException 异常，是反序列化过程不能成功完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readObject method with validity checking</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">	s.defaultReadObject()；</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that our invariants are satisfied</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start.compareTo(end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> **InvalidObjectException**(start + <span class="string">" after "</span> + end)；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写更加健壮的 readObject 方法的指导方针：</p>
<ul>
<li>对于对象引用域必须保持为私有的类，要保护性地拷贝这些域中的每个对象。不可变类的可变组件就属于这一类。</li>
<li>对于任何约束条件，如果检查失败，则抛出一个 <strong>InvalidObjectException</strong> 异常。这些检查动作应该跟在所有的保护性拷贝之后。</li>
<li>如果整个对象图在被反序列化之后必须进行验证，就应该使用 ObjectInputValidation 接口。</li>
<li>无论直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li>
</ul>
<h4 id="【77】对于实例控制，枚举类型优先于-readResolve"><a href="#【77】对于实例控制，枚举类型优先于-readResolve" class="headerlink" title="【77】对于实例控制，枚举类型优先于 readResolve"></a>【77】对于实例控制，枚举类型优先于 readResolve</h4><p>readResolve 特性允许你用 readObject 创建的实例代替另一个实例。对于一个正在被反实例化的对象，如果它的类定义了一个 readResolve 方法，并且具备正确的声明，那么在反序列化之后，新建对象上的 readResolve 方法就会被调用。然后，该方法返回的对象引用将被返回，取代新建的对象。</p>
<p><strong>readResolve</strong> 的可访问性很重要。如果把 readResolve 方法放在一个 final 类上，它就应该是私有的。如果把 readResolve 方法放在一个非 final 对象上，就必须认真考虑它的可访问性。</p>
<p>总而言之，你应该尽可能地使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控的类，就必须提供一个 readResolve 方法，并确保该类的所有实例域都为基本类型，或者是 transient 的。</p>
<h4 id="【78】考虑用序列化代理代替序列化实例"><a href="#【78】考虑用序列化代理代替序列化实例" class="headerlink" title="【78】考虑用序列化代理代替序列化实例"></a>【78】考虑用序列化代理代替序列化实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  start the beginning of the period</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  end the end of the period; must not precede start</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if start is after end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if start or end is null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.end   = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line"></span><br><span class="line">                          start + <span class="string">" after "</span> + end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">start</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">end</span> <span class="params">()</span>   </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Date(end.getTime()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start + <span class="string">" - "</span> + end; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serialization proxy for Period class </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line"></span><br><span class="line">        SerializationProxy(Period p) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.start = p.start;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.end = p.end;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = </span><br><span class="line"></span><br><span class="line">            <span class="number">234098243823485285L</span>; <span class="comment">// Any number will do (Item 75)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// readResolve method for Period.SerializationProxy </span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Period(start, end);  <span class="comment">// Uses public constructor</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writeReplace method for the serialization proxy pattern </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SerializationProxy(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// readObject method for the serialization proxy pattern </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InvalidObjectException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Proxy required"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总而言之，每当你发现自己必须在一个不能被客户端扩展的类上编写 readObject 或者 write-Object 方法的时候，就应该考虑使用序列化代理模式。要想稳健地将带有重要约束条件的对象序列化时，这种模式可能是最容易的方法。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>《EffectiveJava》（四）</title>
    <url>/2019/11/23/EffectiveJava3/</url>
    <content><![CDATA[<h4 id="【47】了解和使用库"><a href="#【47】了解和使用库" class="headerlink" title="【47】了解和使用库"></a>【47】了解和使用库</h4><p>不要重复发明轮子。一般而言，类库的代码可能比你自己编写的代码更好一些，并且会随着时间的推移不断改进。从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能够给予的投入。</p>
<p>强烈需要了解的类库：</p>
<p><strong>java.lang</strong></p>
<p><strong>java.util</strong></p>
<p><strong>java.io</strong></p>
<a id="more"></a>

<p>特别推荐：</p>
<p><strong>java.util.Collections</strong></p>
<p><strong>java.util.concurrent</strong></p>
<h4 id="【48】如果需要精确的答案，请避免使用-float-和-double"><a href="#【48】如果需要精确的答案，请避免使用-float-和-double" class="headerlink" title="【48】如果需要精确的答案，请避免使用 float 和 double"></a>【48】如果需要精确的答案，请避免使用 float 和 double</h4><p>float 和 double 类型主要是为了科学计算和工程计算而设计的。它们执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。要让一个 float 或者 double 精确地表示 0.1（或任何10的任何其它负数次方值）是不可能的。</p>
<p>如果想让系统来记录十进制小数点，并且不介意因为不使用基本类型而带来的不便，就请使用BigDecimal(数值超过18位数字则必须使用它)，它允许你完全控制舍入。另外对于小数值也可以使用int 或者 long。以下为一个使用 BigDecimal 的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> BigDecimal TEN_CENTS = <span class="keyword">new</span> BigDecimal(“.<span class="number">10</span>”)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> itemsBought = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">BigDecimal funds = <span class="keyword">new</span> BigDecimal(“<span class="number">1.00</span>”)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (BigDecimal price = TEN_CENTS；funds.compareTo(price) &gt;= <span class="number">0</span>；price = 	</span><br><span class="line"></span><br><span class="line">	price.add(TEN_CENTS)) &#123;</span><br><span class="line"></span><br><span class="line">	itemsBought ++；</span><br><span class="line"></span><br><span class="line">	funds = funds.subtract(price)；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(itemsBought + <span class="string">"items bought."</span>)；</span><br><span class="line"></span><br><span class="line">System.out.println(“Money left over：$” + funds)；</span><br></pre></td></tr></table></figure>

<h4 id="【49】基本类型优先于装箱基本类型"><a href="#【49】基本类型优先于装箱基本类型" class="headerlink" title="【49】基本类型优先于装箱基本类型"></a>【49】基本类型优先于装箱基本类型</h4><p>Java有一个类型系统由两部分组成，包含基本类型，如 int、double、boolean，和引用类型，如 String 和 List。每个基本类型都有一个对应的引用类型，称作装箱基本类型。如：</p>
<p>int —&gt; Integer，double —&gt; Double，boolean —&gt; Boolean</p>
<p>基本类型和装箱基本类型之间的三个主要区别：</p>
<p>&lt;1&gt;基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。换句话说，两个装箱基本类型可以具有相同的值和不同的同一性。</p>
<p>&lt;2&gt;基本类型只有功能完备的值，而每个装箱基本类型还有一个非功能值：null。</p>
<p>&lt;3&gt;基本类型通常比装箱基本类型更节约时间和空间。</p>
<p>当程序用 <strong>==</strong> 操作符比较两个装箱基本类型时，它做了一个同一性比较，这几乎肯定不是你所希望的。当程序进行涉及装箱和拆箱基本类型混合类型计算时，它会进行拆箱，会抛出 NullPointer-Exception 异常。最后，当程序装箱了基本类型时，会导致高开销和不必要的对象创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">42</span>)；</span><br><span class="line"></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">42</span>)；</span><br><span class="line"></span><br><span class="line">Interger f；</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == j)		<span class="comment">//返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f == <span class="number">42</span>)	<span class="comment">//抛出 NullPointerException，因为 f 初始值为 null</span></span><br></pre></td></tr></table></figure>

<h4 id="【50】如果其它类型更合适，则尽量避免使用字符串"><a href="#【50】如果其它类型更合适，则尽量避免使用字符串" class="headerlink" title="【50】如果其它类型更合适，则尽量避免使用字符串"></a>【50】如果其它类型更合适，则尽量避免使用字符串</h4><p>字符串不适合代替其它的值类型。比如说表达数值的字符串应该转化为适当的数值类型，比如说int、float、BigInteger。如果它是一个“是—或—否”这种问题的答案，就应该转变为 boolean 类型。</p>
<p>字符串不适合代替枚举类型。枚举类型比字符串更加适合用来表示枚举的常量。</p>
<p>字符串不适合代替聚集类型。如果一个实体有多个组件，用一个字符串来表示这个实体通常是很不恰当的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String compoundKey = className + <span class="string">"#"</span> + i.next()；</span><br></pre></td></tr></table></figure>

<p>如果分隔符出现在某个域中，结果会出现混乱。使用时也需要解析字符串得到三个单独的域，造成性能损失。更好的做法是，简单地编写一个类来描述这个数据集，通常是一个私有的静态成员类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompoundKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String className：</span><br><span class="line"></span><br><span class="line">	String seperator；</span><br><span class="line"></span><br><span class="line">	String add；</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【51】当心字符串连接的性能"><a href="#【51】当心字符串连接的性能" class="headerlink" title="【51】当心字符串连接的性能"></a>【51】当心字符串连接的性能</h4><p>为连接 n 个字符串而重复地使用字符串连接操作符，需要 n 的平方级的时间。这是由于字符串不可变而导致的不幸结果。当两个字符串被连接在一起时，它们的内容都要被拷贝。</p>
<p>不要使用字符串连接操作符（+）来合并多个字符串，除非性能无关紧要。相反，应该使用 Strin-gBuilder 的 append 方法。另一种方法是，使用字符数组，或者每次只处理一个字符串，而不是将它们组合起来。</p>
<h4 id="【52】通过接口引用对象"><a href="#【52】通过接口引用对象" class="headerlink" title="【52】通过接口引用对象"></a>【52】通过接口引用对象</h4><p>应该使用接口而不是用类作为参数的类型。更一般的讲，应该优先使用接口而不是类来引用对象。如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当你利用构造器创建某个对象的时候，才需要真正引用这个对象的类。</p>
<p>例外情况：</p>
<p>（1）如果没有合适的接口类型存在，完全可以用类而不是接口来引用对象。</p>
<p>（2）对象属于一个框架，而框架的基本类型是类。</p>
<p>（3）类实现了接口，但是它提供了接口中不存在的额外方法。</p>
<h4 id="【53】接口优先于反射机制"><a href="#【53】接口优先于反射机制" class="headerlink" title="【53】接口优先于反射机制"></a>【53】接口优先于反射机制</h4><p>待添加。。。</p>
<h4 id="【54】谨慎地使用本地方法"><a href="#【54】谨慎地使用本地方法" class="headerlink" title="【54】谨慎地使用本地方法"></a>【54】谨慎地使用本地方法</h4><p>在使用本地方法之前务必三思。极少数情况下会需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层的资源或者遗留代码库，也要尽可能少用本地代码，并且要全面进行测试。本地代码的一个 BUG 就有可能破坏整个应用程序。</p>
<h4 id="【55】谨慎地进行优化"><a href="#【55】谨慎地进行优化" class="headerlink" title="【55】谨慎地进行优化"></a>【55】谨慎地进行优化</h4><p>三条与优化有关的格言：</p>
<p>1.很多计算机上的过失都被归咎于效率（没必要达到的效率），而不是任何其他原因——甚至盲目的做傻事。</p>
<p>2.不要去计较效率上的一些小小的得失，在 %97 的情况下，不成熟的优化才是一切问题的根源。</p>
<p>3.1不要进行优化。</p>
<p>3.2（仅针对专家）：还是不要进行优化——也就是说，在你还没有绝对清晰的优化方案之前，请不要进行优化。</p>
<p>总而言之，不要费力去编写快速的程序——应该努力编写好的程序，速度自然会随之而来。在设计系统的时候，特别是在设计 API 、线路层协议和永久数据格式的时候，一定要考虑性能的因素。当构建完系统之后，要测量它的性能。如果它够快，你的任务就完成了。如果不够快，则可以在性能剖析器的帮助下，找到问题的根源，然后设法优化系统中相关的部分。第一个步骤是检查所选择的算法：再多的底层优化也无法弥补算法的选择不当。必要时重复这个过程，在每次改变之后都要测量性能，直到满意为止。</p>
<h4 id="【56】遵守普遍接受的命名惯例"><a href="#【56】遵守普遍接受的命名惯例" class="headerlink" title="【56】遵守普遍接受的命名惯例"></a>【56】遵守普遍接受的命名惯例</h4><p>把标准的命名惯例当做一种内在的机制来看待，并且学着用它们作为第二特征。字面惯例是非常直接和明确的；语法惯例则更加复杂和松散。“如果长期养成的习惯用法与此不同，请不要盲目遵从这些命名惯例。”请运用常识。</p>
<h2 id="十、异常："><a href="#十、异常：" class="headerlink" title="十、异常："></a><strong>十、异常：</strong></h2><h4 id="【57】只针对异常的情况才使用异常"><a href="#【57】只针对异常的情况才使用异常" class="headerlink" title="【57】只针对异常的情况才使用异常"></a>【57】只针对异常的情况才使用异常</h4><p>设计良好的 API 不应该强迫它的客户端为了正常的控制流而使用异常。如果类具有“状态相关”的方法，即只有在特定的不可预知的条件下才可以被调用的方法，这个类往往也应该有个单独的“状态测试”方法，即指示是否可以调用这个状态相关的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> （Iterator&lt;Foo&gt; i = collection.iterator；i.hasNext；）&#123; <span class="comment">//状态测试方法“hasNext()”</span></span><br><span class="line"></span><br><span class="line">	Foo foo = i.next()；<span class="comment">//状态相关方法“next()”</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种提供单独的状态测试方法的做法是，如果“状态相关”的方法被调用时，该对象处于不适当的状态之中，他就会返回一个可识别的值，比如 null，但这种方法对于 Iterator 而言并不合适，因为Null 是 next 方法的合法返回值。</p>
<h4 id="【58】对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#【58】对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="【58】对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>【58】对可恢复的情况使用受检异常，对编程错误使用运行时异常</h4><p>Java 程序设计语言提供了三种可抛出结构：受检的异常、运行时异常和错误。</p>
<p>在决定使用受检异常或是未受检异常时，主要的原则是：如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常。通过抛出受检的异常，强迫调用者在一个 catch 子句中处理该异常或者将它传播出去。</p>
<p>因为受检的异常往往指明了可恢复的条件，所以对于这样的异常，提供一些辅助方法尤其重要，通过这些方法，调用者可以获取一些有助于恢复的信息。例如，假设因为用户没有存储足够的钱，他企图在一个收费电话上呼叫就会失败，于是抛出受检异常。这个异常应该提供一个访问方法，以便允许客户查询所缺的费用金额，从而将这个数值传递给电话用户。</p>
<h4 id="【59】避免不必要的使用受检的异常"><a href="#【59】避免不必要的使用受检的异常" class="headerlink" title="【59】避免不必要的使用受检的异常"></a>【59】避免不必要的使用受检的异常</h4><p>在异常处理的时候，都会接触到受检异常（checked exception）和非受检异常（unchecked-exception）这两种异常类型。非受检异常指的是java.lang.RuntimeException和java.lang.Error类及其子类，所有其他的异常类都称为受检异常。两种类型的异常在作用上并没有差别，唯一的差别就在于使用受检异常时的合法性要在编译时刻由编译器来检查。正因为如此，受检异常在使用的时候需要比非受检异常更多的代码来避免编译错误。</p>
<p>“把受检异常变成未受检异常”的一种方法是，把这个抛出异常的方法分成两个方法，其中第一个方法是，其中第一个方法返回一个 boolean，表明是否应该抛出异常。这种 API 重构，把下面的调用序列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">	obj.action()；</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (TheCheckedException e) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Handle exceptional condition</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj.actionPermitted(args)) &#123;</span><br><span class="line"></span><br><span class="line">	obj.action(args)；</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Handle exceptional condition</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【60】优先使用标准的异常"><a href="#【60】优先使用标准的异常" class="headerlink" title="【60】优先使用标准的异常"></a>【60】优先使用标准的异常</h4><p><img src="D:/MarkDown/asserts/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170925104852.png" alt="img"></p>
<h4 id="【61】抛出与抽象相对应的异常"><a href="#【61】抛出与抽象相对应的异常" class="headerlink" title="【61】抛出与抽象相对应的异常"></a>【61】抛出与抽象相对应的异常</h4><p>如果方法抛出的异常与它所执行的任务没有明显的联系，这种情形将会使人不知所措。当方法传递由低层抽象抛出的异常时，往往会发生这种情况。</p>
<p>为了避免这个问题，更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法被称为异常转译（exception translation），如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use lower-level abstraction to do our bidding</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException e) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(...)；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种特殊的异常转译形式称为异常链，如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。低层的异常（原因）被传到高层的异常，高层的异常提供访问方法来获得低层的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use lower-level abstraction to do our bidding</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (LowerLevelException cause) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(cause)；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高层异常的构造器将原因传到支持连的超级构造器，因此它最终将被传给 Throwable 的其中一个运行异常链的构造器，例如 Throwable(Throwable)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighLevelException</span>(<span class="title">Throwable</span> <span class="title">cause</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	HigherLevelException(Throwable cause) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">super</span>(cause)；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总而言之，如果不能阻止或处理来自更低层的异常，一般的做法是使用异常转译，除非低层方法碰巧可以保证它抛出的所有异常对高层也合适才可以将异常从低层传播到高层。异常链对高层和低层异常都提供了最佳的功能：它允许抛出适当的高层异常，同时又能捕获底层的原因进行失败分析。</p>
<h4 id="【62】每个方法抛出的异常都要有文档"><a href="#【62】每个方法抛出的异常都要有文档" class="headerlink" title="【62】每个方法抛出的异常都要有文档"></a>【62】每个方法抛出的异常都要有文档</h4><p>始终要单独地声明受检的异常，并且利用Javadoc的@throws标记，准确的记录下抛出每个异常的条件。</p>
<p>总而言之，要为你编写的每个方法所能抛出的每个异常建立文档。对于受检异常和非受检异常，以及对于抽象的和具体的方法也都一样。要为每个受检异常提供单独的 throws 子句，不要为未受检异常提供 throws 子句。</p>
<h4 id="【63】在细节消息中包含能捕获失败的信息"><a href="#【63】在细节消息中包含能捕获失败的信息" class="headerlink" title="【63】在细节消息中包含能捕获失败的信息"></a>【63】在细节消息中包含能捕获失败的信息</h4><p>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。为了确保在异常的细节消息中包含足够的能够捕获失败的信息，一种办法是在异常的构造器而不是字符串细节消息中引入这些信息。然后，有了这些信息，只要把他们放到消息描述中，就可以自动产生细节消息。例如，IndexOutOfBoundsException 并不是有个 String 构造器，而是有个这样的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> IndexOutOfBoundsException（<span class="keyword">int</span> lowerBound，<span class="keyword">int</span> upperBound，<span class="keyword">int</span> index）&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">super</span>(<span class="string">"Lower bound："</span> + lowerBound + “，Upper bound：” + upperBound + <span class="string">"，  </span></span><br><span class="line"><span class="string">          Index："</span> + index)；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.lowerBound = lowerBound；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.upperBound = upperBound；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.index = index；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为异常的“失败捕获”信息（在上例中的 lowerBound、upperBound 和 index 方法）提供一些访问方法是合适的。提供这样的访问方法对于受检的异常，比对于未受检的异常更为重要，因为失败——捕获信息对于从失败中恢复是非常有用的。</p>
<h4 id="【64】努力使失败保持原子性"><a href="#【64】努力使失败保持原子性" class="headerlink" title="【64】努力使失败保持原子性"></a>【64】努力使失败保持原子性</h4><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法被称为具有失败原子性。</p>
<p>实现这种效果的途径：</p>
<p>1.设计一个不可变的对象。如果对象是不可变的，失败原子性就是显然的。</p>
<p>2.对于在可变对象上执行操作的方法：</p>
<p>2.1在执行操作之前检查参数的有效性。</p>
<p>2.2调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。</p>
<p>2.3编写一段恢复代码，由它来拦截操作过程中发生的失败，以及使对象回滚到操作开始之前的状态上。这种办法主要用于永久性的数据结构。（例如数据库的回滚）</p>
<p>2.4在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。</p>
<h4 id="【65】不要忽略异常"><a href="#【65】不要忽略异常" class="headerlink" title="【65】不要忽略异常"></a>【65】不要忽略异常</h4><p>空的 catch 块会使异常达不到应有的目的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SomeException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管异常代表了可预见的异常条件，还是编程错误，用空的 catch 块忽略它，将会导致程序在遇到错误的情况下悄然地执行下去。而会在将来的某个点上突然失败。</p>
<h2 id="十一、并发："><a href="#十一、并发：" class="headerlink" title="十一、并发："></a><strong>十一、并发：</strong></h2><h4 id="【66】同步访问共享的可变数据"><a href="#【66】同步访问共享的可变数据" class="headerlink" title="【66】同步访问共享的可变数据"></a>【66】同步访问共享的可变数据</h4><p>读取一个<strong>非 long 或 double 类型</strong>的变量，可以保证返回的值是某个线程保存在改变量中的，即使多个线程在没有同步的情况下并发地修改这个变量也是如此。</p>
<p>为了在线程之间进行可靠的通信，也是为了互斥访问，同步是必要的。</p>
<p>要阻止一个线程妨碍另一个线程，建议的做法是让第一个线程轮询一个 boolean 域，这个域一开始为 false ，但是可以通过第二个线程设置为 true ，表示第一个线程将中止自己。由于 boolean 域的读和写操作都是原子的，程序员在访问这个域的时候不再使用同步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested；<span class="comment">//boolean域</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Thread backgroundThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">int</span> i = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (!stopRequested) &#123;</span><br><span class="line"></span><br><span class="line">					i ++；</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;)；</span><br><span class="line"></span><br><span class="line">		backgroundThread.start()；</span><br><span class="line"></span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>)；</span><br><span class="line"></span><br><span class="line">		stopRequested = <span class="keyword">true</span>；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于没有同步，就不能保证后台线程何时“看到”主线程对 stopRequested 的值所做的改变。因此上述代码永远不会终止，修正的一种方法是同步访问 stopRequested 域：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequested；<span class="comment">//boolean域</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">requestStop</span><span class="params">()</span> </span>&#123; <span class="comment">//同步写操作</span></span><br><span class="line"></span><br><span class="line">		stopRequested = <span class="keyword">true</span>；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">stopRequested</span><span class="params">()</span> </span>&#123; <span class="comment">//同步读操作</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> stopRequested；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Thread backgroundThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">int</span> i = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (**!stopRequested()**) &#123;</span><br><span class="line"></span><br><span class="line">					i ++；</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;)；</span><br><span class="line"></span><br><span class="line">		backgroundThread.start()；</span><br><span class="line"></span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>)；</span><br><span class="line"></span><br><span class="line">		requestStop()；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果读和写操作没有都被同步，同步就不会起作用。上述的 boolean 域的读写操作即使没有同步也是原子的，因此这些方法的同步只是为了它的通信效果（让其它线程立即知道改变），而不是为了互斥访问。起着同样的作用的修饰符是 <strong>volatile</strong>，它虽然不执行互斥访问，但是它可以保证任何一个县城在读取该域的时候都将看到最近刚刚被写入的值，一个需要特别注意的点是，使用 volatile 修饰符的变量进行其它操作时，需要注意此操作的原子性（总之谨慎地使用 volatile）。</p>
<h4 id="【67】避免过度同步"><a href="#【67】避免过度同步" class="headerlink" title="【67】避免过度同步"></a>【67】避免过度同步</h4><p>简而言之，为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法。更为一般地讲，要尽量限制同步区域内部的工作量。当你在设计一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。在现在这个多核的时代，这比永远不要过度同步来得更重要。只有当你有足够的理由一定要在内部同步类的时候，才应该这么做，同时还应该将这个决定清楚地写到文档中。</p>
<p>（暂时还是不能很好地理解，后续再慢慢理解）</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>《EffectiveJava》（三）</title>
    <url>/2019/11/23/EffectiveJava2/</url>
    <content><![CDATA[<h4 id="【27】优先考虑泛型方法"><a href="#【27】优先考虑泛型方法" class="headerlink" title="【27】优先考虑泛型方法"></a>【27】优先考虑泛型方法</h4><p>静态工具方法尤其适合泛型化。如实现构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V，K&gt; HashMap&lt;V，K&gt; newHashMap() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K，V&gt;()；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>调用 Map&lt;String，List<String>&gt; anagrams = newHashMap() 来实现 anagrams 的生成。</p>
<p>对于 public static &lt;T extends Comparable<T>&gt; T max(List<T> list) {…}；类型限制&lt;T extends Comparable<T>&gt;，可以读作 “ 针对可以与自身进行比较的每个类型 T “，这与互比性的概念或多或少有些一致。</p>
<h4 id="【28】利用有限制通配符来提升-API-的灵活性"><a href="#【28】利用有限制通配符来提升-API-的灵活性" class="headerlink" title="【28】利用有限制通配符来提升 API 的灵活性"></a>【28】利用有限制通配符来提升 API 的灵活性</h4><p>确定了子类型后，每个类型便都是自身的子类型，即便它没有将自身扩展。</p>
<p>为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。如果某个输入参数既是生产者，又是消费者，那么通配符类型就没有什么好处了：因为你需要的是严格的类型匹配，这不是用任何通配符而得到的。</p>
<p><strong>PECS</strong> 表示 producer-extends，consumer-super。</p>
<p>如果参数化类型表示一个 T 生产者，就使用&lt;? extends T&gt;；如果它表示一个 T 消费者，就使用&lt;? super T&gt;。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; src)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (E  e：src)</span><br><span class="line"></span><br><span class="line">	push(e)；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法中的 src 参数产生 E 实例供 Stack 使用，因此 src 相应的类型为 Iterable&lt;? super E&gt;；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ( ! isEmpty)</span><br><span class="line"></span><br><span class="line">	dst.add(pop())；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法中 dst 参数通过 Stack 消费 E 实例，因此 dst 相应的类型为 Collection&lt;? super E&gt;。</p>
<p>一般来说，如果类型参数只在方法声明中出现一次，就可以用通配符取代它。如果是无限制的类型参数(<E>)，就用无限制的通配符取代它(&lt;?&gt;)；如果是有限制的类型参数，就用有限制的通配符取代它。</p>
<h4 id="【29】优先考虑类型安全的异构容器"><a href="#【29】优先考虑类型安全的异构容器" class="headerlink" title="【29】优先考虑类型安全的异构容器"></a>【29】优先考虑类型安全的异构容器</h4><p>cast 方法是 Java 的 cast 操作符的动态模拟。它只检测它的参数是否为 Class 对象所表示的类型实例。如果是，就返回参数；否则就抛出 ClassCastException 异常。</p>
<p>集合 API （如 Set 和 Map）说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上来避开这一限制。对于这种类型安全的异构容器，可以用 Class 对象作为键。以这种方式使用的 Class 对象称作类型令牌。你也可以使用定制的键类型。例如，用一个 DatabaseRow 类型表示一个数据库行（容器），用泛型 Column<T> 作为它的键。</p>
<h2 id="七、枚举和注解："><a href="#七、枚举和注解：" class="headerlink" title="七、枚举和注解："></a><strong>七、枚举和注解：</strong></h2><h4 id="【30】用-enum-代替-int-常量"><a href="#【30】用-enum-代替-int-常量" class="headerlink" title="【30】用 enum 代替 int 常量"></a>【30】用 enum 代替 int 常量</h4><p>Java 枚举类型背后的基本想法非常简单：它们就是通过公有的静态 final 域为每个枚举常量导出实例的类。因为没有可以访问的构造器，枚举类型是真正的 final。Java 枚举本质上是 int 值。</p>
<p>为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Planet &#123;</span><br><span class="line"></span><br><span class="line">	MERCURY	(<span class="number">3.302e+23</span>, <span class="number">2.439e6</span>),	<span class="comment">//使用构造器</span></span><br><span class="line"></span><br><span class="line">	VENUS		(<span class="number">4.869e+24</span>, <span class="number">6.052e6</span>),</span><br><span class="line"></span><br><span class="line">	EARTH		(<span class="number">5.975e+24</span>, <span class="number">6.378e6</span>),</span><br><span class="line"></span><br><span class="line">	MARS		(<span class="number">6.419e+23</span>, <span class="number">3.393e6</span>),</span><br><span class="line"></span><br><span class="line">	JUPITER		(<span class="number">1.899e+27</span>, <span class="number">7.149e7</span>),</span><br><span class="line"></span><br><span class="line">	SATURN		(<span class="number">5.685e+26</span>, <span class="number">6.027e7</span>),</span><br><span class="line"></span><br><span class="line">	URANUS		(<span class="number">8.683e+25</span>, <span class="number">2.556e7</span>),</span><br><span class="line"></span><br><span class="line">	NEPTUNE	(<span class="number">1.024e+26</span>, <span class="number">2.477e7</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> mass;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> surfaceGravity;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> G = <span class="number">6.67300E-11</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内部构造器，外部不能访问</span></span><br><span class="line"></span><br><span class="line">	Planet(<span class="keyword">double</span> mass, <span class="keyword">double</span> radius) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.mass = mass;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.radius = radius;</span><br><span class="line"></span><br><span class="line">		surfaceGravity = G * mass / (radius * radius);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> mass;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">radius</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> radius;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">surfaceGravity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> surfaceGravity;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">surfaceWeight</span><span class="params">(<span class="keyword">double</span> mass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> mass * surfaceGravity;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当需要一组固定常量的时候，应该使用枚举。枚举中的常量集不一定要始终保持不变。如果多个枚举常量同时共享相同的行为，则考虑策略枚举：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> PayrollDay &#123;</span><br><span class="line"></span><br><span class="line">	MONDAY(PayType.WEEKDAY)，	<span class="comment">//使用策略一</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	SUNDAY(PayType.WEEKEND)；	<span class="comment">//使用策略二</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PayType payType；</span><br><span class="line"></span><br><span class="line">	PayrollDay(PayType payType) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.payType = payType；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">pay</span><span class="params">(<span class="keyword">double</span> hoursWorked，<span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> payType.pay(hoursWorked，payRate)；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//策略枚举</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">enum</span> PayType &#123;</span><br><span class="line"></span><br><span class="line">		WEEKDAY &#123;	<span class="comment">//策略一：WEEKDAY 策略</span></span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">double</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">double</span> hours，<span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;，</span><br><span class="line"></span><br><span class="line">		WEEKEND &#123;	<span class="comment">//策略二：WEEKEND 策略</span></span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">double</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">double</span> hours，<span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;；</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="comment">//枚举内部声明的抽象构造方法</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">double</span> hours，<span class="keyword">double</span> payRate)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">		<span class="keyword">double</span> <span class="title">pay</span><span class="params">(<span class="keyword">double</span> hours，<span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【31】用实例域代替序数"><a href="#【31】用实例域代替序数" class="headerlink" title="【31】用实例域代替序数"></a>【31】用实例域代替序数</h4><p>永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。很少用到，故不详细说明了。</p>
<h4 id="【32】用-EnumSet-代替位域"><a href="#【32】用-EnumSet-代替位域" class="headerlink" title="【32】用 EnumSet 代替位域"></a>【32】用 EnumSet 代替位域</h4><p>集合的位域表示法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_BOLD				= <span class="number">1</span>&lt;&lt;<span class="number">0</span>；<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_ITALIC				= <span class="number">1</span>&lt;&lt;<span class="number">1</span>；<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_UNDERLINE		= <span class="number">1</span>&lt;&lt;<span class="number">2</span>；<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_STRIKETHROUGH	= <span class="number">1</span>&lt;&lt;<span class="number">3</span>；<span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(<span class="keyword">int</span> styles)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">text.applyStyles(STYLE_BOLD | STYLE_ITALIC)；</span><br></pre></td></tr></table></figure>

<p>用枚举代替位域：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> Style &#123; BOLD，ITALIC，UNDERLINE，STRIKETHROUGH &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(Set&lt;style&gt; styles)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">text.applyStyles(EnumSet.of(Style.BOLD，Style.ITALIC))；</span><br></pre></td></tr></table></figure>

<h4 id="【33】用-EnumMap-代替序数索引"><a href="#【33】用-EnumMap-代替序数索引" class="headerlink" title="【33】用 EnumMap 代替序数索引"></a>【33】用 EnumMap 代替序数索引</h4><p>最好不要用序数来索引数组，而要使用 EnumMap。如果你所表示的这种关系是多维的，就使用 EnumMap&lt;…， EnumMap&lt;…&gt;&gt;。应用程序的程序员在一般的情况下都不使用 Enum.ordinal</p>
<p>即使要用也很少，因此这是一种特殊情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Herb.Type，Set&lt;Herb&gt;&gt; herbsByType = <span class="keyword">new</span> EnumMap&lt;Herb.Type，Set&lt;Herb&gt;&gt;(Herb.Type<span class="class">.<span class="keyword">class</span>)；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">for</span> (<span class="title">Herb</span>.<span class="title">Type</span> <span class="title">t</span>：<span class="title">Herb</span>.<span class="title">Type</span>.<span class="title">values</span>()) </span>&#123;</span><br><span class="line"></span><br><span class="line">	herbsByType.put(t，<span class="keyword">new</span> HashSet&lt;Herb&gt;())；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Herb h：garden) &#123;</span><br><span class="line"></span><br><span class="line">	herbsByType.get(h.type).add(h)；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(herbsByType)；</span><br></pre></td></tr></table></figure>

<h4 id="【34】用接口模拟可伸缩的枚举"><a href="#【34】用接口模拟可伸缩的枚举" class="headerlink" title="【34】用接口模拟可伸缩的枚举"></a>【34】用接口模拟可伸缩的枚举</h4><p>虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。这样允许客户端编写自己的枚举来实现接口。如果 API 是根据接口编写的，那么在可以使用基础枚举类型的任何地方，也都可以使用这些枚举。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123; <span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x，<span class="keyword">double</span> y)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">enum</span> BasicOperation implements Operation </span>&#123; <span class="comment">//扩展接口的基本运算类型</span></span><br><span class="line"></span><br><span class="line">	PLUS (<span class="string">"+"</span>) &#123;	<span class="comment">//加法运算</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x，<span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x+y；&#125;</span><br><span class="line"></span><br><span class="line">	&#125;，</span><br><span class="line"></span><br><span class="line">	MINUS (<span class="string">"-"</span>) &#123;...&#125;，	<span class="comment">//减法运算，省略</span></span><br><span class="line"></span><br><span class="line">	TIMES (<span class="string">"*"</span>) &#123;...&#125;，	<span class="comment">//乘法运算，省略</span></span><br><span class="line"></span><br><span class="line">	DEVIDE (<span class="string">"/"</span>) &#123;...&#125;；	<span class="comment">//除法运算，省略</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String symbol；</span><br><span class="line"></span><br><span class="line">	BasicOperation(String symbol) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.symbol = symbol；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> symbol；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExtendedOperation implements Operation &#123; <span class="comment">//扩展接口的扩展运算类型</span></span><br><span class="line"></span><br><span class="line">	EXP(<span class="string">"^"</span>) &#123;		<span class="comment">//计算 x 的 y 次方的结果</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x，<span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> Math.pow(x，y)；</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;，</span><br><span class="line"></span><br><span class="line">	REMINDER(<span class="string">"%"</span>) &#123;...&#125;；	<span class="comment">//求余运算</span></span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【35】注解优先于命名模式"><a href="#【35】注解优先于命名模式" class="headerlink" title="【35】注解优先于命名模式"></a>【35】注解优先于命名模式</h4><h4 id="【36】坚持使用-Override-注解"><a href="#【36】坚持使用-Override-注解" class="headerlink" title="【36】坚持使用 Override 注解"></a>【36】坚持使用 Override 注解</h4><p>Override 注解只能用在方法声明中，它表示被注解的方法声明覆盖了超类型中的一个声明。如果坚持使用这个注解，可以防止一大类的非法错误。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bigram</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> first；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> second；</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Bigram b)</span> </span>&#123; <span class="comment">//结果是重载而非覆盖 equals 方法</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> b.first == first &amp;&amp; b.second == second；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了覆盖 Object.equals，必须定义一个参数为 Object 类型的 equals 方法，但是 Bigram 的 equals 方法的参数并不是 Object 类型，因此 Bigram 从 Object 继承了 equals 方法，而非覆盖了equals 方法。需要改成正确的覆盖方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bigram</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> first；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> second；</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span>	<span class="comment">//当加入注解时，会给出覆盖 equals 方法提示</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(**Object  o**)</span> </span>&#123; <span class="comment">//覆盖 equals 方法</span></span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Bigram)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>；</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Bigram b = (Bigram) <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> b.first == first &amp;&amp; b.second == second；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【37】用标记接口定义类型"><a href="#【37】用标记接口定义类型" class="headerlink" title="【37】用标记接口定义类型"></a>【37】用标记接口定义类型</h4><p>标记接口是没有包含方法声明的接口，而只是指明一个类实现了某种属性的接口。例如，考虑 Serializable 接口。通过实现这个接口，类表明它的实例可以被写到 ObjectOutputStream (或者“被序列化”)。</p>
<p>序列化的原因：很多时候，由于通信协议的原因，在传输的过程中，复杂的类对象是不支持传来传去的，所以一般来说要转化成流的形式，放在包中传来传去。</p>
<p>标记接口的例子：</p>
<p><strong>定义标记接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标记接口继承：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,  </span></span><br><span class="line"><span class="class">	<span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>		//继承<span class="title">Random</span>-<span class="title">Access</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span>  </span></span><br><span class="line"><span class="class">    <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>	//未继承<span class="title">Random</span>-<span class="title">Access</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标记接口使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.RandomAccess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceLearning</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iteratorElements</span><span class="params">(List&lt;String&gt; list)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//判断 list 是否为 RandomAccess 实例，以采取不同的处理策略</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list <span class="keyword">instanceof</span> **RandomAccess**)	</span><br><span class="line"></span><br><span class="line">        &#123;   ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        &#123;  ...  &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、方法："><a href="#八、方法：" class="headerlink" title="八、方法："></a><strong>八、方法：</strong></h2><h4 id="【38】检查参数的有效性"><a href="#【38】检查参数的有效性" class="headerlink" title="【38】检查参数的有效性"></a>【38】检查参数的有效性</h4><p>每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制，应该把这些限制写到文档中，并且在这个方法的开头处，通过显示的检查来实施这些限制。养成这样的的习惯是非常重要的。只要有效检查有一次失败，你为必要的有效性检查所付出的努力便都可以连本带利得到偿还了。</p>
<h4 id="【39】必要时进行保护性拷贝"><a href="#【39】必要时进行保护性拷贝" class="headerlink" title="【39】必要时进行保护性拷贝"></a>【39】必要时进行保护性拷贝</h4><p>如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性的拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当的修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。实例：</p>
<p>我们定义了一个Person类，该类的字段均为私有的，同时没有添加可以修改字段的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Date birth; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Date birth)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.birth = birth; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">getBirth</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> birth; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类看似是一个不可变类，实际上是这样的吗？可以测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  Person p = <span class="keyword">new</span> Person(<span class="string">"Benson"</span>,<span class="keyword">new</span> Date(<span class="number">1990</span>, <span class="number">4</span>, <span class="number">13</span>)); </span><br><span class="line"></span><br><span class="line">  System.out.println(p.getName()); </span><br><span class="line"></span><br><span class="line">  System.out.println(p.getBirth().getYear()); </span><br><span class="line"></span><br><span class="line">  Date hole = p.getBirth(); 	<span class="comment">//得到 Date 变量，但 Date 变量是可变的</span></span><br><span class="line"></span><br><span class="line">  hole.setYear(<span class="number">2013</span>); 		<span class="comment">//birth 改变</span></span><br><span class="line">    </span><br><span class="line">  System.out.println(p.getName()); </span><br><span class="line"></span><br><span class="line">  System.out.println(p.getBirth().getYear()); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Benson </span><br><span class="line"></span><br><span class="line"><span class="number">1990</span> </span><br><span class="line"></span><br><span class="line">Benson </span><br><span class="line"></span><br><span class="line"><span class="number">2013</span></span><br></pre></td></tr></table></figure>

<p>Person 实例被改变了，虽然 Person 实例中没有可以改变 Person 类的方法给外部访问，但是</p>
<p>Person 类中具有一个可变的属性 Date ，外部客户端可以先得到这个 Date 属性，再调用 Date 的 set() 方法来改变 Person 类，造成了类的可变性。</p>
<p>使用保护性拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">	... </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getBirth</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> Date(birth.toString());   <span class="comment">//保护性拷贝 </span></span><br><span class="line"></span><br><span class="line">  	&#125; </span><br><span class="line"></span><br><span class="line">	... </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后再调用 Date hole = p.getBirth(); 得到的变量 hole 是 Person 属性 birth 的一个副本，之后再</p>
<p>调用 hole.set() 方法就不会改变 birth 属性的值了，对 Person 类就有了一个很好的保护。</p>
<h4 id="【40】谨慎的设计方法签名"><a href="#【40】谨慎的设计方法签名" class="headerlink" title="【40】谨慎的设计方法签名"></a>【40】谨慎的设计方法签名</h4><p><strong>（1）谨慎地选择方法的名称。</strong>方法的名称应该始终遵循标准的命名习惯。</p>
<p><strong>（2）不要过于追求提供便利的的方法。</strong>每个方法都应该尽其所能。方法太多会使类难以学习、使用、文档化、测试和维护。</p>
<p><strong>（3）避免过长的参数列表。</strong>目标是四个，或者更少。缩短参数列表的方法：</p>
<p>&lt;1&gt;将方法分解为多个方法。</p>
<p>&lt;2&gt;创建辅助类。例如 draw（int x, int y, String name）中的（int x，int y）代表一个点，就可以用 draw（Point point，String name）来代替。</p>
<p>&lt;3&gt;从对象构建到方法调用都采用 Builder 模式。例如 fruit.addName(“Apple”).addColor(“Red”)</p>
<p><strong>（4）对于参数类型，要优先使用借口而不是类。</strong>如果使用的是类而不是接口，则限制了客户端只能传入特定的实现，如果碰巧输入的数据是以其他的形式存在，则就会导致不必要的，可能非常昂贵的拷贝操作。例如如果使用 Map 接口作为参数，就可以使你传入一个 Hashtable、HashMap、Tr-eeMap 或者任何有待于将来编写的 Map 实现。</p>
<p><strong>（5）对于 boolean 参数，要优先使用两个元素的枚举类型。</strong>它使代码更易于阅读和编写，也使以后更易于添加更多的选项。</p>
<h4 id="【41】慎用重载"><a href="#【41】慎用重载" class="headerlink" title="【41】慎用重载"></a>【41】慎用重载</h4><p>对于重载方法的选择是静态的，对于被覆盖的方法的选择则是动态的。</p>
<p>调用重载方法是在编译时作出决定的，选择被覆盖的方法的正确版本是在运行时进行的。</p>
<p>对于以下变量 collections :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;?&gt; collections = &#123; <span class="keyword">new</span> HashSet&lt;String&gt;()， <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;()， <span class="keyword">new</span> HashMap&lt;String，String&gt;().values() &#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Collection&lt;?&gt; c ： collections) &#123;</span><br><span class="line"></span><br><span class="line">	System.out.println(classify(c))；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 for 循环的三次迭代，Collection&lt;?&gt; 为参数的编译时类型，而 HashSet<String>，Array-List<String>，HashMap&lt;String，String&gt; 为三个参数的运行时类型。</p>
<p>重载的例子：如构造函数，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span> <span class="params">()</span> </span>&#123; &#125;；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span> <span class="params">(String name)</span> </span>&#123; &#125;；</span><br></pre></td></tr></table></figure>

<p>覆盖的例子：如子类Override复写，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wine</span> </span>&#123; <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"wine"</span>； &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparklingWine</span> <span class="keyword">extends</span> <span class="title">Wine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span>   </span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"sparkling wine"</span>； &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载的安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用可变参数，保守的策略是根本不要重载它。这项限制并不麻烦，因为你始终可以给方发起不同的名称，而不使用重载机制。</p>
<p>对于构造器，你没有选择使用不同名称的机会；一个类的多个构造器总是重载的。在许多情况下，可以选择导出静态工厂，而不是构造器。</p>
<p>总而言之，“能够重载方法”并不意味着“应该重载方法”。一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法，但是在某些情况下，特别是涉及构造器的时候，就必定要重载</p>
<p>这种情况下，至少要避免这种情形：同一组参数只需要经过类型转换就可以传递给不同的重载方法。如果不可避免，就应当保证：当传递同样的参数时，所有重载方法的行为必须一致。</p>
<h4 id="【42】慎用可变参数"><a href="#【42】慎用可变参数" class="headerlink" title="【42】慎用可变参数"></a>【42】慎用可变参数</h4><p>在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用。如果使用不当，会产生混乱的结果。</p>
<p>定义可变参数方法的一个好的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> firstArg，<span class="keyword">int</span>... remainingArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> min = firstArg；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> arg：remainingArgs) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (arg &lt; min) &#123;</span><br><span class="line"></span><br><span class="line">			min = arg；</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> min；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在重视性能的情况下，使用可变参数机制要特别小心。可变参数方法的每次调用都会导致进行一次数组分配和初始化。假设确定对某个方法 95% 的调用会有 3 个或者更少的参数，就该声明 5 个重载，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;	&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1)</span> </span>&#123;	&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1，<span class="keyword">int</span> a2)</span> </span>&#123;      &#125;；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1，<span class="keyword">int</span> a2，<span class="keyword">int</span> a3)</span> </span>&#123;		&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1，<span class="keyword">int</span> a2，<span class="keyword">int</span> a3，<span class="keyword">int</span>... rest)</span> </span>&#123;		&#125;；</span><br></pre></td></tr></table></figure>

<h4 id="【43】返回零长度的数组或者集合，而不是-null"><a href="#【43】返回零长度的数组或者集合，而不是-null" class="headerlink" title="【43】返回零长度的数组或者集合，而不是 null"></a>【43】返回零长度的数组或者集合，而不是 <strong>null</strong></h4><p>返回类型为数组或者为集合的方法不应该返回 null，而应该返回一个零长度的数组或者集合。集合值的方法可以做成在每当需要返回空集合的时候都返回同一个不可变的空集合。Collections.empty-Set、emptyList 和 emptyMap 提供的正是我们需要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheeseList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cheeseInStock.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Collections.emptyList()；<span class="comment">//返回空集合，而不是 null</span></span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Cheese&gt;(cheeseInStock)；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【44】为所有导出的-API-元素编写文档注释"><a href="#【44】为所有导出的-API-元素编写文档注释" class="headerlink" title="【44】为所有导出的 API 元素编写文档注释"></a>【44】为所有导出的 API 元素编写文档注释</h4><p>Javadoc 的 {@code} 标签：使代码片段以代码字体进行呈现，并限制 HTML 标记和嵌套的 Jav-adoc 标签在代码片段中进行处理。后一种属性正是允许我们在代码片段中使用小于号（&lt;）的东西，虽然它是一个 HTML 元字符。</p>
<p>Javadoc 的 {@literal} 标签也是为了产生包含 HTML 元字符的文档，比如小于号（&lt;）、大于号（&gt;）以及“与”（&amp;）。除了它不以代码字体渲染文本之外，其余方面就像 {@code} 标签一样。例如：</p>
<p>* The triangle inequality is { @literal |x + y|&lt;|x| + |y| } 产生的文档为： “The triangle inequality is |x + y|&lt;|x| + |y| ”</p>
<p>文档注释在源代码和产生的文档中都应该是易于阅读的。如果无法让两者都易读，产生的文档的可读性要优先于源码的可读性。</p>
<h2 id="九、通用程序设计："><a href="#九、通用程序设计：" class="headerlink" title="九、通用程序设计："></a><strong>九、通用程序设计：</strong></h2><h4 id="【45】将局部变量的作用域最小化"><a href="#【45】将局部变量的作用域最小化" class="headerlink" title="【45】将局部变量的作用域最小化"></a>【45】将局部变量的作用域最小化</h4><p>将局部变量的作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。</p>
<p>要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。几乎每个局部变量的声明都应该包含一个初始化表达式。如果还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。</p>
<p>如果在循环终止之后不再需要循环变量的内容，for 循环就优先于 while 循环。以下展示一个“剪切—粘贴”错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Element&gt; i = c.iterator()；</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">	doSomething(i.next())；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Iterator&lt;Element&gt; i2 = c2.iterator()；</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i.hasNext()) &#123;				<span class="comment">//BUG! 变量 i 的作用域使 i 仍在有效范围</span></span><br><span class="line"></span><br><span class="line">	doSomethingElse()；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 for 循环可以避免这种问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;Element&gt; i = c.iterator()；i.hasNext()；) &#123;</span><br><span class="line"></span><br><span class="line">	doSomething(i.next())；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;Element&gt; i = c2.iterator()；i.hasNext()；) &#123;	<span class="comment">//上一个变量 i 作用域已结束，不影响</span></span><br><span class="line"></span><br><span class="line">	doSomething(i.next())；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【46】for-each-循环优先于传统的-for-循环"><a href="#【46】for-each-循环优先于传统的-for-循环" class="headerlink" title="【46】for-each 循环优先于传统的 for 循环"></a>【46】for-each 循环优先于传统的 for 循环</h4><p>for-each 循环在简洁性和预防 BUG 方面有着传统的 for 循环无法比拟的优势，并且没有性能损失。应该尽可能地使用 for-each 循环。for-each 循环不仅让你遍历集合和数组，还让你遍历任何实现Iterable 接口的对象。例如：</p>
<p>使用 for 循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;Suit&gt; i = suits.iterator()；i.hasNext()；) &#123;</span><br><span class="line"></span><br><span class="line">	Suit suit = i.next()；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Iterator&lt;Rank&gt; j = ranks.iterator()；j.hasNext()；) &#123;</span><br><span class="line"></span><br><span class="line">		deck.add(<span class="keyword">new</span> Card(suit，j.next()))；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 for-each 循环代替：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Suit suit：suits) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Rank rank：ranks) &#123;</span><br><span class="line"></span><br><span class="line">		deck.add(<span class="keyword">new</span> Card(suit，j.next()))；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种常见的不能使用 for-each 循环的情况：</p>
<p><strong>过滤</strong>——如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的remove 方法。</p>
<p><strong>转换</strong>——如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引，以便设定元素的值。</p>
<p><strong>平行迭代</strong>——如果需要并行的遍历多个集合，就需要显式的控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>《EffectiveJava》（二）</title>
    <url>/2019/11/23/EffectiveJava1/</url>
    <content><![CDATA[<h4 id="【15】使可变性最小化"><a href="#【15】使可变性最小化" class="headerlink" title="【15】使可变性最小化"></a>【15】使可变性最小化</h4><p>不可变类只是实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。为了使类成为不可变，要遵循下面五条规则：</p>
<p>&lt;1&gt;不要提供任何会修改对象状态的方法。</p>
<p>&lt;2&gt;保证类不会被扩展。</p>
<p>&lt;3&gt;使所有的域都是 final 的。</p>
<p>&lt;4&gt;使所有的域都成为私有的。</p>
<p>&lt;5&gt;确保对于任何可变组件的互斥访问。</p>
<a id="more"></a>

<p>不可变对象本质上是线程安全的，它们不要求同步。当多个线程并发访问这样的对象时它们不会遭到破坏。这无疑是获得线程安全最容易的办法。</p>
<p>不可变类真正唯一的缺点是，对于每一个不同的值都需要一个单独的对象，创建这种对象的代价可能会很高。这时候就需要为不可变类提供一个共有的可变配套类来进行复杂的多阶段操作，例如：</p>
<p>StringBuilder 类就是 String 类的可变配套类，用来改变 String 对象，以提升性能。</p>
<h4 id="【16】复合优先于继承"><a href="#【16】复合优先于继承" class="headerlink" title="【16】复合优先于继承"></a>【16】复合优先于继承</h4><p>继承的功能非常强大，但也存在诸多问题，因为它违背了封装原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类处在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性。为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。</p>
<p>复合设计：不用扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，现有类成为了新类的一个组件，新类中的每个实例方法都可以调用被包含的现有实例中的对应方法，并返回结果。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转发类（中间层），包含转发方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;E&gt; s；<span class="comment">//现有类的实例</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> ForwardingSet（Set&lt;E&gt; s） &#123; <span class="keyword">this</span>.s = s； &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>	</span>&#123; s.clear； &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>	</span>&#123; <span class="keyword">return</span> s.add(e)； &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复合类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> addCount = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InstrumentedSet</span><span class="params">(Set&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(s)；</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">		addCount++；</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.add(e)；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【17】要么为继承而设计，并提供文档说明，要么就禁止继承"><a href="#【17】要么为继承而设计，并提供文档说明，要么就禁止继承" class="headerlink" title="【17】要么为继承而设计，并提供文档说明，要么就禁止继承"></a>【17】要么为继承而设计，并提供文档说明，要么就禁止继承</h4><p>为了允许继承，类还需遵守其他一些约束。构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用，因为超类的构造器是在子类的构造器之前运行的，所以子类中覆盖版本的方法将会在子类的构造器运行之前就先被调用。</p>
<p>对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种方法可以禁止子类化：</p>
<p>&lt;1&gt;把这个类声明为 final 的。</p>
<p>&lt;2&gt;把类中所有的构造器都变成私有的，包括包级私有的，并增加一些公有的静态工厂来替代构造器。</p>
<p>你可以机械地消除类中可覆盖方法的自用特性，而不改变它的行为。将每个可覆盖方法的代码体移到一个私有的 “辅助方法（helper method）” 中，并让每个可覆盖方法调用它的私有辅助方法。然后，用 “直接调用可覆盖方法的私有辅助方法” 来代替 “可覆盖方法的每个自用调用” 。 </p>
<h4 id="【18】接口优于抽象类"><a href="#【18】接口优于抽象类" class="headerlink" title="【18】接口优于抽象类"></a>【18】接口优于抽象类</h4><p>接口和抽象类机制之间的区别：抽象类允许包含某些方法的实现，但是接口则不允许；一个更重要的区别在于，为了实现由抽象类定义的类型，类必须成为抽象类的一个子类，而任何一个类，只要它定义了所有必要的方法，并且遵守通用约定，它就被允许实现一个接口，而不管这个类是处于类层次的哪个位置。</p>
<p>抽象类的演变比接口的演变要容易得多。如果在后续的发行版本中，你希望在抽象类中增加新的方法，始终可以增加具体方法，它包含合理的默认实现。然后，该抽象类的所有实现都将提供这个新的方法，对于接口，这样做是行不通的。</p>
<p>通过对导出的每一个重要接口都提供一个<strong>抽象的骨架实现</strong>（skeletal implementation）类，可以把接口和抽象类的优点结合起来。接口的作用仍然是定义类型，但是骨架实现类接管了所有与接口实现相关的工作。例如：</p>
<p><strong>接口1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口1的抽象骨架实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">AbstractFoo</span> <span class="keyword">implements</span> <span class="title">IFoo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> String val;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getVal</span><span class="params">()</span> </span>&#123;**<span class="comment">//自定义 get 方法，扩展接口1的实现**</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(String val)</span> </span>&#123;**<span class="comment">//自定义 set 方法，扩展接口1的实现**</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>.val = val;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;**<span class="comment">//实现接口1的 foo() 方法**</span></span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">"AbstarctFoo"</span>);</span><br><span class="line"></span><br><span class="line">     &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新的测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">extends</span> <span class="title">AbstractFoo</span> <span class="keyword">implements</span> <span class="title">IBar</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;**<span class="comment">//实现 IBar 接口方法 bar()**</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// yingkhtodo Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;**<span class="comment">//实现 AbstractFoo 中未实现的接口1的 add() 方法**</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// yingkhtodo Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;**<span class="comment">//实现 AbstractFoo 中未实现的接口1的 del() 方法**</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// yingkhtodo Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FooBar 类继承自 AbstractFoo 类，可以调用父类的 set()、get()、foo() 方法，也可以自己实现接口1和 IBar 接口的方法，其中接口1 foo() 方法在抽骨架价类 AbstractFoo 中实现，不需要再次实现，并且其它继承自 AbstractFoo 类的任意子类都不需要实现接口1的 foo() 方法， AbstractFoo 类接管了所有与接口1实现的相关工作。</p>
<h4 id="【19】接口只用于定义类型"><a href="#【19】接口只用于定义类型" class="headerlink" title="【19】接口只用于定义类型"></a>【19】接口只用于定义类型</h4><p>接口应该只被用来定义类型，它们不应该被用来导出常量。如果常量被看做枚举类型的成员，就应该用枚举类型（enum type）来导出这些常量，否则，应该使用不可实例化的工具类（utility-class）来导出常量，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhysicalConstants</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">PhysicalConstants</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">//Prevents instantiation</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> AVOGADROS_NUMBER = <span class="number">6.02214199e23</span>；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BOLTZMANN_CONSTANT = <span class="number">1.3806503e-23</span>；</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【20】类层次优于标签类"><a href="#【20】类层次优于标签类" class="headerlink" title="【20】类层次优于标签类"></a>【20】类层次优于标签类</h4><p>标签类很少有使用的时候，当你想要编写一个包含显式标签域的类时，应该考虑一下，这个标签域是否可以被取消，这个类是否可以被层次类来代替。当你遇到一个包含标签域的现有类时，就要考虑将它重构到一个层次结构中去。例如，标签类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum</span> Shape &#123; RECTANGLE，CIRCLE &#125;；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> Shape shape；<span class="comment">//标签域，用来表示图形类别</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//矩形参数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> length；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> width；</span><br><span class="line"></span><br><span class="line">	<span class="comment">//圆形参数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> radius</span><br><span class="line"></span><br><span class="line">	Figure (<span class="keyword">double</span> radius) &#123;</span><br><span class="line"></span><br><span class="line">		shape = Shape.CIRCLE；</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.radiu = radius；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(shape) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> CIRCLE：</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> MATH.PI * (radius * radius)；</span><br><span class="line"></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换为层次类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Circle extends Figure </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">double</span> radius；</span><br><span class="line"></span><br><span class="line">	Circle(Double radius) &#123; <span class="keyword">this</span>.radius = radius；&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Math.PI * (radius * radius)；&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【21】用函数对象表示策略"><a href="#【21】用函数对象表示策略" class="headerlink" title="【21】用函数对象表示策略"></a>【21】用函数对象表示策略</h4><p>有些语言支持函数指针（function pointer）、代理（delegate）、lambda表达式，或者支持类似机制，允许程序把 “调用特殊函数的能力 “ 存储起来并传递这种能力。这种机制通常用于允许函数的调用者通过传入第二个函数，来指定自己的行为。</p>
<p>函数指针的主要用途就是实现策略（Strategy）模式。为了在 JAVA 中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略被使用一次时，通常使用匿名类来声明和实现这个具体策略类。当一个具体策略是设计用来重复使用的时候，它的类通常就要被实现为私有的静态成员类，并通过公有的静态 final 域被导出，其类型为该策略接口。</p>
<p>策略接口示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(T t1，T t2)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>匿名类示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Array.sort(stringArray，<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1，s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> s1.length() - s2.length()；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>

<p>导出静态域实现策略示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StrLenCmp</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;，<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> s1.length() - s2.length()；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公有静态域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; STRING_LENGTH_COMPARATOR </span><br><span class="line">    </span><br><span class="line">    = <span class="keyword">new</span> StrLenCmp()；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【22】优先考虑静态成员类"><a href="#【22】优先考虑静态成员类" class="headerlink" title="【22】优先考虑静态成员类"></a>【22】优先考虑静态成员类</h4><p>嵌套类有四种：静态成员类、非静态成员类、匿名类和局部类。</p>
<p>静态成员类是最简单的一种嵌套类，它可以访问外围类的所有成员，包括那些声明为私有的成员。</p>
<p>非静态成员类每个实例都隐含着与外围类的一个外围实例相关联，在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的 this 构造获得外围实例的引用。如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是静态成员类：在没有外围实例的情况下，想要创建非静态成员类的实例是不可能的。</p>
<p>如果声明成员类不要求访问外围实例，就要始终把 static 修饰符放在它的声明中，使它成为静态成员类，而不是非静态成员类。</p>
<p>匿名类出现在表达式中必须保持简短（10行或更少），否则会影响程序可读性。匿名类的一种常见用法是动态地创建函数对象（sort(A ，new B(){ … })；）；另一种常见用法是创建过程对象，如 Runnable、Thread 或者 ThreadTask 实例。</p>
<h2 id="六、泛型："><a href="#六、泛型：" class="headerlink" title="六、泛型："></a><strong>六、泛型：</strong></h2><h4 id="【23】请不要在新代码中使用原生态类型"><a href="#【23】请不要在新代码中使用原生态类型" class="headerlink" title="【23】请不要在新代码中使用原生态类型"></a>【23】请不要在新代码中使用原生态类型</h4><p>使用原生态类型会在运行时导致异常，因此不要在新代码中使用。原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。Set<Object> 是个参数化类型，表示可以包含任何对象类型的一个集合；Set&lt;?&gt; 则是一个通配符类型，表示包含某种位置对象类型的一个集合；Set 则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。</p>
<p><img src="../../../../asserts/jietu.png" alt="img"></p>
<p>不要新代码中使用原生态类型，这条规则有两种例外：</p>
<p>a.在类文字中必须使用原生类型，如 List.class、String[].class 合法，但是 List<String>.class 不合法。</p>
<p>b.由于泛型信息可以在运行时被擦除，因此在参数化类型而非无限制通配符上使用 instanceof 操作符是非法的。用无限制通配符类型代替原生态类型，对 instanceof 操作符的行为不会产生任何影响</p>
<p>下面是利用泛型来使用 instanceof 操作符的首选方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> （o <span class="keyword">instanceof</span> Set） &#123;</span><br><span class="line"></span><br><span class="line">	Set&lt;?&gt; m = (Set &lt;?&gt;) o；</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【24】消除非受检警告"><a href="#【24】消除非受检警告" class="headerlink" title="【24】消除非受检警告"></a>【24】消除非受检警告</h4><p>用泛型编程时，会遇到许多编译器警告，每一条警告都表示可能在运行时抛出 ClassCast-</p>
<p>Exception 异常。要尽最大的努力消除这些警告。如果无法消除非受检警告，同时可以证明引起警告的代码是类型安全的，就可能在尽可能小的范围中，用@SupperessWarnings(unchecked)注解来禁止该警告。要用注释把禁止该警告的原因记录下来。</p>
<h4 id="【25】列表优先于数组"><a href="#【25】列表优先于数组" class="headerlink" title="【25】列表优先于数组"></a>【25】列表优先于数组</h4><p>数组和泛型有着非常不同的类型规则。数组是协变且可以具体化的；泛型是不可变且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型也一样。一般来说，数组和泛型不能很好的混用。如果你发现自己将它们混合起来使用，并且得到了编译时错误或者警告，你的第一反应就应该是用列表 (List<Object>或者List<E>) 代替数组 (Object[ ] 或者 E[ ] )。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">reduce</span><span class="params">(List&lt;E&gt; list，Function&lt;E&gt; f，E initval)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	List&lt;E&gt; snapshot；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">synchronized</span>(list) &#123;</span><br><span class="line"></span><br><span class="line">		snapshot = <span class="keyword">new</span> ArrayList&lt;E&gt;(list)；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	E result = initVal；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (E e：snapshot) &#123;</span><br><span class="line"></span><br><span class="line">		result = f.apply(result，e)；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【26】优先考虑泛型"><a href="#【26】优先考虑泛型" class="headerlink" title="【26】优先考虑泛型"></a>【26】优先考虑泛型</h4><p>使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。在设计新类型的时候，要确保他们不需要这种转换就可以使用。这通常意味着要把类做成泛型。只要时间允许，就要把现有的类型都泛型化。这对于这些类型的新用户来说会变得更加轻松，又不会破坏现有的客户端。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>《EffectiveJava》（一）</title>
    <url>/2019/11/23/EffectiveJava/</url>
    <content><![CDATA[<h2 id="一、基本原则："><a href="#一、基本原则：" class="headerlink" title="一、基本原则："></a><strong>一、基本原则：</strong></h2><h4 id="【1】模块的用户永远也不应该被模块的行为所迷惑"><a href="#【1】模块的用户永远也不应该被模块的行为所迷惑" class="headerlink" title="【1】模块的用户永远也不应该被模块的行为所迷惑"></a>【1】模块的用户永远也不应该被模块的行为所迷惑</h4><h4 id="【2】模块要尽可能小，但又不能太小"><a href="#【2】模块要尽可能小，但又不能太小" class="headerlink" title="【2】模块要尽可能小，但又不能太小"></a>【2】模块要尽可能小，但又不能太小</h4><h4 id="【3】代码应该被重用，而不是被拷贝"><a href="#【3】代码应该被重用，而不是被拷贝" class="headerlink" title="【3】代码应该被重用，而不是被拷贝"></a>【3】代码应该被重用，而不是被拷贝</h4><h4 id="【4】模块之间的依赖性应该尽可能地降到最小"><a href="#【4】模块之间的依赖性应该尽可能地降到最小" class="headerlink" title="【4】模块之间的依赖性应该尽可能地降到最小"></a>【4】模块之间的依赖性应该尽可能地降到最小</h4><h4 id="【5】错误应该尽早被检测出来，最好是在编译时刻"><a href="#【5】错误应该尽早被检测出来，最好是在编译时刻" class="headerlink" title="【5】错误应该尽早被检测出来，最好是在编译时刻"></a>【5】错误应该尽早被检测出来，最好是在编译时刻</h4><a id="more"></a>

<h2 id="二、Java语言支持四种类型："><a href="#二、Java语言支持四种类型：" class="headerlink" title="二、Java语言支持四种类型："></a><strong>二、Java语言支持四种类型：</strong></h2><p>接口（interface）、类（class）、数组（array）和基本类型（primitive）</p>
<p>前三种类型通常被称为引用类型（reference type），类实例和数组是对象（object），而基本类型的值则不是对象。</p>
<h2 id="三、创建和销毁对象："><a href="#三、创建和销毁对象：" class="headerlink" title="三、创建和销毁对象："></a><strong>三、创建和销毁对象：</strong></h2><h4 id="【1】考虑用静态工厂方法代替构造器"><a href="#【1】考虑用静态工厂方法代替构造器" class="headerlink" title="【1】考虑用静态工厂方法代替构造器"></a>【1】考虑用静态工厂方法代替构造器</h4><p>优点：a.静态工厂方法有名称，可以提示返回值，而构造器返回值是默认的</p>
<p>b.不必在每次调用静态工厂方法时都创建一个新的对象（单例模式）</p>
<p>c.静态工厂方法可以返回元返回类型的任何子类型的对象</p>
<p>d.静态工厂方法在创建参数化类型实例的时候，使得代码变得更加简洁</p>
<p>实例：</p>
<p>一般定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String，List&lt;String&gt;&gt; m = <span class="keyword">new</span> HashMap&lt;String，List&lt;String&gt;&gt;()；</span><br></pre></td></tr></table></figure>

<p>静态工厂方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K，V&gt; HashMap&lt;K，V&gt; newInstance()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K，V&gt;()；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态工厂方法定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String，List&lt;String&gt;&gt; m = HashMap.newInstance()；</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<p>​    i.类如果不含有共有的或者受保护的构造器，就不能被子例化</p>
<p>​    ii.它们与其他的静态方法实际上没有任何的区别</p>
<p>常用方法：</p>
<p>​    &lt;1&gt; valueOf() 类型转换方法</p>
<p>​    &lt;2&gt; getInstance() 获取实例，对于Singleton来说，该方法没有参数，并返回唯一实例</p>
<p>​    &lt;3&gt; newInstance() 获取新的不同实例</p>
<h4 id="【2】遇到多个构造器参数时要考虑用构建器（Builder）"><a href="#【2】遇到多个构造器参数时要考虑用构建器（Builder）" class="headerlink" title="【2】遇到多个构造器参数时要考虑用构建器（Builder）"></a>【2】遇到多个构造器参数时要考虑用构建器（Builder）</h4><p>如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择，特别是当大多数参数都是可选的时候。与是用传统的重叠构造器模式相比，使用Builder模式的客户端代码将更易于阅读和编写，构建器也比JavaBean更加安全。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">	.calories(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	.sodium(<span class="number">35</span>)</span><br><span class="line"></span><br><span class="line">	.carbonhydrate(<span class="number">27</span>)</span><br><span class="line"></span><br><span class="line">	.build();</span><br></pre></td></tr></table></figure>

<h4 id="【3】用私有构造器或者枚举类型强化Singleton属性"><a href="#【3】用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="【3】用私有构造器或者枚举类型强化Singleton属性"></a>【3】用私有构造器或者枚举类型强化Singleton属性</h4><p>实现方法：</p>
<p>​    a.共有静态成员为final域</p>
<p>​    b.公有成员为静态工厂方法</p>
<p>​    c.包含单个元素的枚举类型</p>
<h4 id="【4】通过私有构造器强化不可实例化的能力"><a href="#【4】通过私有构造器强化不可实例化的能力" class="headerlink" title="【4】通过私有构造器强化不可实例化的能力"></a>【4】通过私有构造器强化不可实例化的能力</h4><p>对于工具类，一般只包含静态方法和静态的域，这样的工具类（utility class）不希望被实例化，实例化对它没有任何意义。</p>
<p>企图将类做成抽象类来强制该类不可被实例化是行不通的，因为该类可以被子类化，并且该子类也可以被实例化。</p>
<p>将显示构造器声明为私有的就可以使类不能被实例化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Suppress default constructor for noninstantiability</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError()；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的副作用：使一个类不能被子类化。</p>
<h4 id="【5】避免创建不必要的对象"><a href="#【5】避免创建不必要的对象" class="headerlink" title="【5】避免创建不必要的对象"></a>【5】避免创建不必要的对象</h4><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"ABC"</span>)；<span class="comment">//**DON‘T DO THIS**</span></span><br><span class="line"></span><br><span class="line">String s = <span class="string">"ABC"</span>;<span class="comment">//**OK**</span></span><br></pre></td></tr></table></figure>

<p><strong>tips:</strong>要优先使用基本数据类型而不是装箱基本类型，要当心无意识的自动装箱。</p>
<p>Long sum = 0L   —-&gt; Long sum = 0l 使用0L的时候，代表每调用一次sum就会新创建一个Long实例</p>
<p>通过维护自己的对象池（object pool）来避免创建对象并不是一种好的做法，除非对象池中的对象是非常重量级的（例如数据库连接池、线程池）。</p>
<p>在提倡<strong>保护性拷贝</strong>的时候，因重用对象付出的代价要远远大于因创建重复对象而付出的代价，必要时如果没能实施保护性拷贝，会导致潜在的错误和安全漏洞；而不必要的创建对象则只会影响程序的风格和性能。</p>
<h4 id="【6】消除过期的对象引用"><a href="#【6】消除过期的对象引用" class="headerlink" title="【6】消除过期的对象引用"></a>【6】消除过期的对象引用</h4><p>一般而言，只要类是自己管理内存，程序就应该警惕内存泄漏问题。</p>
<p>典型的例子就是 <strong>Stack</strong> 类，Stack 类自己管理内存，如果一个栈先是增长，然后再收缩，那么从栈中弹出来的对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，由于栈内维护着这些对象的过期引用，它们也不会被回收。</p>
<p>清空过期引用的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException()；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object result = elements[--size]；</span><br><span class="line"></span><br><span class="line">	elements[size] = <span class="keyword">null</span>；<span class="comment">//消除过期对象引用</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【7】避免使用终结方法"><a href="#【7】避免使用终结方法" class="headerlink" title="【7】避免使用终结方法"></a>【7】避免使用终结方法</h4><p>类中对象中封装的资源（例如文件或者线程）需要终止时，只需提供一个显式的终止方法，并要求该类的客户端在每个实例不再有用的时候调用这个方法即可。</p>
<p>显式的终止方法通常与<strong>try-finally</strong>结构结合起来使用，以确保及时终止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo foo = <span class="keyword">new</span> Foo(...)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Do what must done with foo</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">	foo.terminate()；<span class="comment">//显式调用终止方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、对于所有对象都通用的方法："><a href="#四、对于所有对象都通用的方法：" class="headerlink" title="四、对于所有对象都通用的方法："></a><strong>四、对于所有对象都通用的方法：</strong></h2><h4 id="【8】覆盖-equals-时请遵守通用约定"><a href="#【8】覆盖-equals-时请遵守通用约定" class="headerlink" title="【8】覆盖 equals 时请遵守通用约定"></a>【8】覆盖 equals 时请遵守通用约定</h4><p>Object类提供的equals方法：类的每个实例都只与它的自身相等</p>
<p>一般来说，内容相同不一定他们在内存中指向的地址也是相同的。而不同的对象在内存中若指向同一个地址，则他们的内容肯定是相同的(因为他们实际上就是同一个对象)。而==(两个等号)运算符与 equal函数就是运来比较这两块内容的。<strong>其中==运算符是用来比较内存中的地址是否相同</strong>，即比较它们的身份证号码是否相同。<strong>而equal函数则只比较他们的内容</strong>。如果他们的内容相同，即使身份证号码不相同(内存中的地址不同)，这个函数也人们他们是相同的，会返回TRUE值。</p>
<p>例子：</p>
<p>◆String str1=new String(“welcome”); //创建一个对象，给利用单词welcome初始化</p>
<p>◆String str2=new String(“welcome”); //创建一个对象，给利用单词welcome初始化</p>
<p>◆String str3=str1; //创建一个对象，并利用对象str1的地址赋值</p>
<p>比较 str1==str2 返回 <strong>false</strong></p>
<p>比较 str1==str3 返回 <strong>true</strong></p>
<p>比较 str1.equals(str2) 返回 <strong>true</strong></p>
<p><strong>Object 中的 equals 方法实现了等价关系，具有以下特性：</strong></p>
<p>（1）自反性 （2）对称性 （3）传递性 （4）一致性 （5）非空性</p>
<p><strong>实现高质量的 equals 方法的诀窍：</strong></p>
<p>&lt;1&gt;使用 == 操作符检查“参数是否为这个对象的引用”</p>
<p>&lt;2&gt;使用 instanceof 操作符检查“参数是否为正确的类型”</p>
<p>&lt;3&gt;把参数转换成正确地类型</p>
<p>&lt;4&gt;对于该类中的每个“关键域”，检查参数中的域是否与该对象中对应的域匹配</p>
<p>&lt;5&gt;当你编写完成了 equals 方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？</p>
<p><strong>最后的忠告：</strong></p>
<p>​    <strong>-&gt;覆盖 equals 时总要覆盖 hashCode</strong></p>
<p>​    <strong>-&gt;不要企图让 equals 方法过于智能</strong></p>
<p>​    <strong>-&gt;不要将 equals 声明中的 Object 对象替换为其它的类型</strong></p>
<h4 id="【9】覆盖-equals-时总要覆盖-hashCode"><a href="#【9】覆盖-equals-时总要覆盖-hashCode" class="headerlink" title="【9】覆盖 equals 时总要覆盖 hashCode"></a>【9】覆盖 equals 时总要覆盖 hashCode</h4><h4 id="【10】始终要覆盖-toString"><a href="#【10】始终要覆盖-toString" class="headerlink" title="【10】始终要覆盖 toString"></a>【10】始终要覆盖 toString</h4><p>java.lang.Object 类提供了一个原生的 toString 方法实现，返回的字符串为：类名称+@+hash-Code，例如 “PhoneNumber@163b91” ；为了使类用起来更加舒适，建议所有的子类都覆盖toString 方法。</p>
<p>在实际使用中，toString 方法应该返回对象中包含的所有值得关注的信息，无论你对返回的信息是否指定确切的格式，都应该在函数文档说明中明确地表明自己的意图；无论是否指定格式，都应该为 toString 返回值中包含的所有信息，提供一种编程式的访问途径。</p>
<p>例如：PhoneNumber类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 以 “（XXX） YYY-ZZZZ” 的格式返回 PhoneNumber 实例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> String.format(<span class="string">"(%03d) %03d-%04d，areaCode，prefix，lineNumber"</span>)；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAreaCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.areaCode；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.prefix；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLineNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.lineNumber；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【11】谨慎地覆盖-clone"><a href="#【11】谨慎地覆盖-clone" class="headerlink" title="【11】谨慎地覆盖 clone"></a>【11】谨慎地覆盖 clone</h4><p>记住一点：Cloneable接口具有许多的问题，其他的接口都不应该扩展这个接口，为了继承而设计的类也不应该实现这个接口。对于一个专门为了继承而设计的类，如果你未能提供行为良好的受保护 clone 方法，它的子类就不可能实现 Cloneable 接口。</p>
<h4 id="【12】考虑实现-Comparable-接口"><a href="#【12】考虑实现-Comparable-接口" class="headerlink" title="【12】考虑实现 Comparable 接口"></a>【12】考虑实现 Comparable 接口</h4><p>通用约定：将对象与指定的对象进行比较，当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCa-</p>
<p>stException异常。</p>
<h2 id="五、类和接口："><a href="#五、类和接口：" class="headerlink" title="五、类和接口："></a><strong>五、类和接口：</strong></h2><h4 id="【13】使类和成员的可访问性最小化"><a href="#【13】使类和成员的可访问性最小化" class="headerlink" title="【13】使类和成员的可访问性最小化"></a>【13】使类和成员的可访问性最小化</h4><p>要区别设计良好的模块与设计不好的模块，最重要的因素在于，这个模块对于外部的其他模块而言，是否隐藏其内部数据和其它实现细节。设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。</p>
<p>对于顶层的（非嵌套类）类和接口，只有两种可能的访问级别：包级私有的（package-private）和公有的（public）。如果你用 public 修饰符声明了顶层类或者接口，那它就是公有的；否则，它将是包级私有的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为包级私有的类，只有同一个包下的类才能够访问到，如果在另一个包内的类，就不能访问到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为公有类，在不同的包内都可以访问到。</p>
<p>实例域决不能是公有的，以保证实例域的不可变性。</p>
<p>注意，长度非零的数组总是可变的，所以，类具有公有静态 final 数组域，或者返回这个域的访问方法，这几乎总是错误的。如果类具有这样的域或者访问方法，客户端就能够修改数组中的内容，可以使公有数组变成私有的，并增加一个公有的不可变列表来修正：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[ ] PRIVATE_VALUES = &#123;...&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = 		</span><br><span class="line"></span><br><span class="line">	Collection.unmodifiableList(Arrays.asList(PRIVATE_VALUES))；</span><br></pre></td></tr></table></figure>

<h4 id="【14】在公有类中使用访问方法而非公有域"><a href="#【14】在公有类中使用访问方法而非公有域" class="headerlink" title="【14】在公有类中使用访问方法而非公有域"></a>【14】在公有类中使用访问方法而非公有域</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Point &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> x；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> y；</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x，<span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.x = x；</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.y = y；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> x；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> y；</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公有类永远都不应该暴露可变的域。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>《设计原本》</title>
    <url>/2019/11/23/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E6%9C%AC/</url>
    <content><![CDATA[<p>【1】什么是设计？Dorothy Sayers(英国作家和戏剧家)说设计有三个阶段：概念构造的形成，在真实媒质上的实现，与真正用户的交互。</p>
<p>【2】新思想来自于将一门艺术中的领悟联系并应用到另一门艺术中，经理若干次这样的经历而有所悟，脑海里自然就孕育出了“新思想”。——培根</p>
<a id="more"></a>

<p>【3】给设计者的六点建议：</p>
<p>   a.专心研究以前设计者的工作，看看他们如何解决问题。</p>
<p>   b.尝试弄明白他们为什么做出那样的设计决定，这是对你自己最有启发性的问题。</p>
<p>   c.仔细研究以前设计者的风格。最好的方式是尝试用他们的一些风格勾画设计草图。</p>
<p>   d.保存一本“草图本”，将您的想法、设计和局部设计记录下来，不论使用何种媒质</p>
<p>   e.在开始设计时，写下您对用户和使用方式的假定。</p>
<p>   f.设计、设计、设计！</p>
<p>【4】哪些领域的研究将有助于毕业生变成卓越的软件设计师？</p>
<p>   a.算法和数据结构是重要的基础课程。</p>
<p>   b.计算机硬件架构。</p>
<p>   c.应用领域，特别是商业数据处理、数据库技术和数据挖掘。</p>
<p>   d.心理学，特别是直觉心理学，因为用户是最重要的。</p>
<p>【5】对于大多数的创作者来说，构思的不完整性和不一致性只有到了实现的时候才变得明显起来。因此，记录、试验和“解决”成为了理论家们的关键原则。</p>
<p>【6】设计中最困难的部分在于决定要设计什么，而设计师的主要任务乃是帮助客户发现他们想要的设计。</p>
<p>【7】快速原型是一种进行精准的需求配置的必要工具。不仅整个设计过程是迭代的，就连设计目标的设定过程也是迭代的。</p>
<p>【8】研习设计史的最有利的原因是去了解怎么样的设计方案是行不通的以及为什么这些设计方案行不通。（前世之事，后事之师？！）</p>
<p>【9】我们都是围绕着约束来做设计的，该过程要求对于设计空间中少有人问津的角落有着很多创新和探索的精神，这是设计之乐的部分所在，也是设计之难的大部分所在。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>《架构之美》</title>
    <url>/2019/11/23/%E6%9E%B6%E6%9E%84%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<p>【1】形式永远服从功能。</p>
<p>【2】好的架构的生成：</p>
<p>​    &lt;1&gt;确实进行有意为之的前端设计。</p>
<p>​    &lt;2&gt;设计者的素质和经验。</p>
<p>​    &lt;3&gt;在开发过程中，保持清晰的设计观点。</p>
<a id="more"></a>

<p>​    &lt;4&gt;授权团队负责软件的整体设计，而团队也承担起这一责任。</p>
<p>​    &lt;5&gt;不要害怕改变设计：没有什么是一成不变的。</p>
<p>​    &lt;6&gt;让合适的人加入到团队中，包括设计者、程序员和经理，确保开发团队的规模合适。</p>
<p>确保他们具有健康的工作关系，应为这些关系不可避免地影响代码的结构。</p>
<p>​    &lt;7&gt;在合适的时候做出设计决定，当你知道所有必要的信息时再做决定。延迟那些暂时不</p>
<p>能做出的决定。</p>
<p>​    &lt;8&gt;好的项目管理，以及合适的最后期限。</p>
<p>【3】新芯片的设计目标不是将一件事做得更快，而是同时做多件事。如果在芯片上运行的</p>
<p>多项任务实际上可以同时执行，那么在芯片层面上引入并发执行将带来更好的总体性能。</p>
<p>【4】关于数据传输：快重试与慢重试的交叉使用。快重试是指客户端发送文件，服务器接收</p>
<p>文件后返回状态码，客户端接收到的状态码如果不是OK则立即重新传输文件，最多重传3次；</p>
<p>慢重试是指如果3次重传返回的状态码依旧是FAIL，则将任务放在失败重传序列，序列将以20</p>
<p>分钟为间隔来进行新一轮的重传操作，直到文件传输完毕。当然在进行传输时需要设置超时时</p>
<p>间。</p>
<p>【5】面向资源的架构方法很优雅的实现了一些折中。一方面，对于传统的方法来说，这些方法</p>
<p>可能看起来有些奇怪，从而没有尝试过。如果人们关心自己的简历，就会希望停留在尝试过的、</p>
<p>真正在使用的方法。另一方面，对于那些研究过Web和它的基本组成模块的人来说，它很有意义，</p>
<p>代表人们设想和实现过的最大、最成功的网络软件架构。</p>
<p>【6】Facebook：数据隐私层；跨语言的进程间通信（IPC）系统Thrift;</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>《人月神话》</title>
    <url>/2019/11/23/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/</url>
    <content><![CDATA[<p>【1】由一个人来进行问题的分解，其他人给予他所需要的支持，以提高效率和生产力。</p>
<p>【2】系统的 体系结构（architecture） 指的是完整和详细的用户接口说明。</p>
<p>对于计算机，它是编程手册；对于编译器，它是语言手册；</p>
<p>对于控制程序，它是语言和函数调用手册；</p>
<a id="more"></a>

<p>对于整个系统，它是用户要完成自己全部工作所需参考的手册的集合。</p>
<p>【3】想要成功，结构师必须：</p>
<p>  a.牢记是开发人员承担创造性和发明性的实现责任， 所以结构师只能建议， 而不能支配；</p>
<p>  b.时刻准备着为所指定的说明建议 一种 实现的方法， 同样准备接受其他任何能达到目标的方法；</p>
<p>  c.对上述的建议保持低调和平静；</p>
<p>  d.准备放弃坚持所作的改进建议；</p>
<p>【4】一个可以开阔结构师眼界的准则是为每个小功能分配一个值：每次改进，功能 x 不超过 m字节的内存和 n微秒。这些值会在一开始作为决策的向导， 在物理实现期间充当指南和对所有人的警示。</p>
<p>【5】一个规格说明作者必须在仔细定义规定什么的同时，定义未规定什么。</p>
<p>【6】如同前面所示，形式化定义可以是一种设计实现。反之，设计实现也可以作为一种形式化定义的方法。当制造第一批兼容性的计算机时，我们使用的正是上述技术：新的机器同原有的机器一致。如果手册有一些模糊的地方？“问一问机器！ ”——设计一段程序来得到其行为，新机器必须按照上述结果运行。</p>
<p>【7】认识到编程需要技术积累，需要开发很多公共单元构件。每个项目要有能用于队列、搜索和排序的例程或者宏库。对于每项功能，库至少应该有两个程序实现：运行速度较快和短小精炼的。 上述的公共库开发是一件重要的实现工作， 它可以与系统设计工作并行进行。</p>
<p>【8】由于缺乏空间而绞尽脑汁的编程人员，常常能通过从自己的代码中挣脱出来，回顾、分析实际情况，仔细思考程序的数据，最终获得非常好的结果。实际上，数据的表现形式 是编程的根本。</p>
<p>【9】不变只是愿望，变化才是永恒。——SWIFT</p>
<p>普遍的做法是，选择一种方法，试试看；如果失败了，没关系，再试试别的。不管怎么样，重要的是先去尝试。——富兰克林 D.罗斯福</p>
<p>【10】每个产品都应该有数字版本号，每个版本都应该有自己的日程表和冻结日期，在此之后的变更属于下一个版本的范畴。</p>
<p>【11】自顶向下的设计：开始是勾画出能得到主要结果的，但比较粗略的任务定义和大概的解决方案。然后，对该定义和方案进行细致的检查，以判断结果与期望之间的差距。同时，将上述步骤的解决方案，在更细的步骤中进行分解，每一项任务定义的精化变成了解决方案中算法的精化，后者还可能伴随着数据表达方式的精化。</p>
<p>【12】增量模式开发系统：首先系统应该能够运行，即使未完成任何有用功能，只能正确调用一系列伪子系统。接着，系统一点一点被充实，子系统轮流被开发，或者是在更低的层次调用程序、模块、子系统的占位符（伪程序）等。</p>
<p>【13】向软件系统增加必要的复杂性：</p>
<p>​    a.层次化，通过分层的模块或者对象。</p>
<p>​    b.增量化，从而系统可以持续地运行。</p>
<p>【14】精炼、 充分和快速的程序。 往往是 战略性 突破的结果， 而不仅仅技巧上的提高。这种突破常常是一种新型算法。更普遍的是， 战略上突破常来自于数据或表的重新表达。 数据的表现形式是编程的根本。</p>
<p>【15】对于大多数项目，第一个开发的系统并不合用。它可能太慢、太大，而且难以使用，或者三者兼而有之。系统的丢弃和重新设计可以一步完成， 也可以一块块地实现。 这是个 必须完成的步骤。</p>
<p>【16】对于大型项目， 一个对里程碑报告进行维护的 计划和控制（Plan and Control ）小组是非常可贵的。</p>
<p>【17】每一份发布的程序拷贝应该包括一些测试用例，其中一部分用于校验输入数据，一部分用于边界输入数据，另一部分用于无效的输入数据。</p>
<p>【18】增量开发模型：首先设计框架，再向框架内添加内容，保证在每一个设计阶段都有可运行的系统输出，从空的框架一步步到添加了各个功能的完整系统。</p>
<p>【19】设计类似一棵树的技巧是将那些变化可能性较小的设计决策放置在树的根部。这样的设计使得模块的重用最大化。更重要的是，可以延伸相同的策略，使它不但可以包括发布产品，而且还包括以增量开发策略创建的后续中间版本。这样，产品可以通过它的中间阶段，以最低限度的回溯代价增长。</p>
<p>【20】“从第一个里程碑开始构建”的微软流程和快速原型之间的差别是什么？功能。 第一个里程碑产品可能不包含足够的功能使任何人对它产生兴趣，而可发布产品和定义中的一样，在完整性上——配备了一系列实用的功能集，在质量上——它可以健壮地运行。</p>
<p>【21】人力（人）和时间（月）之间的平衡远不是线性关系，使用人月作为生产率的衡量标准实际是一个神话：</p>
<p>​    a.第一次发布的成本最优进度时间，T = 2. 5（M M ）1/ 3 。即，月单位的最优时间是估计工作量（人月）的立方根，估计工作量则由规</p>
<p>​    模估计和模型中的其他因子导出。最优人员配备曲线是由推导得出的。</p>
<p>​    b.当计划进度比最优进度长时， 成本曲线会缓慢攀升。 时间越充裕， 花的时间也越长。</p>
<p>​    c.当计划进度比最优进度短时，成本曲线急剧升高。</p>
<p>​    d.无论安排多少人手， 几乎没有任何项目能够在少于 3/ 4的最优时间内获得成功！</p>
<p>【22】对于项目的成功而言，项目人员的素质、人员的组织管理是比使用的工具或采用的技术方法更重要的因素。</p>
<p>【23】如果人们认同我在文中多处提到的观点——创造力来自于个人，而不是组织架构或者开发过程， 那么项目管理面对的中心问题是如何设计架构和流程， 来提高而不是压制主动性和创造力。</p>
<p>【24】通过权力委派，中心的权威实际上是得到了加强；从整体而言，组织机构实际上更加融洽和繁荣。</p>
<p>【25】“大多数成功的第 4 代语言是以选项和参数方式系统化某个应用领域的结果。 ”这些第 4 代语言最普遍的情况是带有查询语言、数据库以及通讯软件包的应用生成程序。</p>
<p>【26】软件工程的一些特殊问题:</p>
<p>​    a.如何把一系列程序设计和构建成 系统。</p>
<p>​    b.如何把程序或者系统设计成健壮的、经过测试的、文档化的、可支持的产品。</p>
<p>​    c.如何维持对大量的 复杂性 的控制。</p>
<p>【27】软件工程这个复杂的行业需要：进行持续的发展；学习使用更大的要素来开发；新工具的最佳使用；经论证的管理方法的最佳应用；良好判断的自由发挥；以及能够使我们认识到自己不足和容易犯错的——上帝所赐予的谦卑。</p>
<p>【28】乍一看,用任何规则或者原理来约束创造性思维的想法是一种阻碍, 而不是帮助, 但实际情况中完全不是这样. 规范的思维实际上是促进而不是阻碍了灵感的产生。</p>
<p>【29】Brooks《 人月神话 》的核心论点：由于人力的划分，大型项目遭遇的管理问题与小型项目的不同；因此，产品的概念完整性很关键；取得这种统一性是很困难，但并不是不可能的。 </p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>WING-剧情大纲</title>
    <url>/2019/11/23/wing3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>wing</tag>
      </tags>
  </entry>
  <entry>
    <title>WING-世界观</title>
    <url>/2019/11/23/wing2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>wing</tag>
      </tags>
  </entry>
  <entry>
    <title>WING-人设</title>
    <url>/2019/11/19/wing1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>wing</tag>
      </tags>
  </entry>
  <entry>
    <title>贪婪算法介绍</title>
    <url>/2019/11/18/greedy/</url>
    <content><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a><strong>算法简介</strong></h2><p><strong>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。</strong></p>
<p><strong>贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。</strong></p>
<a id="more"></a>

<ul>
<li>贪婪算法并<strong>没有固定的算法解决框架</strong>，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。</li>
<li>必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。</li>
</ul>
<p>比如前边介绍的最短路径问题(<a href="https://www.jianshu.com/p/78e674161e54" target="_blank" rel="noopener">广度优先</a>、<a href="https://www.jianshu.com/p/b805e9d1eb5c" target="_blank" rel="noopener">狄克斯特拉</a>)都属于贪婪算法，只是在其问题策略的选择上，刚好可以得到最优解。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><strong>基本思路</strong></h2><p>其基本的解题思路为：</p>
<p>1.建立数学模型来描述问题</p>
<p>2.把求解的问题分成若干个子问题</p>
<p>3.对每一子问题求解，得到子问题的局部最优解</p>
<p>4.把子问题对应的局部最优解合成原来整个问题的一个近似最优解</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h2><p>这边的案例来自”算法图解”一书</p>
<h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a><strong>案例一</strong></h3><p>区间调度问题:</p>
<p>假设有如下课程，希望尽可能多的将课程安排在一间教室里：</p>
<table>
<thead>
<tr>
<th>课程</th>
<th>开始时间</th>
<th>结束时间</th>
</tr>
</thead>
<tbody><tr>
<td>美术</td>
<td>9AM</td>
<td>10AM</td>
</tr>
<tr>
<td>英语</td>
<td>9:30AM</td>
<td>10:30AM</td>
</tr>
<tr>
<td>数学</td>
<td>10AM</td>
<td>11AM</td>
</tr>
<tr>
<td>计算机</td>
<td>10:30AM</td>
<td>11:30AM</td>
</tr>
<tr>
<td>音乐</td>
<td>11AM</td>
<td>12PM</td>
</tr>
</tbody></table>
<p>这个问题看似要思考很多，实际上算法很简单:</p>
<p>1.选择<strong>结束最早</strong>的课，便是要在这教室上课的第一节课</p>
<p>2.接下来，选择第一堂课结束后才开始的课，并且结束最早的课，这将是第二节在教室上的课。</p>
<p><img src="../../../../asserts/4b066988419.webp" alt="img"></p>
<p>重复这样做就能找出答案，这边的选择策略便是结束最早且和上一节课不冲突的课进行排序，因为每次都选择结束最早的，所以留给后面的时间也就越多，自然就能排下越多的课了。</p>
<p>每一节课的选择都是策略内的局部最优解(留给后面的时间最多)，所以最终的结果也是近似最优解(这个案例上就是最优解)。</p>
<p>(该案例的代码实现，就是一个简单的时间遍历比较过程)</p>
<h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a><strong>案例二</strong></h3><p>背包问题：有一个背包，容量为35磅 ， 现有如下物品</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>重量</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>吉他</td>
<td>15</td>
<td>1500</td>
</tr>
<tr>
<td>音响</td>
<td>30</td>
<td>3000</td>
</tr>
<tr>
<td>笔记本电脑</td>
<td>20</td>
<td>2000</td>
</tr>
<tr>
<td>显示器</td>
<td>29</td>
<td>2999</td>
</tr>
<tr>
<td>笔</td>
<td>1</td>
<td>200</td>
</tr>
</tbody></table>
<p>要求达到的目标为装入的背包的总价值最大，并且重量不超出。</p>
<p>方便计算所以只有3个物品，实际情况可能是成千上万。</p>
<p>同上使用贪婪算法，因为要总价值最大，所以每次每次都装入最贵的,然后在装入下一个最贵的，选择结果如下：</p>
<p>选择: 音响 + 笔，总价值 3000 + 200 = 3200</p>
<p>并不是最优解: 吉他 + 笔记本电脑, 总价值 1500 + 2000 = 3500</p>
<p>当然选择策略有时候并不是很固定，可能是如下：</p>
<p>(1)每次挑选价值最大的,并且最终重量不超出：</p>
<p>选择: 音响 + 笔，总价值 3000 + 200 = 3200</p>
<p>(2)每次挑选重量最大的,并且最终重量不超出(可能如果要求装入最大的重量才会优先考虑)：</p>
<p>选择: 音响 + 笔，总价值 3000 + 200 = 3200</p>
<p>(3)每次挑选单位价值最大的(价格/重量),并且最终重量不超出：</p>
<p>选择: 笔+ 显示器，总价值 200 + 2999 = 3199</p>
<p>如上最终的结果并不是最优解，在这个案例中贪婪算法并无法得出最优解，只能得到近似最优解,也算是该算法的<strong>局限性之一</strong>。该类问题中需要得到最优解的话可以采取动态规划算法(后续更新，也可以关注我的公众号第一时间获取更新信息)。</p>
<h3 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a><strong>案例三</strong></h3><p>集合覆盖问题:</p>
<p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。</p>
<p>如何选择最少的广播台，让所有的地区都可以接收到信号。</p>
<table>
<thead>
<tr>
<th>广播台</th>
<th>覆盖地区</th>
</tr>
</thead>
<tbody><tr>
<td>K1</td>
<td>ID,NV,UT</td>
</tr>
<tr>
<td>K2</td>
<td>WA,ID,MT</td>
</tr>
<tr>
<td>K3</td>
<td>OR,NV,CA</td>
</tr>
<tr>
<td>K4</td>
<td>NV,UT</td>
</tr>
<tr>
<td>K5</td>
<td>CA,AZ</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><img src="../../../../asserts/ce3bfe6cde9.webp" alt="img"></p>
<p>如何找出覆盖所有地区的广播台的集合呢，听起来容易，实现起来很复杂，使用穷举法实现：</p>
<p>(1) 列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2ⁿ个【由组合及二项式定理得出：C(n,1)+C(n,2)+C(n,3)+…+C(n,n) = 2^n】</p>
<p>(2) 在这些集合中，选出覆盖全部地区的最小的集合，假设n不在，但是当n非常大的时候，假设每秒可以计算10个子集</p>
<table>
<thead>
<tr>
<th>广播台数量n</th>
<th>子集总数2ⁿ</th>
<th>需要的时间</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>32</td>
<td>3.2秒</td>
</tr>
<tr>
<td>10</td>
<td>1024</td>
<td>102.4秒</td>
</tr>
<tr>
<td>32</td>
<td>4294967296</td>
<td>13.6年</td>
</tr>
<tr>
<td>100</td>
<td>1.26*100³º</td>
<td>4x10²³年</td>
</tr>
</tbody></table>
<p>目前并没有算法可以快速计算得到准备的值，</p>
<p>而使用贪婪算法，则可以得到非常接近的解，并且效率高:</p>
<p>选择策略上，因为需要覆盖全部地区的最小集合:</p>
<p>(1) 选出一个广播台，即它覆盖了最多未覆盖的地区即便包含一些已覆盖的地区也没关系</p>
<p>(2) 重复第一步直到覆盖了全部的地区</p>
<p>这是一种近似算法（approximation algorithm，贪婪算法的一种）。在获取到精确的最优解需要的时间太长时，便可以使用近似算法，判断近似算法的优劣标准如下:</p>
<ul>
<li>速度有多快</li>
<li>得到的近似解与最优解的接近程度</li>
</ul>
<p>在本例中贪婪算法是个不错的选择，不仅运行速度快，本例运行时间O(n²),最坏的情况，假设n个广播台，每个广播台就覆盖1个地区,n个地区，总计需要查询n*n=O(n²),实现可查看后面的java代码实现</p>
<table>
<thead>
<tr>
<th>广播台数量n</th>
<th>子集总数2ⁿ</th>
<th>穷举需要时间</th>
<th>贪婪算法</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>32</td>
<td>3.2秒</td>
<td>2.5秒</td>
</tr>
<tr>
<td>10</td>
<td>32</td>
<td>102.4秒</td>
<td>10秒</td>
</tr>
<tr>
<td>32</td>
<td>32</td>
<td>13.6年</td>
<td>102.4秒</td>
</tr>
<tr>
<td>100</td>
<td>32</td>
<td>4x10²³年</td>
<td>1000秒</td>
</tr>
</tbody></table>
<p>此时算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区，可能不是预期中的K2, K3,K4,K5(也许预期中的更便宜，更便于实施等等)</p>
<h2 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a><strong>NP完全问题</strong></h2><h3 id="案例四"><a href="#案例四" class="headerlink" title="案例四"></a><strong>案例四</strong></h3><p>旅行商问题</p>
<p>假设有旅行商需要从下面三个城市的某一个城市出发，如何规划路线获取行程的最短路径。</p>
<p><img src="../../../../asserts/1505a09f64e.webp" alt="img"></p>
<p>存在3！(阶乘)=6种可能情况:</p>
<p>A-&gt;B-&gt;C A-&gt;C-&gt;B B-&gt;A-&gt;C B-&gt;C-&gt;A C-&gt;A-&gt;B C-&gt;B-&gt;A </p>
<p>这边和之前求最短路径的算法(广度搜索、狄克斯特拉、贝尔曼-福特)，最大的差别是没有固定源点(起点),，每一个节点都可能是源点，并且需要经过每一个节点，所以若穷举法则不得不找出每一种可能并进行比较。</p>
<p>当城市数量为n,则可能性为n!，假设每秒处理判断一个路线</p>
<table>
<thead>
<tr>
<th>数量n</th>
<th>总数n!</th>
<th>穷举需要时间</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>120</td>
<td>120秒</td>
</tr>
<tr>
<td>10</td>
<td>32</td>
<td>42天</td>
</tr>
</tbody></table>
<p>而使用贪婪算法，随机选择从一个城市出发，比如A，每次选择从最近的还没去过的城市出发,则可以得到近似最优解。</p>
<p>第一次比较n-1个城市</p>
<p>第二次比较n-2个城市</p>
<p>…</p>
<p>第n-1次比较1个城市</p>
<p>第n次不存在需要比较的了个</p>
<p>0+1+2+3+..+(n-1) ≈ O(n²/2)</p>
<table>
<thead>
<tr>
<th>数量n</th>
<th>总数n!</th>
<th>穷举需要时间</th>
<th>贪婪需要时间</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>120</td>
<td>120秒</td>
<td>12.5秒</td>
</tr>
<tr>
<td>10</td>
<td>32</td>
<td>42天</td>
<td>50秒</td>
</tr>
</tbody></table>
<p>类似上述集合覆盖问题、旅行商问题，都属于NP完全问题，在数学领域上并没有快速得到最优解的方案，贪婪算法是最适合处理这类问题的了。</p>
<h2 id="如何判断是NP完全问题的"><a href="#如何判断是NP完全问题的" class="headerlink" title="如何判断是NP完全问题的:"></a><strong>如何判断是NP完全问题的:</strong></h2><p>1.元素较少时，一般运行速度很快，但随着元素数量增多，速度会变得非常慢</p>
<p>2.涉及到需要计算比较”所有的组合”情况的通常是NP完全问题</p>
<p>3.无法分割成小问题，必须考虑各种可能的情况。这可能是NP完全问题</p>
<p>4.如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题</p>
<p>5.如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题</p>
<p>6.如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>1.贪婪算法可以寻找局部最优解，并尝试与这种方式获得全局最优解</p>
<p>2.得到的可能是近似最优解，但也可能便是最优解(区间调度问题，最短路径问题(<a href="https://juejin.im/post/5b64630ae51d45190b61d79a" target="_blank" rel="noopener">广度优先</a>、<a href="https://juejin.im/post/5b7000ab6fb9a009bd03cb79" target="_blank" rel="noopener">狄克斯特拉</a>))</p>
<p>3.对于完全NP问题，目前并没有快速得到最优解的解决方案</p>
<p>4.面临NP完全问题，最佳的做法就是使用近似算法</p>
<p>5.贪婪算法(近似算法)在大部分情况下易于实现，并且效率不错</p>
<h2 id="JAVA-实现"><a href="#JAVA-实现" class="headerlink" title="JAVA 实现"></a><strong>JAVA 实现</strong></h2><p>贪婪算法需要根据具体问题，选择对应的策略来实现，所以这边只取集合覆盖问题做个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 贪婪算法 - 集合覆盖问题 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment">* */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greedy</span> </span>&#123;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        </span><br><span class="line">        <span class="comment">//初始化广播台信息        </span></span><br><span class="line">        HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span>  </span><br><span class="line">            HashMap&lt;String,HashSet&lt;String&gt;&gt;();        </span><br><span class="line">        broadcasts.put(<span class="string">"K1"</span>,  </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"ID"</span>,<span class="string">"NV"</span>,<span class="string">"UT"</span>&#125;)));  </span><br><span class="line">        broadcasts.put(<span class="string">"K2"</span>, </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"WA"</span>,<span class="string">"ID"</span>,<span class="string">"MT"</span>&#125;)));  </span><br><span class="line">        broadcasts.put(<span class="string">"K3"</span>, </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"OR"</span>,<span class="string">"NV"</span>,<span class="string">"CA"</span>&#125;)));  </span><br><span class="line">        broadcasts.put(<span class="string">"K4"</span>, </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"NV"</span>,<span class="string">"UT"</span>&#125;)));  </span><br><span class="line">        broadcasts.put(<span class="string">"K5"</span>, </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"CA"</span>,<span class="string">"AZ"</span>&#125;)));  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需要覆盖的全部地区        </span></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[]  </span><br><span class="line">             &#123;<span class="string">"ID"</span>,<span class="string">"NV"</span>,<span class="string">"UT"</span>,<span class="string">"WA"</span>,<span class="string">"MT"</span>,<span class="string">"OR"</span>,<span class="string">"CA"</span>,<span class="string">"AZ"</span>&#125;));   </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//所选择的广播台列表        </span></span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;String&gt;();        </span><br><span class="line">        String maxKey = <span class="keyword">null</span>;        </span><br><span class="line">        <span class="keyword">while</span>(allAreas.size()!=<span class="number">0</span>) &#123;            </span><br><span class="line">            maxKey = <span class="keyword">null</span>;            </span><br><span class="line">            <span class="keyword">for</span>(String key : broadcasts.keySet()) &#123;  </span><br><span class="line">                tempSet.clear();  </span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);  </span><br><span class="line">                tempSet.addAll(areas);  </span><br><span class="line">                                                   </span><br><span class="line">                <span class="comment">//求出2个集合的交集，此时tempSet会被赋值为交集的内容，所以使用临时变量  </span></span><br><span class="line">                tempSet.retainAll(allAreas);                </span><br><span class="line">                <span class="comment">//如果该集合包含的地区数量比原本的集合多                </span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size()&gt;<span class="number">0</span> &amp;&amp; (maxKey == <span class="keyword">null</span> || tempSet.size() &gt;  </span><br><span class="line">                                         broadcasts.get(maxKey).size())) &#123;                    </span><br><span class="line">                    maxKey = key;                </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;                        </span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);  </span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.print(<span class="string">"selects:"</span> + selects);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完main方法打印信息如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selects:[K1, K2, K3, K5]</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html" target="_blank" rel="noopener">https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/fede80bad3f1" target="_blank" rel="noopener">https://www.jianshu.com/p/fede80bad3f1</a></p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>SHA(安全散列算法)简单实现</title>
    <url>/2019/11/18/sha/</url>
    <content><![CDATA[<p>摘要算法：SHA 及 Java 实现样例</p>
<p>SHA = 安全散列算法（Secure Hash Algorithm）。</p>
<p>SHA 与 MD5 类似，都是单向不可逆散列函数，用于计算消息摘要，生成消息数字签名（指纹）。</p>
<a id="more"></a>

<p>Algorithm    散列值长度（单位比特）</p>
<table>
<thead>
<tr>
<th>SHA-1</th>
<th>160</th>
</tr>
</thead>
<tbody><tr>
<td>SHA-224</td>
<td>224</td>
</tr>
<tr>
<td>SHA-256</td>
<td>256</td>
</tr>
<tr>
<td>SHA-384</td>
<td>384</td>
</tr>
<tr>
<td>SHA-512</td>
<td>512</td>
</tr>
</tbody></table>
<p>Java 实现样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySHA</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub         </span></span><br><span class="line">        String msg = <span class="string">"0123456789abcdef"</span>;         </span><br><span class="line">        MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA"</span>);  </span><br><span class="line">        sha.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []shaBin = sha.digest();            </span><br><span class="line">        printBytes(shaBin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha1 = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);  </span><br><span class="line">        sha1.update(msg.getBytes());            </span><br><span class="line">        printBytes(sha1Bin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha224 = MessageDigest.getInstance(<span class="string">"SHA-224"</span>);  </span><br><span class="line">        sha224.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []sha224Bin = sha224.digest();            </span><br><span class="line">        printBytes(sha224Bin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha256 = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);  </span><br><span class="line">        sha256.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []sha256Bin = sha256.digest();            </span><br><span class="line">        printBytes(sha256Bin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha384 = MessageDigest.getInstance(<span class="string">"SHA-384"</span>);  </span><br><span class="line">        sha384.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []sha384Bin = sha384.digest();            </span><br><span class="line">        printBytes(sha384Bin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha512 = MessageDigest.getInstance(<span class="string">"SHA-512"</span>);  </span><br><span class="line">        sha512.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []sha512Bin = sha512.digest();            </span><br><span class="line">        printBytes(sha512Bin);        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**     </span></span><br><span class="line"><span class="comment">* 十六进制打印字节数组     </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> b byte[]     </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBytes</span><span class="params">(<span class="keyword">byte</span>[] b)</span>    </span>&#123;        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)        &#123;            </span><br><span class="line">        System.out.printf(<span class="string">"%02X"</span>, b[i]);        </span><br><span class="line">    &#125;        </span><br><span class="line">    System.out.println();    </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注：散列值都是按照十六进制大写字母编码表示</p>
<p>很多人肯定会出来反驳，加密简单的123456可以在某些解密网站直接解密出来。</p>
<p>在这样的情况下，我们可以尝试在字符串追加其他文字如<strong>yangzhangyin</strong>，实际如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger; </span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SHAEncryption</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptSHA(<span class="keyword">byte</span>[] data, String shaN) </span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;         </span><br><span class="line">        MessageDigest sha = MessageDigest.getInstance(shaN);  </span><br><span class="line">        sha.update(data);        </span><br><span class="line">        <span class="keyword">return</span> sha.digest();     </span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptFlychordPwd</span><span class="params">(String str)</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">byte</span>[] outputData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];            </span><br><span class="line">        <span class="keyword">try</span> &#123;                </span><br><span class="line">            outputData =  encryptSHA((str+<span class="string">"yangzhangyin"</span>).getBytes(), </span><br><span class="line">                                     <span class="string">"SHA-256"</span>);                </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="number">1</span>, outputData).toString(<span class="number">16</span>);            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;                </span><br><span class="line">            e.printStackTrace();            </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;        </span><br><span class="line">    &#125;                </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//加密123456</span></span><br><span class="line">        System.out.println(ss.encryptFlychordPwd(<span class="string">"123456"</span>));          </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就解决了简单密码被解密的问题啦。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Diffie-Hellman（秘钥协商算法）介绍</title>
    <url>/2019/11/18/diffie-hellman/</url>
    <content><![CDATA[<p><strong>一、概述</strong></p>
<p>Diffie-Hellman密钥协商算法主要解决秘钥配送问题，本身并非用来加密用的；该算法其背后有对应数学理论做支撑，简单来讲就是构造一个复杂的计算难题，使得对该问题的求解在现实的时间内无法快速有效的求解（<em>computationally infeasible</em> ）。</p>
<a id="more"></a>

<p>理解Diffie-Hellman密钥协商的原理并不困难，只需要一点数论方面的知识既可以理解，主要会用到简单的模算术运算、本原根、费马小定理、离散对数等基础数论的知识。在<a href="http://www.cnblogs.com/qcblog/p/8976017.html" target="_blank" rel="noopener"><strong>现代密码学中的基础数论知识梳理</strong></a>中已经对这些知识做了必要的总结。</p>
<p> <strong>二、从何而来</strong></p>
<p>DH密钥协商算法在1976年在Whitfield Diffie和Martin Hellman两人合著的论文<strong>New Directions in Cryptography</strong>（Section Ⅲ PUBLIC KEY CRYPTOGRAPHY）中被作为一种公开秘钥分发系统(<em>public key distribution system</em>)被提出来。原文的叙述过程比较简单，但基本阐述了算法的原理以及其可行性。</p>
<p>在该论文中实际上提出了一些在当时很有创新性的思想。原论文重点讨论两个话题：</p>
<p>（1）在公网通道上如何进行安全的秘钥分派。</p>
<p>（2）认证（可以细分为消息认证和用户认证）。</p>
<p>为了解决第一个问题，原文提出两种方法：公钥加密系统(<em>public key cryptosystem</em>)和秘钥分发系统(<em>public key distribution system</em>)。对于公钥加密系统，原文只是勾画了一种比较抽象的公钥加密系统的概念模型，重点是加解密采用不同的秘钥，并总结了该系统应该满足的一些特性，相当于是一种思想实验，并没有给出具体的算法实现途径，但这在当时应该来说已经足够吸引人。后来RSA三人组（Ron Rivest、Adi Shamir 和 Leonard Adleman）受此启发，经过许多轮失败的尝试后，于第二年在论文<strong>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</strong>中提出了切实可行且很具体的公钥加密算法–RSA公钥加密算法。而对于秘钥分发系统，就是本文的DH秘钥协商算法。</p>
<p>为了解决第二个问题，原文通过单向函数（one-way function）来解决，这就是单向认证的问题。另外作者还讨论了这些密码学问题之间的关联性以及如何相互转化。比如一个安全的密码系统（可以防御明文攻击）可以用来生成一个的单向函数、公钥加密系统可以用来作为单向认证、陷门密码系统可以用来生成一个公钥加密系统。数学难题的计算复杂度被当成一种保障密码学安全问题的有效工具被利用起来，这一重要思想贯穿现代密码学的许多加密算法。</p>
<p><strong>三、算法流程及原理</strong></p>
<p>按照惯例，以Alice和Bob这两个密码学中的网红为角色，述阐DH算法的流程。</p>
<p>假设Alice需要与Bob协商一个秘钥（秘钥本质上就是一个比特序列，从计算的角度看就是一个大数）。</p>
<p>1）首先Alice与Bob共享一个素数p以及该素数p的本原根g（geneator），当然这里有2⩽g⩽p−1。这两个数是可以不经过加密地由一方发送到另一方，至于谁发送给并不重要，其结果只要保证双方都得知p和g即可。</p>
<p><img src="../../../../asserts/5-1377258439.png" alt="img"></p>
<p>2）然后Alice产生一个私有的随机数A，满足1⩽A⩽p−1，然后计算gAmodp=Ya，将结果Ya通过公网发送给Bob；与此同时，Bob也产生一个私有的随机数B，满足1⩽B⩽p−1，计算gBmodp=Yb，将结果Yb通过公网发送给Alice。</p>
<p><img src="../../../../asserts/9-1497141203.png" alt="img"></p>
<p>3）此时Alice知道的信息有p,g,A,Ya，其中数字A是Alice私有的，只有她自己知道，别人不可能知道，其他三个信息都是别人有可能知道的；Bob知道的信息有p,g,B,Yb，其中数字B是Bob私有的，只有他自己知道，别人不可能知道，其他都是别人有可能知道的。</p>
<p>到目前为止，Alice和Bob之间的秘钥协商结束。</p>
<p>Alice通过计算Ka=(Yb)Amodp得到秘钥Ka，同理，Bob通过计算Kb=(Ya)Bmodp得到秘钥Kb，此时可以证明，必然满足Ka=Kb。因此双方经过协商后得到了相同的秘钥，达成秘钥协商的目的。</p>
<p> 证明：</p>
<p>对于Alice有：</p>
<p>Ka=(Yb)Amodp=(gBmodp)Amodp=gB×Amodp</p>
<p>对于Bob有：</p>
<p>Kb=(Ya)Bmodp=(gAmodp)Bmodp=gA×Bmodp</p>
<p>可见，Alice和Bob生成秘钥时其实是进行相同的运算过程，因此必然有Ka=Kb。”相同的运算过程”是双方能够进行秘钥协商的本质原因，类似的利用椭圆曲线进行秘钥协商也是与之相同的原理。</p>
<p>更严密地考虑，A和B不应该选择p−1，也就是说只能在集合{1,2,3,…,p−2}中选择。这是因为如果选择p−1，那么由费马小定理可知，情况就退化成了gp−1≡1(modp)的情况，对秘钥协商的机密性构成威胁。</p>
<p>所以总结起来，整个流程串起来大概就是这样：</p>
<p><img src="../../../../asserts/8-2035633054.png" alt="img"></p>
<p>那么窃听者Eve能否破解秘钥呢？首先要知道Eve能够得知哪些信息，显然Eve能够窃听到的信息只能有p,g,Ya,Yb，现在的问题是Eve能够通过以上信息计算出Ka或者Kb吗？要计算Ka或者Kb需要知道A或者B。</p>
<p>以计算A为例，Eve能根据条件gAmodp=Ya计算出A吗？实际上当p是大质数的时候，这是相当困难的，这就是离散对数问题。实际上在论文发表的当时，计算该问题的最有效的算法的时间复杂度大约是O(p–√)。也正是求解该问题在计算上的困难程度保证了DH算法的安全性。如果能够找到对数时间复杂度的算法，那么该算法即容易被攻破。</p>
<p><strong>四、一个实例</strong></p>
<p>1）假设Alice和Bob共享的p和g分别是p=17,g=3，显然这里g=3是p=17的一个本原根，实际上3,5,6,7,10,11,12,14都是17的本原根。</p>
<p>2）然后Alice选定一个私有数字，假设A=15，计算Ya=315mod17=14348907mod17=6，将6发送给Bob；同时Bob也选定一个私有的数字，假设B=13，计算Ya=313mod17=1594323mod17=12，将12发送给Alice。</p>
<p>3）Alice计算秘钥Ka=1215mod17=2147483647mod17=8，Bob计算秘钥Kb=613mod17=2147483647mod17=8。双方经过协商后，8最终成为双方的协商的秘钥。</p>
<p>实际上，当指数和模数的位数都比较大的时候，存在一种快速计算幂取模的算法叫做“反复平方算法”，实现取来也比较简单，在<strong>算法导论</strong>中第三十一章有相应的解释。</p>
<p><strong>五、存在的问题</strong></p>
<p> 是否DH秘钥协商算法就一定安全呢？应该说也不是，因为存在一种伪装者攻击（或者称为中间人攻击）能够对这种秘钥协商算法构成威胁。</p>
<p>假设秘钥协商过程中，在Alice和Bob中间有一个称为Mallory的主动攻击者，他能够截获Alice和Bob的消息并伪造假消息，考虑如下情况。</p>
<p>1）Alice和Bob已经共享一个素数p及其该素数p的本原根g，当然Mallory监听到报文也得知了这两个消息。</p>
<p>2）此时Alice计算Ya=gAmodp，然而在将Ya发送给Bob的过程中被Mallory拦截，Mallory自己选定一个随机数S，计算Ysb=gSmodp，然后将Ysb发送给了Bob。</p>
<p><img src="../../../../asserts/2-1457088379.png" alt="img"></p>
<p>3）同时Bob计算Yb=gBmodp，然而在将Yb发送给Alice的过程中被Mallory拦截，Mallory自己选定一个随机数T，计算Yta=gTmodp，然后将Yta发送给了Alice。</p>
<p><img src="../../../../asserts/82-320719224.png" alt="img"></p>
<p>由于通讯消息被替换，Alice计算出的秘钥实际上是Alice和Mallory之间协商秘钥：Kam=gA×Tmodp；Bob计算出的秘钥实际上是Bob与Mallory之间协商的秘钥：Kbm=gB×Smodp。如果之后Alice和Bob用他们计算出的秘钥加密任何信息，Mallory截获之后都能够解密得到明文，而且Mallory完全可以伪装成Alice或者Bob给对方发消息。</p>
<p><strong>六、References</strong></p>
<p>1、<a href="https://www.cis.upenn.edu/~nadiah/courses/cis800-02-f13/readings/diffie-hellman.pdf" target="_blank" rel="noopener">New Directions in Cryptography</a></p>
<p>2、密码编码学与网络安全原理与实践</p>
<p>3、图解密码技术</p>
<p>原文出处：<a href="http://www.cnblogs.com/qcblog/p/9016704.html" target="_blank" rel="noopener">http://www.cnblogs.com/qcblog/p/9016704.html</a></p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Simhash算法介绍</title>
    <url>/2019/11/18/simhash/</url>
    <content><![CDATA[<p><strong>Simhash的生成及存储</strong></p>
<p><strong>一、背景介绍</strong></p>
<p>根据 <em>Detecting Near-Duplicates for Web Crawling</em> 论文中的介绍，在互联网中有很多网页的内容是一样的，但是它们的网页元素却不是完全相同的。每个域名下的网页总会有一些自己的东西，比如广告、导航栏、网站版权之类的东西，但是对于搜索引擎来讲，只有内容部分才是有意义的，虽然网页元素不同，但是对搜索结果没有任何影响，所以在判定内容是否重复的时候，应该忽视后面的部分。当新爬取的内容和数据库中的某个网页的内容一样的时候，就称其为Near-Duplicates（重复文章）。对于重复文章，不应再执行入库操作，这种操作的优点是(A)节省带宽、(B)节省磁盘、(C)减轻服务器负荷以及(D)去除相似文章噪点干扰，提升索引的质量。</p>
<a id="more"></a>

<p>在现实中，一模一样的网页的概率是很小的，大部分的相似网页都会存在一些细节的变化，而如何进行这种判定就是一个本文要解决的一个问题。除了近似文章判定算法的难题，还有以下待解决的难点（按照80亿篇文章来考虑）：</p>
<ul>
<li>数据规模巨大，对于海量数据如何存储</li>
<li>查找速度，如何做到在毫秒级别返回检索结果</li>
</ul>
<p><strong>二、simhash介绍</strong></p>
<p>simhash是由 Charikar 在2002年提出来的，它是一种能计算文档相似度的hash算法，google用它来进行海量文本去重工作。simhash属于局部敏感型（locality sensitive hash）的一种，其主要思想是降维，将高维的特征向量转化成一个<strong>f</strong>位的指纹（fingerprint），通过算出两个指纹的海明距离（hamming distince）来确定两篇文章的相似度，海明距离越小，相似度越低（根据 <em>Detecting Near-Duplicates for Web Crawling</em> 论文中所说），一般海明距离为3就代表两篇文章相同。</p>
<p>simhash也有其局限性，在处理小于500字的短文本时，simhash的表现并不是很好，所以在使用simhash前一定要注意这个细节。</p>
<p><strong>三、simhash与hash算法的区别</strong></p>
<p>传统Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统hash算法产生的两个签名，如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。</p>
<p>　　我们主要解决的是文本相似度计算，要比较的是两个文章是否相似，当然我们降维生成了hash签名也是用于这个目的。看到这里，估计大家就明白了，即使把文章中的字符串变成 01 串，我们使用的simhash算法也还是可以用于计算相似度，而传统的hash却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。</p>
<p>通过simhash计算结果为：</p>
<p>　　1000010010101101111111100000101011010001001111100001001011001011</p>
<p>　　1000010010101101011111100000101011010001001111100001101010001011</p>
<p>通过传统hash计算为：</p>
<p>　　0001000001100110100111011011110</p>
<p>　　1010010001111111110010110011101</p>
<p>大家可以看得出来，相似的文本只有部分 01 串变化了，而普通的hash却不能做到，这个就是局部敏感哈希的魅力。</p>
<p><strong>四、simhash的生成</strong></p>
<p>simhash的生成图解如下图：</p>
<p><img src="../../../../asserts/ashgenerate.jpeg" alt="img"></p>
<p>为了更加通俗易懂，采用例子来详解simhash的生成规则。simhash的生成划分为五个步骤：<strong>分词-&gt;hash-&gt;加权-&gt;合并-&gt;降维</strong></p>
<ul>
<li>1：分词。首先，判断文本分词，形成这个文章的特征单词。然后，形成去掉噪音词的单词序列。最后，为每个分词加上权重。我们假设权重分为5个级别（1~5），比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==&gt; 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。</li>
<li>2：hash。通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101，“51区”通过hash算法计算为 101011。这样，我们的字符串就变成了一串串数字，还记得文章开头说过的吗？要把文章变为数字计算，才能提高相似度计算性能，现在是降维过程进行时。</li>
<li>3：加权。在第2步骤hash生成结果后，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。</li>
<li>4：合并。把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实的计算需要把所有单词的序列串累加。</li>
<li>5：降维。把第4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于或等于0 则记为 0。最后算出结果为：“1 0 1 0 1 1”。</li>
</ul>
<p>整个过程的流程图为：</p>
<p><img src="../../../../asserts/hashgenerate.png" alt="img"></p>
<p><strong>五、simhash分表存储策略</strong></p>
<p>在线上查询算法中，首先建立多个指纹表:T1，T2，√…，Tt。每个指纹表 Ti 关联两个未知数：一个整型pi和一个在f bit-positions上的排列πi，Ti就是对已经存在的所有指纹进行排列πi得到的有序集合。对于一个指纹f和一个整数k，算法分两个步骤：</p>
<ul>
<li>1 找到Ti中所有的前pi个bit-positions和πi（F）的前pi个bit-positions相同的指纹，假设为指纹集合F。</li>
<li>2 在F中的每一个指纹，比较其是否和πi（F）有的差异不超过k个。</li>
</ul>
<p><strong>分表存储原理</strong></p>
<p>借鉴“hashmap算法找出可以hash的key值”。因为我们使用的simhash是局部敏感哈希，这个算法的特点是：只要相似的字符串，只有个别的位数是有差别变化的。这样，我们可以推断两个相似的文本，至少有16位的simhash是一样的。</p>
<p><strong>分表存储设计</strong></p>
<p>假设f = 64 ，k=3，并且我们有80亿 = 2^34个数的网页指纹，d=34，可以有下面四种设计方法 （f：指纹位数，k：海明距离，d：将文章数量转化成2的幂次方，d就是幂值）</p>
<p>1.20个表：将64bit分为11,11,11,11,10,10六个bit块。根据排列组合，如果想从这6个块中找3个作为leading bits的话（这样才能满足|pi-d|是个小整数），一共有C(6,3)=20种找法，所以需要20个表，每个表的前三块来自不同的三个块，那么pi就有11+11+11、11+ 11+10和11+10+10三种可能了。一次嗅探平均需要检索2^(34-31)=8个指纹。</p>
<p>2.16个表：先将64bit均分成4份，然后针对每份，将剩余的48bit再均分成四份，也就是16,12,12,12,12,12五部分，很明显这种组合的可能是4*4，而pi = 28。一次嗅探平均需要检索2^(34-28)=64个指纹。</p>
<p>3.10个表：将64bit分成 13，13，13，13，12 五个bit快。根据排列组合，需要从5块中找到2个作为leading bits，共有C(5,2)=10种找法，需要10张表，而pi=25或26。一次嗅探平均需要检索2^(34-25)=512个指纹。</p>
<p>4.4个表：同理 64 等分为4份，每份16bit，从四份中找出1个leading bits，共有C(4,1)=4种找法，pi=16,一次嗅探平均需要检索2^(34-16)=256K个指纹。</p>
<p><strong>分表存储实现</strong></p>
<p><img src="../../../../asserts/simhashstore.png" alt="img"></p>
<p>存储：</p>
<p>　　1、将一个64位的simhash签名拆分成4个16位的二进制码。（图上红色的16位）</p>
<p>　　2、分别拿这4个16位二进制码查找当前对应位置上是否有元素。（放大后的16位）</p>
<p>　　3、对应位置没有元素，直接追加到链表上；对应位置有则直接追加到链表尾端。（图上的 S1 — SN）</p>
<p>　　查找：</p>
<p>　　1、将需要比较的simhash签名拆分成4个16位的二进制码。</p>
<p>　　2、分别拿着4个16位二进制码每一个去查找simhash集合对应位置上是否有元素。</p>
<p>　　3、如果有元素，则把链表拿出来顺序查找比较，直到simhash小于一定大小的值，整个过程完成。</p>
<p>　　原理：</p>
<p>　　借鉴“hashmap算法找出可以hash的key值”。因为我们使用的simhash是局部敏感哈希，这个算法的特点是：只要相似的字符串，只有个别的位数是有差别变化的。那这样我们可以推断两个相似的文本，至少有16位的simhash是一样的。具体选择16位、8位、4位，大家根据自己的数据测试选择，虽然比较的位数越小越精准，但是空间会变大。分为4个16位段的存储空间是单独simhash存储空间的4倍。之前算出5000w数据是 382 Mb，扩大4倍1.5G左右，还可以接受</p>
<p><strong>最佳分表策略</strong></p>
<p>根据 4.2节分表存储设计，给定 f,k 我们可以有很多种分表的方式，增加表的个数会减少检索时间，但是会增加内存的消耗，相反的，减少表的个数，会减少内存的压力，但是会增加检索时间。</p>
<p>根据google大量的实验，存在一个分表策略满足时间和空间的平衡点</p>
<p><img src="../../../../asserts/simhashont.png" alt="img"></p>
<p>τ=d-pi （<strong>pi计算看4.2章节，取最小pi</strong>）</p>
<p><strong>simhash存储实现(Go)</strong></p>
<p>国外有一大神用go实现了d=3和6的实现，在他的基础上我实现了d到8的扩展，源码请看<a href="https://github.com/kricen/shstorage" target="_blank" rel="noopener">https://github.com/kricen/shstorage</a></p>
<p><strong>参考文章</strong></p>
<p>论文 Detecting Near-Duplicates for Web Crawling</p>
<p><a href="http://www.cnblogs.com/maybe2030/p/5203186.html" target="_blank" rel="noopener">http://www.cnblogs.com/maybe2030/p/5203186.html</a></p>
<p>原文链接：<a href="https://kricen.github.io/2018/03/06/perday/simhash/" target="_blank" rel="noopener">https://kricen.github.io/2018/03/06/perday/simhash/</a></p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Disruptor（三）</title>
    <url>/2019/11/18/disruptor3/</url>
    <content><![CDATA[<p><strong>写入 Ringbuffer</strong></p>
<p>本文的重点是：不要让 Ring 重叠；如何通知消费者；生产者一端的批处理；以及多个生产者如何协同工作。</p>
<p>作者：Trisha 廖涵译</p>
<p>这是 Disruptor 全方位解析（end-to-end view）中缺少的一章。当心，本文非常长。但是为了让你能联系上下文阅读，我还是决定把它们写进一篇博客里。</p>
<a id="more"></a>

<p>本文的 <strong>重点</strong> 是：不要让 Ring 重叠；如何通知消费者；生产者一端的批处理；以及多个生产者如何协同工作。</p>
<p><strong>ProducerBarriers</strong></p>
<p>Disruptor 代码 给 <strong>消费者</strong> 提供了一些接口和辅助类，但是没有给写入 Ring Buffer 的 <strong>生产者</strong> 提供接口。这是因为除了你需要知道生产者之外，没有别人需要访问它。尽管如此，Ring Buffer 还是与消费端一样提供了一个 ProducerBarrier 对象，让生产者通过它来写入 Ring Buffer。</p>
<p>写入 Ring Buffer 的过程涉及到两阶段提交 (two-phase commit)。首先，你的生产者需要申请 buffer 里的下一个节点。然后，当生产者向节点写完数据，它将会调用 ProducerBarrier 的 commit 方法。</p>
<p>那么让我们首先来看看第一步。 “给我 Ring Buffer 里的下一个节点”，这句话听起来很简单。的确，从生产者角度来看它很简单：简单地调用 ProducerBarrier 的 nextEntry() 方法，这样会返回给你一个 Entry 对象，这个对象就是 Ring Buffer 的下一个节点。</p>
<p><strong>ProducerBarrier 如何防止 Ring Buffer 重叠</strong></p>
<p>在后台，由 ProducerBarrier 负责所有的交互细节来从 Ring Buffer 中找到下一个节点，然后才允许生产者向它写入数据。</p>
<p><img src="../../../../asserts/s_782643296.jpeg" alt="img"></p>
<p>（我不确定 闪闪发亮的新手写板 能否有助于提高我画图片的清晰度，但是它用起来很有意思）。</p>
<p>在这幅图中，我们假设只有一个生产者写入 Ring Buffer。过一会儿我们再处理多个生产者的复杂问题。</p>
<p><strong>ConsumerTrackingProducerBarrier</strong> 对象拥有所有正在访问 Ring Buffer 的 <strong>消费者</strong> 列 表。这看起来有点儿奇怪－我从没有期望 ProducerBarrier 了解任何有关消费端那边的事情。但是等等，这是有原因的。因为我们不想与队列“混为一谈”（队列需要追踪队列的头和尾，它们有时候会指向相同的位 置），Disruptor 由消费者负责通知它们处理到了哪个序列号，而不是 Ring Buffer。所以，如果我们想确定我们没有让 Ring Buffer 重叠，需要检查所有的消费者们都读到了哪里。</p>
<p>在上图中，有一个 <strong>消费者</strong> 顺利的读到了最大序号 12（用红色/粉色高亮）。第二个<strong>消费者</strong> 有点儿落后——可能它在做 I/O 操作之类的——它停在序号 3。因此消费者 2 在赶上消费者 1 之前要跑完整个 Ring Buffer 一圈的距离。</p>
<p>现在生产者想要写入 Ring Buffer 中序号 3 占据的节点，因为它是 Ring Buffer 当前游标的下一个节点。但是 ProducerBarrier 明白现在不能写入，因为有一个消费者正在占用它。所以，ProducerBarrier 停下来自旋 (spins)，等待，直到那个消费者离开。</p>
<p><strong>申请下一个节点</strong></p>
<p>现在可以想像消费者 2 已经处理完了一批节点，并且向前移动了它的序号。可能它挪到了序号 9（因为消费端的批处理方式，现实中我会预计它到达 12，但那样的话这个例子就不够有趣了）。</p>
<p><img src="../../../../asserts/aegbsvty487.jpeg" alt="img"></p>
<p>上图显示了当消费者 2 挪动到序号 9 时发生的情况。在这张图中我已经忽略了ConsumerBarrier，因为它没有参与这个场景。</p>
<p>ProducerBarier 会看到下一个节点——序号 3 那个已经可以用了。它会抢占这个节点上的 Entry（我还没有特别介绍 Entry 对象，基本上它是一个放写入到某个序号的 Ring Buffer 数据的桶），把下一个序号（13）更新成 Entry 的序号，然后把 Entry 返回给生产者。生产者可以接着往 Entry 里写入数据。</p>
<p><strong>提交新的数据</strong></p>
<p>两阶段提交的第二步是——对，提交。</p>
<p><img src="../../../../asserts/zqr0ggvq716.jpeg" alt="img"></p>
<p>绿色表示最近写入的 Entry，序号是 13 ——厄，抱歉，我也是红绿色盲。但是其他颜色甚至更糟糕。</p>
<p>当生产者结束向 Entry 写入数据后，它会要求 ProducerBarrier 提交。</p>
<p>ProducerBarrier 先等待 Ring Buffer 的游标追上当前的位置（对于单生产者这毫无意义－比如，我们已经知道游标到了 12 ，而且没有其他人正在写入 Ring Buffer）。然后 ProducerBarrier 更新 Ring Buffer 的游标到刚才写入的 Entry 序号－在我们这儿是 13。接下来，ProducerBarrier 会让消费者知道 buffer 中有新东西了。它戳一下 ConsumerBarrier 上的 WaitStrategy 对象说－“喂，醒醒！有事情发生了！”（注意－不同的 WaitStrategy 实现以不同的方式来实现提醒，取决于它是否采用阻塞模式。）</p>
<p>现在消费者 1 可以读 Entry 13 的数据，消费者 2 可以读 Entry 13 以及前面的所有数据，然后它们都过得很 happy。</p>
<p><strong>ProducerBarrier 上的批处理</strong></p>
<p>有趣的是 Disruptor 可以同时在生产者和 消费者 两端实现批处理。还记得伴随着程序运行，消费者 2 最后达到了序号 9 吗？ProducerBarrier 可以在这里做一件很狡猾的事－它知道 Ring Buffer 的大小，也知道最慢的消费者位置。因此它能够发现当前有哪些节点是可用的。</p>
<p><img src="../../../../asserts/5dct1vbs169.jpeg" alt="img"></p>
<p>如果 ProducerBarrier 知道 Ring Buffer 的游标指向 12，而最慢的消费者在 9 的位置，它就可以让生产者写入节点 3，4，5，6，7 和 8，中间不需要再次检查消费者的位置。</p>
<p><strong>多个生产者的场景</strong></p>
<p>到这里你也许会以为我讲完了，但其实还有一些细节。</p>
<p>在上面的图中我稍微撒了个谎。我暗示了 ProducerBarrier 拿到的序号直接来自 Ring Buffer 的游标。然而，如果你看过代码的话，你会发现它是通过 ClaimStrategy 获取的。我省略这个对象是为了简化示意图，在单个生产者的情况下它不是很重要。</p>
<p>在多个生产者的场景下，你还需要其他东西来追踪序号。这个序号是指当前可写入的序号。注意这和“向 Ring Buffer 的游标加 1”不一样－如果你有一个以上的生产者同时在向 Ring Buffer 写入，就有可能出现某些 Entry 正在被生产者写入但还没有提交的情况。</p>
<p><img src="../../../../asserts/ovuahxbw728.jpeg" alt="img"></p>
<p>让我们复习一下如何申请写入节点。每个生产者都向 ClaimStrategy 申请下一个可用的节点。生产者 1 拿到序号 13，这和上面单个生产者的情况一样。生产者 2 拿到序号 14，尽管 Ring Buffer的当前游标仅仅指向 12。这是因为 ClaimSequence 不但负责分发序号，而且负责跟踪哪些序号已经被分配。</p>
<p>现在每个生产者都拥有自己的写入节点和一个崭新的序号。</p>
<p>我把生产者 1 和它的写入节点涂上绿色，把生产者 2 和它的写入节点涂上可疑的粉色－看起来像紫色。</p>
<p><img src="../../../../asserts/lfmwgd6g622.jpeg" alt="img"></p>
<p>现在假设生产者 1 还生活在童话里，因为某些原因没有来得及提交数据。生产者 2 已经准备好提交了，并且向 ProducerBarrier 发出了请求。</p>
<p>就像我们先前在 commit 示意图中看到的一样，ProducerBarrier 只有在 Ring Buffer 游标到达准备提交的节点的前一个节点时它才会提交。在当前情况下，游标必须先到达序号 13 我们才能提交节点 14 的数据。但是我们不能这样做，因为生产者 1 正盯着一些闪闪发光的东西，还没来得及提交。因此 ClaimStrategy 就停在那儿自旋 (spins)， 直到 Ring Buffer 游标到达它应该在的位置。</p>
<p><img src="../../../../asserts/m4n2n-h4811.jpeg" alt="img"></p>
<p>现在生产者 1 从迷糊中清醒过来并且申请提交节点 13 的数据（生产者 1 发出的绿色箭头代表这个请求）。ProducerBarrier 让 ClaimStrategy 先等待 Ring Buffer 的游标到达序号 12，当然现在已经到了。因此 Ring Buffer 移动游标到 13，让 ProducerBarrier 戳一下 WaitStrategy 告诉所有人都知道 Ring Buffer 有更新了。现在 ProducerBarrier 可以完成生产者 2 的请求，让 Ring Buffer 移动游标到 14，并且通知所有人都知道。</p>
<p>你会看到，尽管生产者在不同的时间完成数据写入，但是 Ring Buffer 的内容顺序总是会遵循 nextEntry() 的初始调用顺序。也就是说，如果一个生产者在写入 Ring Buffer 的时候暂停了，只有当它解除暂停后，其他等待中的提交才会立即执行。</p>
<p>呼——。我终于设法讲完了这一切的内容并且一次也没有提到内存屏障（Memory Barrier）。</p>
<p><strong>更新</strong>：最近的 RingBuffer 版本去掉了 Producer Barrier。如果在你看的代码里找不到 ProducerBarrier，那就假设当我讲“Producer Barrier”时，我的意思是“Ring Buffer”。</p>
<p><strong>更新2</strong>：注意 Disruptor 2.0 版使用了与本文不一样的命名。如果你对类名感到困惑，请阅读我写的Disruptor 2.0更新摘要。</p>
<p>原文链接：<a href="http://ifeve.com/dissecting-the-disruptor-writing-to-the-ring-buffer/" target="_blank" rel="noopener">http://ifeve.com/dissecting-the-disruptor-writing-to-the-ring-buffer/</a></p>
<p>译文链接：<a href="http://ifeve.com/disruptor-writing-ringbuffer/" target="_blank" rel="noopener">http://ifeve.com/disruptor-writing-ringbuffer/</a></p>
]]></content>
      <tags>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Disruptor（二）</title>
    <url>/2019/11/18/disruptor2/</url>
    <content><![CDATA[<p><strong>从Ringbuffer读取数据</strong></p>
<p>从上一篇文章中我们都了解了什么是Ring Buffer以及它是如何的特别。但遗憾的是，我还没有讲述如何使用Disruptor向Ring Buffer写数据和从Ring Buffer中读取数据。</p>
<p>从上一篇文章中我们都了解了什么是<strong>Ring Buffer</strong>以及它是如何的特别。但遗憾的是，我还没有讲述如何使用<strong>Disruptor</strong>向<strong>Ring Buffer</strong>写数据和从<strong>Ring Buffer</strong>中读取数据。</p>
<a id="more"></a>

<p><strong>ConsumerBarrier与消费者</strong></p>
<p>这里我要稍微反过来介绍，因为总的来说读取数据这一过程比写数据要容易理解。假设通过一些“魔法”已经把数据写入到<strong>Ring Buffer</strong>了，怎样从<strong>Ring Buffer</strong>读出这些数据呢？</p>
<p><img src="../../../../asserts/s_880211960.jpeg" alt="img"></p>
<p>(好，我开始后悔使用<strong>Paint/Gimp</strong> 了。尽管这是个购买绘图板的好借口，如果我继续写下去的话… <strong>UML</strong>界的权威们大概也在诅咒我的名字了。)</p>
<p>消费者(<strong>Consumer</strong>)是一个想从<strong>Ring Buffer</strong>里读取数据的线程，它可以访问<strong>ConsumerBarrier</strong>对象——这个对象由<strong>RingBuffer</strong>创建并且代表消费者与<strong>RingBuffer</strong>进行交互。就像<strong>Ring Buffer</strong>显然需要一个序号才能找到下一个可用节点一样，消费者也需要知道它将要处理的序号——每个消费者都需要找到下一个它要访问的序号。在上面的例子中，消费者处理完了<strong>Ring Buffer</strong>里序号<strong>8</strong>之前（包括<strong>8</strong>）的所有数据，那么它期待访问的下一个序号是<strong>9</strong>。</p>
<p>消费者可以调用<strong>ConsumerBarrier</strong>对象的<strong>waitFor()</strong>方法，传递它所需要的下一个序号.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> availableSeq = consumerBarrier.waitFor(nextSequence);</span><br></pre></td></tr></table></figure>

<p><strong>ConsumerBarrier</strong>返回<strong>RingBuffer</strong>的最大可访问序号——在上面的例子中是<strong>12</strong>。<strong>ConsumerBarrier</strong>有一个<strong>WaitStrategy</strong>方法来决定它如何等待这个序号，我现在不会去描述它的细节，代码的注释里已经概括了每一种<strong>WaitStrategy</strong>的优点和缺点 。</p>
<p><strong>接下来怎么做？</strong></p>
<p>接下来，消费者会一直原地停留，等待更多数据被写入<strong>Ring Buffer</strong>。并且，一旦数据写入后消费者会收到通知——节点<strong>9</strong>，<strong>10</strong>，<strong>11</strong>和<strong>12</strong> 已写入。现在序号<strong>12</strong>到了，消费者可以让<strong>ConsumerBarrier</strong>去拿这些序号节点里的数据了。</p>
<p><img src="../../../../asserts/neKawwjs561.jpeg" alt="img"></p>
<p>拿到了数据后，消费者(<strong>Consumer</strong>)会更新自己的标识(<strong>cursor</strong>)。</p>
<p>你应该已经感觉得到，这样做是怎样有助于平缓延迟的峰值了——以前需要逐个节点地询问“我可以拿下一个数据吗？现在可以了么？现在呢？”，消费者(<strong>Consumer</strong>)现在只需要简单的说“当你拿到的数字比我这个要大的时候请告诉我”，函数返回值会告诉它有多少个新的节点可以读取数据了。因为这些新的节点的确已经写入了数据（<strong>Ring Buffer</strong>本身的序号已经更新），而且消费者对这些节点的唯一操作是读而不是写，因此访问不用加锁。这太好了，不仅代码实现起来可以更加安全和简单，而且不用加锁使得速度更快。</p>
<p>另一个好处是——你可以用多个消费者(<strong>Consumer)</strong>去读同一个<strong>RingBuffer</strong> ，不需要加锁，也不需要用另外的队列来协调不同的线程(消费者)。这样你可以在<strong>Disruptor</strong>的协调下实现真正的并发数据处理。</p>
<p><strong>BatchConsumer</strong>代码是一个消费者的例子。如果你实现了<strong>BatchHandler,</strong> 你可以用<strong>BatchConsumer</strong>来完成上面我提到的复杂工作。它很容易对付那些需要成批处理的节点（例如上文中要处理的<strong>9-12</strong>节点）而不用单独地去读取每一个节点。</p>
<p>更新：注意<strong>Disruptor 2.0</strong>版本使用了与本文不一样的命名。如果你对类名感到困惑，请阅读我的<strong>变更总结</strong>。</p>
<p>原文链接：<a href="http://ifeve.com/dissecting-the-disruptor-how-do-i-read-from-the-ring-buffer/" target="_blank" rel="noopener">http://ifeve.com/dissecting-the-disruptor-how-do-i-read-from-the-ring-buffer/</a></p>
<p>译文链接：<a href="http://ifeve.com/dissecting_the_disruptor_how_doi_read_from_the_ring_buffer/" target="_blank" rel="noopener">http://ifeve.com/dissecting_the_disruptor_how_doi_read_from_the_ring_buffer/</a></p>
]]></content>
      <tags>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Disruptor（一）</title>
    <url>/2019/11/18/disruptor1/</url>
    <content><![CDATA[<p><strong>Ringbuffer的特别之处</strong></p>
<p>首先介绍ringbuffer。我对Disruptor的最初印象就是ringbuffer。但是后来我意识到尽管ringbuffer是整个模式（Disruptor）的核心，但是Disruptor对ringbuffer的访问控制策略才是真正的关键点所在。</p>
<p>作者：Trisha 寒桐译</p>
<p>最近，我们开源了LMAX Disruptor， 它是我们的交易系统吞吐量快（LMAX是一个新型的交易平台，</p>
<a id="more"></a>

<p>号称能够单线程每秒处理数百万的订单）的关键原因。为什么我们要将其开源？我们意识到对高性能编程领域的一些传统观点，有点不对劲。我们找到了一种更好、更快地在线程间共享数据的方法，如果不公开于业界共享的话，那未免太自私了。同时开源也让我 们觉得看起来更酷。</p>
<p>从这个站点，你可以下载到一篇解释什么是Disruptor及它为什么如此高性能的文档。这篇文档的编写过程，我并没有参与太多，只是简单地插入了一些标点符号和重组了一些我不懂的句子，但是非常高兴的是，我仍然从中提升了自己的写作水平。</p>
<p>我发现要把所有的事情一下子全部解释清楚还是有点困难的，所有我准备一部分一部分地解释它们，以适合我的NADD听众。</p>
<p>首先介绍ringbuffer。我对Disruptor的最初印象就是ringbuffer。但是后来我意识到尽管ringbuffer是整个模式（Disruptor）的核心，但是Disruptor对ringbuffer的访问控制策略才是真正的关键点所在。</p>
<p><strong>ringbuffer到底是什么？</strong></p>
<p>嗯，正如名字所说的一样，它是一个环（首尾相接的环），你可以把它用做在不同上下文（线程）间传递数据的buffer。</p>
<p><img src="../../../../asserts/2407672373.jpeg" alt="img"></p>
<p>（好吧，这是我通过画图板手画的，我试着画草图，希望我的强迫症不会让我画完美的圆和直线）</p>
<p>基本来说，ringbuffer拥有一个序号，这个序号指向数组中下一个可用的元素。（校对注：如下图右边的图片表示序号，这个序号指向数组的索引4的位置。）</p>
<p><img src="../../../../asserts/mGPxPLmQ319.jpeg" alt="img"></p>
<p>随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。</p>
<p><img src="../../../../asserts/kysAIzvw325.jpeg" alt="img"></p>
<p>要找到数组中当前序号指向的元素，可以通过mod操作：</p>
<p>sequence mod array length = array index     </p>
<p>以上面的ringbuffer为例（java的mod语法）：12 % 10 = 2。很简单吧。</p>
<p>事实上，上图中的ringbuffer只有10个槽完全是个意外。如果槽的个数是2的N次方更有利于基于二进制的计算机进行计算。</p>
<p>（校对注：2的N次方换成二进制就是1000，100，10，1这样的数字， sequence &amp; （array length－1） = array index，比如一共有8槽，3&amp;（8－1）=3，HashMap就是用这个方式来定位数组元素的，这种方式比取模的速度更快。）</p>
<p><strong>那又怎么样？</strong></p>
<p>如果你看了维基百科里面的关于环形buffer的 词条，你就会发现，我们的实现方式，与其最大的区别在于：没有尾指针。我们只维护了一个指向下一个可用位置的序号。这种实现是经过深思熟虑的—我们选择用 环形buffer的最初原因就是想要提供可靠的消息传递。我们需要将已经被服务发送过的消息保存起来，这样当另外一个服务通过nak (校对注：拒绝应答信号)告诉我们没有成功收到消息时，我们能够重新发送给他们。</p>
<p>听起来，环形buffer非常适合这个场景。它维护了一个指向尾部的序号，当收到nak(校对注：拒绝应答信号)请求，可以重发从那一点到当前序号之间的所有消息：</p>
<p><img src="../../../../asserts/unA8JQ4Q654.jpeg" alt="img"></p>
<p>我们实现的ring buffer和大家常用的队列之间的区别是，我们不删除buffer中的数据，也就是说这些数据一直存放在buffer中，直到新的数据覆盖他们。这就是 和维基百科版本相比，我们不需要尾指针的原因。ringbuffer本身并不控制是否需要重叠（决定是否重叠是生产者-消费者行为模式的一部分–如果你等 不急我写blog来说明它们，那么可以自行检出<a href="https://code.google.com/p/disruptor/" target="_blank" rel="noopener">Disruptor项目</a>）。</p>
<p><strong>它为什么如此优秀？</strong></p>
<p>之所以ringbuffer采用这种数据结构，是因为它在可靠消息传递方面有很好的性能。这就够了，不过它还有一些其他的优点。</p>
<p>首先，因为它是数组，所以要比链表快，而且有一个容易预测的访问模式。（译者注：数组内元素的内存地址的连续性存储的）。这是对CPU缓存友好的—也就是说，在硬件级别，数组中的元素是会被预加载的，因此在ringbuffer当中，cpu无需时不时去主存加载数组中的下一个元素。（校对注：因为只要一个元素被加载到缓存行，其他相邻的几个元素也会被加载进同一个缓存行）</p>
<p>其次，你可以为数组预先分配内存，使得数组对象一直存在（除非程序终止）。这就意味着不需要花大量的时间用于垃圾回收。此外，不像链表那样，需要为每一个添加到其上面的对象创造节点对象—对应的，当删除节点时，需要执行相应的内存清理操作。</p>
<p><strong>缺少的部分</strong></p>
<p>我并没有在本文中介绍如何避免ringbuffer产生重叠，以及如何对ringbuffer进行读写操作。你可能注意到了我将ringbuffer和链表那样的数据结构进行比较，因为我并认为链表是实际问题的标准答案。</p>
<p>当你将Disruptor和基于 队列之类的实现进行比较时，事情将变得很有趣。队列通常注重维护队列的头尾元素，添加和删除元素等。所有的这些我都没有在ringbuffer里提到，这 是因为ringbuffer不负责这些事情，我们把这些操作都移到了数据结构（ringbuffer）的外部</p>
<p>原文链接：<a href="http://ifeve.com/ringbuffer/" target="_blank" rel="noopener">http://ifeve.com/ringbuffer/</a></p>
<p>译文链接：<a href="http://ifeve.com/dissecting-disruptor-whats-so-special/" target="_blank" rel="noopener">http://ifeve.com/dissecting-disruptor-whats-so-special/</a></p>
]]></content>
      <tags>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>TF-IDF算法介绍</title>
    <url>/2019/11/18/TF-IDF/</url>
    <content><![CDATA[<p><strong>TF-IDF是什么</strong></p>
<p>TF-IDF是一种统计方法，用以评估一个词对于一篇文章或语料库中一篇文章的重要性。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。</p>
<p><strong>TF-IDF的使用场景</strong></p>
<p>TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了TF-IDF以外，因特网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜寻结果中出现的顺序。</p>
<a id="more"></a>

<p><strong>TF-IDF原理</strong></p>
<ul>
<li>TF（Term Frequency) 表示词频，即一个词在在一篇文章中出现的次数，但在实际应用时会有一个漏洞，就是篇幅长的文章给定词出现的次数会更多一点。因此我们需要对次数进行归一化，通常用给定词的次数除以文章的总词数。</li>
</ul>
<p><img src="https://math.jianshu.com/math?formula=TF_w%20%3D%20%5Cfrac%7BC_w%7D%7BC%7D" alt="img"></p>
<p>这其中还有一个漏洞，就是 ”的“ ”是“ ”啊“ 等类似的词在文章中出现的此时是非常多的，但是这些大多都是没有意义词，对于判断文章的关键词几乎没有什么用处，我们称这些词为”停用词“，也就是说，在度量相关性的时候不应该考虑这些词的频率。</p>
<ul>
<li>IDF（Inverse Document Frequency）逆文本频率指数，如果包含关键词w的文档越少，则说明关键词w具有很好的类别区分能力。某一关键词的IDF，可以用总的文章数量除以包含该关键词的文章的数量，然后对结果取对数得到</li>
</ul>
<p><img src="https://math.jianshu.com/math?formula=IDF_w%20%3D%20%5Clog(%5Cfrac%7BC%7D%7BC_w%20%2B%201%7D)" alt="img"></p>
<p> 注：分母加1是为了避免没有包含关键词的文章时分母是0的情况</p>
<p>一个词预测主题的能力越强，权重就越大，反之，权重越小，因此一个词的TF-IDF就是：</p>
<p><img src="https://math.jianshu.com/math?formula=TF-IDF%20%3D%20TF*IDF" alt="img"></p>
<p><strong>实际应用</strong></p>
<p>通常在新闻的分类，或者说文章的分类的时候我们会用到ID-IDF。如果让编辑来对新闻或者文章分类，他一定要先读懂文章，然后找出主题，最后根据主题的不同对文章进行分类。而让电脑对文章进行分类，就要求我们先把文字的文章变成一组可以计算的数字，然后通过算法来算出文章的相似性。</p>
<p>首先我们先来看怎么用一组数字（或者说一个向量）来表示一篇文章。对于一篇文章的所有实词（除去无意义的停用词），计算出他们的TF-IDF值，把这些值按照对应的实词在词汇表的位置依次排列，就得到了一个向量。比如，词汇表中有64000个词，其编号和词：</p>
<table>
<thead>
<tr>
<th>单词编号</th>
<th>汉字词</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>阿</td>
</tr>
<tr>
<td>2</td>
<td>啊</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>789</td>
<td>服装</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>64000</td>
<td>做作</td>
</tr>
</tbody></table>
<p>在某一篇文章中，文章中的词的TF-IDF值对应为：</p>
<table>
<thead>
<tr>
<th>单词编号</th>
<th>TF-IDF</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0.0034</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>789</td>
<td>0.034</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>64000</td>
<td>0.075</td>
</tr>
</tbody></table>
<p>如果单词表的某个词在文章中没有出现，对应的值为零，这样我们就得到了一个64000维的向量，我们称为这篇文章的特征向量。然后每篇文章就可以用一个向量来表示，这样我们就可以计算文章之间的相似程度了。</p>
<p>向量的夹角是衡量两个向量相近程度的度量。因此，可以通过计算两篇文章的特征向量的夹角来判断两篇文章的主题的接近程度。那么我们就需要用余弦地理了。</p>
<p><img src="../../../../asserts/bdb304120a1.webp" alt="img"></p>
<p>∠A的余弦值为：</p>
<p><img src="https://math.jianshu.com/math?formula=cosA%20%3D%20%5Cfrac%7Bb%5E2%2Bc%5E2-a%5E2%7D%7B2bc%7D" alt="img"></p>
<p>如果将三角形的两边b和c看成是两个以A为起点的向量，那么上述公式等于：</p>
<p><img src="https://math.jianshu.com/math?formula=cosA%3D%5Cfrac%7B%3Cb%2Cc%3E%7D%7B%7Cb%7C%C2%B7%7Cc%7C%7D" alt="img"></p>
<p>其中，分母便是两个向量b和c的长度，分子表示两个向量的内积。假设文章X和文章Y对应的向量是</p>
<p><img src="https://math.jianshu.com/math?formula=X_1%2CX_2%2C...%2CX_%7B64000%7D%E5%92%8CY_1%2CY_2%2C...%2CY_%7B64000%7D" alt="img"></p>
<p>那么他们的夹角的余弦等于</p>
<p><img src="https://math.jianshu.com/math?formula=cos%CE%B8%3D%5Cfrac%7Bx_1y_1%2Bx_2y_2%2B...%2Bx_%7B64000%7Dy_%7B64000%7D%7D%7B%5Csqrt%7Bx_1%5E2%2Bx_2%5E2%2Bx_%7B64000%7D%5E2%7D%5Ccdot%5Csqrt%7By_1%5E2%2By_2%5E2%2By_%7B64000%7D%5E2%7D%7D" alt="img"></p>
<p>由于向量中的每一个变量都是正数，所以余弦的取值在0到1之间。当两篇文章向量的余弦等于1时，这两个向量夹角为零，两篇文章完全相同；当夹角的余弦接近于1时两篇文章越相似，从而可以归成一类；夹角的余弦越小，夹角越大，两篇文章越不相关。</p>
<p>现在假定我们已知一些文章的特征向量，那么对于任何一个要被分类的文章，就很容易计算出它和各类文章的余弦相似性，并将其归入它该去的那一类中。</p>
<p>如果事先没有已知的文章的特征向量呢，可以用自底向上不断合并的方法。</p>
<ol>
<li>计算所有文章之间凉凉的余弦相似性，把相似性大于一个阈值的合并成一小类</li>
<li>把每个小类中的所有文章作为一个整体，计算小类的特征向量，在计算小雷之间两两的余弦相似性，然后合并成一个大类</li>
</ol>
<p>这样不断做下去，类别越来越少，而每个类越来越大。当某一类太大时，这一类里的文章的相似性就很小了，这时就要停止迭代过程了，然后完成分类。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>工具网站收藏</title>
    <url>/2019/11/18/useful-website/</url>
    <content><![CDATA[<p><strong>Part1:前端工具</strong></p>
<p>【1】字体图标生成网站：IconMoon：<a href="https://icomoon.io/" target="_blank" rel="noopener">https://icomoon.io/</a></p>
<p>【2】reset 和 globle CSS：<a href="https://meyeerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">https://meyerweb.com/eric/tools/css/reset/</a></p>
<p>【3】阿里巴巴矢量图标库：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p>
<a id="more"></a>

<p>【4】EChart：<a href="https://echarts.baidu.com/" target="_blank" rel="noopener">https://echarts.baidu.com/</a></p>
<p>【5】iView：<a href="https://www.iviewui.com/" target="_blank" rel="noopener">https://www.iviewui.com/</a></p>
<p><strong>Part2:视频教程</strong></p>
<p>【1】慕课网：<a href="https://www.imooc.com/" target="_blank" rel="noopener">https://www.imooc.com/</a></p>
<p>【2】Siki学院：<a href="http://www.sikiedu.com/" target="_blank" rel="noopener">http://www.sikiedu.com/</a></p>
<p>【3】Bilibili：<a href="https://www.bilibili.com/" target="_blank" rel="noopener">https://www.bilibili.com/</a></p>
<p><strong>Part3:实用网站</strong></p>
<p>【1】国家哲学社会科学文献中心：<a href="http://www.ncpssd.org" target="_blank" rel="noopener">http://www.ncpssd.org</a></p>
<p>【2】MSDN，我告诉你： <a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派镜像制作</title>
    <url>/2019/11/18/raspberry-blog1/</url>
    <content><![CDATA[<p><strong>【1】树莓派原始镜像烧录。</strong></p>
<p><strong>【2】中文字库以及中文拼音输入法下载：</strong></p>
<p>启动后，开启Terminal终端，出现提示符时输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-zenhei</span><br></pre></td></tr></table></figure>

 <a id="more"></a> 

<p>将安装文泉驿的开源中文字体，在这里向文泉驿表示致敬，貌似它是唯一一个开源的中文字体库。郭嘉有钱建孔子学院，但是从来不会有钱搞一套比较完整的开源中文字库出来的。</p>
<p>中文是可以显示啦，输入呢？Linux下早就有啦，叫SCIM（Smart Common Input Method ），所以只要输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install scim-pinyin</span><br></pre></td></tr></table></figure>

<p>就会安装拼音输入法，安装完成后，可以直接打入scim激活，下次启动是会自动启动的。快捷键也是Ctrl+空格。或者直接点击右下角图标选择。</p>
<p>接着运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>

<p>然后选择change_locale，在Default locale for the system environment:中选择zh_CN.UTF-8。然后重启机器，就发现整个环境变成中文的了。</p>
<p><strong>【3】安装 Pi4j：</strong></p>
<p><strong>Installation</strong></p>
<p><strong>Easy/Preferred</strong></p>
<p>(NOTE: This installation method requires that your RaspberryPi is connected to the Internet.)</p>
<p>The simplest method to install Pi4J on your RaspberryPi is to execute the following command directly on your RaspberryPi.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s get.pi4j.com | sudo bash</span><br></pre></td></tr></table></figure>

<p>This method will download and launch an installation script that perform the following steps:</p>
<ol>
<li>adds the Pi4J APT repository to the local APT repositories</li>
<li>downloads and installs the Pi4J GPG public key for signature validation</li>
<li>invokes the ‘apt-get update’ command on the Pi4J APT repository to update the local package database</li>
<li>invokes the ‘apt-get install pi4j’ command to perform the download and installation</li>
</ol>
<p><strong>Offline/Manual</strong></p>
<p>If you prefer/need to install Pi4J on a RaspberryPi device without an Internet connection, the following instructions provide the steps necessary to install Pi4J without requiring an Internet connection.</p>
<p>First, download a copy of the latest Pi4J Debian/Raspian installer package (.deb) file to your local computer. You can download the Pi4J Debian/Raspian installer package (.deb) using your web browser at the following URL: </p>
<p><a href="http://get.pi4j.com/download/pi4j-1.2-SNAPSHOT.deb" target="_blank" rel="noopener">http://get.pi4j.com/download/pi4j-1.2-SNAPSHOT.deb</a></p>
<p>Next, you will need to transfer the download installer package over to your RaspberryPi. You can use any method you prefer to transfer the file (USB, SCP, FTP, etc.)</p>
<p>(NOTE: If you have a previous version of Pi4J installed, you will need to uninstall it first.)</p>
<p>Once the installer package is available on your RaspberryPi, use the following command on the Pi to perform the installation: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i pi4j-1.2-SNAPSHOT.deb</span><br></pre></td></tr></table></figure>

<p><strong>Upgrade</strong></p>
<p><strong>Easy/Preferred</strong></p>
<p>If you originally installed Pi4J using the <em>‘easy’</em> method, then Pi4J upgrades will be available anytime you perform a system update using ‘sudo apt-get update’ and ‘sudo update-get upgrade’.</p>
<p>If you wish to force an upgrade of the Pi4J package only, you can do so by executing the following command: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install pi4j or pi4j --update</span><br></pre></td></tr></table></figure>

<p><strong>Offline/Manual</strong></p>
<p>If you originally installed Pi4J using the <em>‘offline’</em> method, then you will need to manually uninstall the Pi4J package and download, transfer, and install the new version package using the ‘offline’ uninstall and installation methods described here on this page.</p>
<p><strong>Uninstall</strong></p>
<p><strong>Easy/Preferred</strong></p>
<p>If you originally installed Pi4J using the <em>‘easy’</em> method, then you can uninstall Pi4J simply by executing the following command on your RaspberryPi. </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove pi4j or pi4j --uninstall</span><br></pre></td></tr></table></figure>

<p><strong>Complete/Full Removal</strong></p>
<p>If you originally installed Pi4J using the <em>‘easy’</em> method and you want to remove all traces of Pi4J, including the Pi4J repository in the APT repositories list and the Pi4J GPG signature, then simply execute the following command on your RaspberryPi. </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s get.pi4j.com/uninstall | sudo bash</span><br></pre></td></tr></table></figure>

<p><strong>Offline/Manual</strong></p>
<p>If you originally installed Pi4J using the <em>‘offline’</em> method, then you will need to manually uninstall the Pi4J package by executing the following command on your Raspberry Pi: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -r pi4j</span><br></pre></td></tr></table></figure>

<p><strong>Installed Location / Example Files</strong></p>
<p>This will install the Pi4J libraries and example source files to: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/pi4j/lib </span><br><span class="line">/opt/pi4j/examples</span><br></pre></td></tr></table></figure>

<p>When attempting to compile a Java program using the Pi4J libraries, make sure to include the Pi4J lib folder in the classpath: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac -classpath .:classes:/opt/pi4j/lib/'*' ...</span><br></pre></td></tr></table></figure>

<p>When attempting to start a Java program using the Pi4J libraries, make sure to include the Pi4J lib folder in the classpath: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo java -classpath .:classes:/opt/pi4j/lib/'*' ...</span><br></pre></td></tr></table></figure>

<p>If you would like to explore the examples, you can compile all the examples with the following commands: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/pi4j/examples/build</span><br></pre></td></tr></table></figure>

<p><strong>Pi4j官网:</strong><a href="https://pi4j.com" target="_blank" rel="noopener">https://pi4j.com</a></p>
<p><strong>【4】安装 JavaFX 插件包：</strong></p>
<p>As you can read <a href="https://stackoverflow.com/questions/28284239/javafx-ensemble-on-raspberry-pi/28284736#28284736" target="_blank" rel="noopener">here</a>, the most recent JDK versions for ARM don’t include JavaFX.</p>
<p>If you want to use JavaFX in your Raspberry Pi, the solution is adding the missing JavaFX SDK.</p>
<p>If you install the recent Oracle’s JDK for ARM from <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">here</a> (select jdk-8u111-linux-arm32-vfp-hflt.tar.gz), then you will need to download the JavaFX SDK from Gluon’s <a href="http://gluonhq.com/labs/javafxports/get/" target="_blank" rel="noopener">site</a> (select JavaFX Embedded SDK for armv6 hard float).</p>
<p>Once you have the file, unzip it, and copy the folders to your JDK.</p>
<p>Assuming you have downloaded armv6hf-sdk-8.60.8.zip to your Pi/Downloads folder, and you have unzip it to a folder armv6hf-sdk, like in the following picture:</p>
<p><img src="../../../../asserts/sQzdd.png" alt="Pi ARM JavaFX"></p>
<p>using the following commands will allow you moving from command line the files to the JDK required folders. You can use a graphic tool for this as well.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd Downloads </span><br><span class="line">sudo chown -R root:root armv6hf-sdk </span><br><span class="line">cd armv6hf-sdk </span><br><span class="line">sudo mv lib/javafx-mx.jar /opt/jdk1.8.0_111/lib/ </span><br><span class="line">cd rt/lib/ </span><br><span class="line">sudo mv j* /opt/jdk1.8.0_111/jre/lib/ </span><br><span class="line">sudo mv arm/* /opt/jdk1.8.0_111/jre/lib/arm/ </span><br><span class="line">sudo mv ext/* /opt/jdk1.8.0_111/jre/lib/ext/</span><br></pre></td></tr></table></figure>

<p>After that you should be able to run Java/JavaFX programs.</p>
<p><strong>参考链接:</strong><a href="https://stackoverflow.com/questions/40481455/running-javafx-gui-on-the-raspberry-pi/40483500#40483500" target="_blank" rel="noopener">https://stackoverflow.com/questions/40481455/running-javafx-gui-on-the-raspberry-pi/40483500#40483500</a></p>
<p><strong>【5】解决树莓派图形渲染问题：</strong></p>
<p><a href="https://www.raspberrypi.org/forums/viewtopic.php?f=81&t=60024#p448200" target="_blank" rel="noopener">JavaFX glGetError 0x505</a></p>
<p>You can try increase the available raspberry pi video memory using the <strong>sudo raspi-config</strong> tool. try change to the 50/50 memory spit.</p>
<p><strong>参考链接</strong>:<a href="https://www.raspberrypi.org/forums/viewtopic.php?f=81&amp;t=60024#p448200" target="_blank" rel="noopener">https://www.raspberrypi.org/forums/viewtopic.php?f=81&amp;t=60024#p448200</a></p>
<p><strong>【6】树莓派播放视频：</strong></p>
<p>WebView and Media were never part of the JavaFX ARM distribution, but Gluon recently added it to the embedded SDK that can be downloaded from <a href="http://gluonhq.com/labs/javafxports/get/" target="_blank" rel="noopener">here</a> and installed with a recent JDK for ARM, available <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">here</a>.</p>
<p>Media requires a few extra steps as it depends in the native drivers that usually are not fully installed on a regular Jessie distribution.</p>
<p>First install these drivers:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gstreamer0.10-plugins-good </span><br><span class="line">sudo apt-get install gstreamer0.10-plugins-bad</span><br></pre></td></tr></table></figure>

<p>Now edit /etc/apt/sources.list and add at the end:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://ftp.uk.debian.org/debian/ wheezy main deb-src http://ftp.uk.debian.org/debian/ wheezy main</span><br></pre></td></tr></table></figure>

<p>Save the file (Ctrl+O, Ctrl+X).</p>
<p>Finally update and install the drivers:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update </span><br><span class="line">sudo apt-get install gstreamer0.10-ffmpeg </span><br><span class="line">sudo apt-get install gstreamer0.10-alsa</span><br></pre></td></tr></table></figure>

<p>Now you can try to run again your JavaFX application.</p>
<p>If you find again the same exception (MediaException: UNKNOWN), check if it shows this message: Error in GstPipelineFactory, notice the driver that is missing, and try to install it.</p>
<p><strong>参考链接:</strong><a href="https://stackoverflow.com/questions/42076680/play-a-video-using-javafx-on-raspberry-pi" target="_blank" rel="noopener">https://stackoverflow.com/questions/42076680/play-a-video-using-javafx-on-raspberry-pi</a></p>
<p><strong>【7】常用的设置树莓派自启动的方法：</strong></p>
<p>这个方式不用修改 rc.local 文件。机制上类似于 Windows 的“开始”菜单中的“启动”菜单。方法如下：</p>
<p>在 /home/pi/.config 下创建一个文件夹，名称为 autostart，并在该文件夹下创建一个xxx.desktop文件（文件名以.desktop结尾，前面可以自定义），文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Desktop Entry] </span><br><span class="line">Name=example </span><br><span class="line">Comment=My Python Program </span><br><span class="line">Exec=python /home/pi/example.py </span><br><span class="line">Icon=/home/pi/example.png </span><br><span class="line">Terminal=false </span><br><span class="line">MultipleArgs=false </span><br><span class="line">Type=Application </span><br><span class="line">Categories=Application;Development; </span><br><span class="line">StartupNotify=true</span><br></pre></td></tr></table></figure>

<p>以上 Name、Comment、Icon 可以自定，分别表示这个启动项目的名称、备注以及显示的图标。Exec 表示调用的指令，和在终端输入运行脚本的指令格式一致。</p>
<p><strong>参考链接</strong>：<a href="https://www.jianshu.com/p/1a160067d8fd" target="_blank" rel="noopener">https://www.jianshu.com/p/1a160067d8fd</a></p>
<p><strong>【8】用树莓派播放视频：</strong></p>
<p>树莓派上可以播放 H264 和 mp4 等视频格式，1080p也没问题，因为这种格式的文件有硬件加速。</p>
<p>首先安装 安装 omxplayer ，这是一个命令行的播放器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install omxplayer</span><br></pre></td></tr></table></figure>

<p>然后就可以播放了，当然需要通过 HDMI 连接到显示器看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">omxplayer -o hdmi /path/to/filename.mp4</span><br></pre></td></tr></table></figure>

<p>-o hdmi 表示音频直接通过 HDMI 播放，播放时按左右箭头快进、按 q 退出。</p>
<p>更多命令行选项和播放时的控制快捷键请参考 <a href="https://github.com/huceke/omxplayer" target="_blank" rel="noopener">omxplayer 的文档</a>。</p>
<p><strong>【9】树莓派安装 JDK：</strong></p>
<p>首先是安装JDK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install oracle-java8-jdk</span><br></pre></td></tr></table></figure>

<p>也可以在<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-arm-downloads-2187468.html" target="_blank" rel="noopener">这个地方</a>下载</p>
<p>修改环境变量，我用的版本是JDK8，arm版HFLT，代表arm架构硬件浮点运算，放在/usr/lib/jvm/jdk-8-oracle-arm-vfp-hflt这个文件夹了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/profile</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">[cc lang=<span class="string">"php"</span>]</span><br><span class="line"><span class="comment">#set java environment</span></span><br><span class="line">JAVA_HOME=/usr/lib/jvm/jdk<span class="number">-8</span>-oracle-arm-vfp-hflt</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tool</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME CLASSPATH PATH</span><br><span class="line">[/cc]</span><br></pre></td></tr></table></figure>

<p>接下来是重启树莓派，看看版本号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>



<p><strong>【10】树莓派去黑边：</strong></p>
<p>在使用树莓派连接HDMI电脑显示器的时候，可能会出现屏幕显示不全，有黑边的情况。这时候需要调节分辨率以适应屏幕。</p>
<p>进入树莓派系统，输入以下指令设置config.txt文件： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /boot/config.txt</span><br></pre></td></tr></table></figure>

<p>调节任何参数时，将#号去除即可生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uncomment to force a specific HDMI mode (this will force VGA) </span></span><br><span class="line">hdmi_group=2  //将显示模式切换成DMT（显示器模式） </span><br><span class="line">hdmi_mode=82  //1920x1080   60Hz    1080p</span><br></pre></td></tr></table></figure>

<p>如果显示器不是1080P。则可以参考注1参数修改 </p>
<p>这时候就将显示设置成1080P的分辨率，但是是不带声音的，如果你的显示器支持HDMI声音输出或者自带音响，则将如下代码参数去除#号解锁强制获取声音。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uncomment to force a HDMI mode rather than DVI. This can make audio work <span class="keyword">in</span> <span class="comment"># DMT (computer monitor) </span></span></span><br><span class="line">modes hdmi_drive=2  //HDMI模式</span><br></pre></td></tr></table></figure>

<p>更多设置参考官方配置文档：<a href="https://www.raspberrypi.org/documentation/configuration/config-txt.md" target="_blank" rel="noopener">https://www.raspberrypi.org/documentation/configuration/config-txt.md</a></p>
<p>注1： DMT模式分辨率参数</p>
<table>
<thead>
<tr>
<th>hdmi_mode</th>
<th>resolution</th>
<th>frequency</th>
<th>notes</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>640x350</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>640x400</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>720x400</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>640x480</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>640x480</td>
<td>72Hz</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>640x480</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>640x480</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>800x600</td>
<td>56Hz</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>800x600</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>800x600</td>
<td>72Hz</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>800x600</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>800x600</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>800x600</td>
<td>120Hz</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>848x480</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>1024x768</td>
<td>43Hz</td>
<td>incompatible with the Raspberry Pi</td>
</tr>
<tr>
<td>16</td>
<td>1024x768</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>1024x768</td>
<td>70Hz</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>1024x768</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>1024x768</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>1024x768</td>
<td>120Hz</td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>1152x864</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>1280x768</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>23</td>
<td>1280x768</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>1280x768</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>1280x768</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>1280x768</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>27</td>
<td>1280x800</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>28</td>
<td>1280x800</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>1280x800</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>1280x800</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>1280x800</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>32</td>
<td>1280x960</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>1280x960</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>34</td>
<td>1280x960</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>35</td>
<td>1280x1024</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>1280x1024</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>37</td>
<td>1280x1024</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>1280x1024</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>39</td>
<td>1360x768</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>1360x768</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>41</td>
<td>1400x1050</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>42</td>
<td>1400x1050</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>43</td>
<td>1400x1050</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>44</td>
<td>1400x1050</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>45</td>
<td>1400x1050</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>46</td>
<td>1440x900</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>47</td>
<td>1440x900</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>48</td>
<td>1440x900</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>49</td>
<td>1440x900</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>50</td>
<td>1440x900</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>51</td>
<td>1600x1200</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>52</td>
<td>1600x1200</td>
<td>65Hz</td>
<td></td>
</tr>
<tr>
<td>53</td>
<td>1600x1200</td>
<td>70Hz</td>
<td></td>
</tr>
<tr>
<td>54</td>
<td>1600x1200</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>55</td>
<td>1600x1200</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>56</td>
<td>1600x1200</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>57</td>
<td>1680x1050</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>58</td>
<td>1680x1050</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>59</td>
<td>1680x1050</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>60</td>
<td>1680x1050</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>61</td>
<td>1680x1050</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>62</td>
<td>1792x1344</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>63</td>
<td>1792x1344</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>64</td>
<td>1792x1344</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>65</td>
<td>1856x1392</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>66</td>
<td>1856x1392</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>67</td>
<td>1856x1392</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>68</td>
<td>1920x1200</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>69</td>
<td>1920x1200</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>70</td>
<td>1920x1200</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>71</td>
<td>1920x1200</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>72</td>
<td>1920x1200</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>73</td>
<td>1920x1440</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>74</td>
<td>1920x1440</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>75</td>
<td>1920x1440</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>76</td>
<td>2560x1600</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>77</td>
<td>2560x1600</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>78</td>
<td>2560x1600</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>79</td>
<td>2560x1600</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>80</td>
<td>2560x1600</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>81</td>
<td>1366x768</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>82</td>
<td>1920x1080</td>
<td>60Hz</td>
<td>1080p</td>
</tr>
<tr>
<td>83</td>
<td>1600x900</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>84</td>
<td>2048x1152</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>85</td>
<td>1280x720</td>
<td>60Hz</td>
<td>720p</td>
</tr>
<tr>
<td>86</td>
<td>1366x768</td>
<td></td>
<td>reduced blanking</td>
</tr>
</tbody></table>
<p><strong>【11】OmxPlayer 调节声音大小：</strong></p>
<p>to provide more precise information for playing through scripts, there are 3 ways to change sound volume in current version of omxplayer, and values are not so intuitive:</p>
<ol>
<li>on starting command line, param –vol YYY, double millibels, default 0, range [-6000:0]</li>
<li>by stdin interface, sending +/- to omxplayer will increase/decrease volume for 300 dmbels</li>
<li>with DBUS interface, cmd ‘set volume’, value double:XXX, default 1, range [0:1]</li>
</ol>
<p>xxx to yyy relation is: XXX = 10 ^ (YYY / 2000) … according to <a href="https://github.com/popcornmix/omxplayer/blob/350779b00bb7278e0d1d9025b9ed1ddb4a2d99cd/omxplayer.cpp#L1166" target="_blank" rel="noopener">omxplayer.cpp</a> source code, reverse formula would be: YYY = 2000 * (log XXX).</p>
<p>so if we need:</p>
<ul>
<li>volume 1%, XXX=0.01 and YYY=-4000 (10^(-4000/2000)=10^-2=0.01</li>
<li>volume 10%, XXX=0.1 and YYY=-2000 (10^(-2000/2000)=10^-1=0.1</li>
<li>volume 50%, XXX=0.5 and YYY=-602 (10^(-602/2000))~=0.5</li>
<li>volume 100%, XXX=1 and YYY=0 (10^(0/2000)=10^0=1)</li>
<li>volume 150%, XXX=1.5 and YYY=352 … (for boost test, normal values are &lt;=100%)</li>
</ul>
<p>working bash script for dbus volume command:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export DBUS_SESSION_BUS_ADDRESS=$(cat /tmp/omxplayerdbus.$&#123;USER:-root&#125;) \</span><br><span class="line">dbus-send --print-reply --session --reply-timeout=500 \           </span><br><span class="line">		  --dest=org.mpris.MediaPlayer2.omxplayer \           			</span><br><span class="line"> 		  /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Set\  </span><br><span class="line">		  string:"org.mpris.MediaPlayer2.Player" \           </span><br><span class="line"> 		  string:"Volume" double:0.5   # &lt;-- XXX=0.5 (50% sound volume)</span><br></pre></td></tr></table></figure>

<p>equals to volume parameter at startup:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">omxplayer --vol -602 mediaFileName.mp4</span><br></pre></td></tr></table></figure>

<p>… both sets sound volume to 50%.</p>
<p><strong>【12】树莓派设置不休眠的方法</strong></p>
<p>树莓派长时间没人操作时，会自动进入休眠状态，这是因为长时间无操作触发linux的节电休眠机制。所以当树莓派运行后台程序，比如用树莓派看视频时，时间一长就会自动黑屏，树莓派自动进入休眠状态。</p>
<p>怎么设置树莓派不休眠，其实通过建立和设置内置文件就行了，很简单。</p>
<p>以下是防止树莓派休眠的设置步骤：</p>
<p>1、用管理员root账户登录树莓派，在文件夹/etc/profile.d/里面新建内置文件screen.sh。</p>
<p>2、编辑文件screen.sh，写入以下两行内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xset dpms 0 0 0</span><br><span class="line">xset s off</span><br></pre></td></tr></table></figure>

<p>保存文件。</p>
<p>3、重启树莓派，就能实现永久禁用树莓派休眠。</p>
<p><strong>【13】树莓派中的GPU渲染内存设置</strong></p>
<p>为了平衡树莓派CPU运行内存和GPU渲染内存，将GPU的MemorySplit设置成320M这个经验值（总内存1GB，GPU分得320M，则CPU持有704M）是一个不错的选择，设置方法如下：</p>
<p>raspi-config&gt;&gt;Advanced Options&gt;&gt;Memory Split&gt;&gt;更改内存为320</p>
]]></content>
      <tags>
        <tag>raspberry</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<a id="more"></a>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
