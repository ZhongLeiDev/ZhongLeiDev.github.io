<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhongLeiDev</title>
  
  <subtitle>不忘初心，方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.smartonline.net.cn/"/>
  <updated>2019-12-10T01:20:40.705Z</updated>
  <id>https://www.smartonline.net.cn/</id>
  
  <author>
    <name>ZhongLeiDev</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis缓存雪崩和缓存击穿</title>
    <link href="https://www.smartonline.net.cn/2019/12/10/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    <id>https://www.smartonline.net.cn/2019/12/10/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</id>
    <published>2019-12-10T01:15:25.000Z</published>
    <updated>2019-12-10T01:20:40.705Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="https://www.smartonline.net.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁的正确实现方式（Java版）</title>
    <link href="https://www.smartonline.net.cn/2019/12/10/RedisLock/"/>
    <id>https://www.smartonline.net.cn/2019/12/10/RedisLock/</id>
    <published>2019-12-10T00:44:51.000Z</published>
    <updated>2019-12-10T01:13:10.215Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="https://www.smartonline.net.cn/tags/java/"/>
    
      <category term="redis" scheme="https://www.smartonline.net.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://www.smartonline.net.cn/2019/11/25/BloomFilter/"/>
    <id>https://www.smartonline.net.cn/2019/11/25/BloomFilter/</id>
    <published>2019-11-25T06:26:43.000Z</published>
    <updated>2019-11-25T10:30:08.651Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;布隆过滤器 (Bloom Filter)是由Burton Howard Bloom于1970年提出，它是一种space efficient的概率型数据结构，用于判断一个元素是否在集合中。在垃圾邮件过滤的黑白名单方法、爬虫(Crawler)的网址判重模块中等等经常被用到。哈希表也能用于判断元素是否在集合中，但是布隆过滤器只需要哈希表的1/8或1/4的空间复杂度就能完成同样的问题。布隆过滤器可以插入元素，但不可以删除已有元素。其中的元素越多，false positive rate(误报率)越大，但是false negative (漏报)是不可能的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://www.smartonline.net.cn/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>《EffectiveJava》（五）</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/EffectiveJava4/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/EffectiveJava4/</id>
    <published>2019-11-23T09:10:09.000Z</published>
    <updated>2019-11-23T09:11:28.553Z</updated>
    
    <summary type="html">
    
      &lt;h4 id=&quot;【68】executor-和-task-优先于线程&quot;&gt;&lt;a href=&quot;#【68】executor-和-task-优先于线程&quot; class=&quot;headerlink&quot; title=&quot;【68】executor 和 task 优先于线程&quot;&gt;&lt;/a&gt;【68】executor 和 task 优先于线程&lt;/h4&gt;&lt;p&gt;创建工作队列：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ExecutorService executor = Executors.newSingleThreadExecutor()；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;executor.execute(runnable)；&lt;span class=&quot;comment&quot;&gt;//执行提交一个 runnable 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;executor.shutdown()；&lt;span class=&quot;comment&quot;&gt;//优雅地终止&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.smartonline.net.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://www.smartonline.net.cn/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>《EffectiveJava》（四）</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/EffectiveJava3/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/EffectiveJava3/</id>
    <published>2019-11-23T08:57:33.000Z</published>
    <updated>2019-11-23T09:12:01.267Z</updated>
    
    <summary type="html">
    
      &lt;h4 id=&quot;【47】了解和使用库&quot;&gt;&lt;a href=&quot;#【47】了解和使用库&quot; class=&quot;headerlink&quot; title=&quot;【47】了解和使用库&quot;&gt;&lt;/a&gt;【47】了解和使用库&lt;/h4&gt;&lt;p&gt;不要重复发明轮子。一般而言，类库的代码可能比你自己编写的代码更好一些，并且会随着时间的推移不断改进。从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能够给予的投入。&lt;/p&gt;
&lt;p&gt;强烈需要了解的类库：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java.lang&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java.util&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java.io&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.smartonline.net.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://www.smartonline.net.cn/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>《EffectiveJava》（三）</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/EffectiveJava2/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/EffectiveJava2/</id>
    <published>2019-11-23T08:57:22.000Z</published>
    <updated>2019-11-23T09:14:12.341Z</updated>
    
    <summary type="html">
    
      &lt;h4 id=&quot;【27】优先考虑泛型方法&quot;&gt;&lt;a href=&quot;#【27】优先考虑泛型方法&quot; class=&quot;headerlink&quot; title=&quot;【27】优先考虑泛型方法&quot;&gt;&lt;/a&gt;【27】优先考虑泛型方法&lt;/h4&gt;&lt;p&gt;静态工具方法尤其适合泛型化。如实现构造器：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;V，K&amp;gt; HashMap&amp;lt;V，K&amp;gt; newHashMap() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;K，V&amp;gt;()；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.smartonline.net.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://www.smartonline.net.cn/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>《EffectiveJava》（二）</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/EffectiveJava1/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/EffectiveJava1/</id>
    <published>2019-11-23T08:57:10.000Z</published>
    <updated>2019-11-26T13:52:45.344Z</updated>
    
    <summary type="html">
    
      &lt;h4 id=&quot;【15】使可变性最小化&quot;&gt;&lt;a href=&quot;#【15】使可变性最小化&quot; class=&quot;headerlink&quot; title=&quot;【15】使可变性最小化&quot;&gt;&lt;/a&gt;【15】使可变性最小化&lt;/h4&gt;&lt;p&gt;不可变类只是实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。为了使类成为不可变，要遵循下面五条规则：&lt;/p&gt;
&lt;p&gt;&amp;lt;1&amp;gt;不要提供任何会修改对象状态的方法。&lt;/p&gt;
&lt;p&gt;&amp;lt;2&amp;gt;保证类不会被扩展。&lt;/p&gt;
&lt;p&gt;&amp;lt;3&amp;gt;使所有的域都是 final 的。&lt;/p&gt;
&lt;p&gt;&amp;lt;4&amp;gt;使所有的域都成为私有的。&lt;/p&gt;
&lt;p&gt;&amp;lt;5&amp;gt;确保对于任何可变组件的互斥访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.smartonline.net.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://www.smartonline.net.cn/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>《EffectiveJava》（一）</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/EffectiveJava/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/EffectiveJava/</id>
    <published>2019-11-23T07:25:42.000Z</published>
    <updated>2019-11-23T09:15:46.004Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、基本原则：&quot;&gt;&lt;a href=&quot;#一、基本原则：&quot; class=&quot;headerlink&quot; title=&quot;一、基本原则：&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、基本原则：&lt;/strong&gt;&lt;/h2&gt;&lt;h4 id=&quot;【1】模块的用户永远也不应该被模块的行为所迷惑&quot;&gt;&lt;a href=&quot;#【1】模块的用户永远也不应该被模块的行为所迷惑&quot; class=&quot;headerlink&quot; title=&quot;【1】模块的用户永远也不应该被模块的行为所迷惑&quot;&gt;&lt;/a&gt;【1】模块的用户永远也不应该被模块的行为所迷惑&lt;/h4&gt;&lt;h4 id=&quot;【2】模块要尽可能小，但又不能太小&quot;&gt;&lt;a href=&quot;#【2】模块要尽可能小，但又不能太小&quot; class=&quot;headerlink&quot; title=&quot;【2】模块要尽可能小，但又不能太小&quot;&gt;&lt;/a&gt;【2】模块要尽可能小，但又不能太小&lt;/h4&gt;&lt;h4 id=&quot;【3】代码应该被重用，而不是被拷贝&quot;&gt;&lt;a href=&quot;#【3】代码应该被重用，而不是被拷贝&quot; class=&quot;headerlink&quot; title=&quot;【3】代码应该被重用，而不是被拷贝&quot;&gt;&lt;/a&gt;【3】代码应该被重用，而不是被拷贝&lt;/h4&gt;&lt;h4 id=&quot;【4】模块之间的依赖性应该尽可能地降到最小&quot;&gt;&lt;a href=&quot;#【4】模块之间的依赖性应该尽可能地降到最小&quot; class=&quot;headerlink&quot; title=&quot;【4】模块之间的依赖性应该尽可能地降到最小&quot;&gt;&lt;/a&gt;【4】模块之间的依赖性应该尽可能地降到最小&lt;/h4&gt;&lt;h4 id=&quot;【5】错误应该尽早被检测出来，最好是在编译时刻&quot;&gt;&lt;a href=&quot;#【5】错误应该尽早被检测出来，最好是在编译时刻&quot; class=&quot;headerlink&quot; title=&quot;【5】错误应该尽早被检测出来，最好是在编译时刻&quot;&gt;&lt;/a&gt;【5】错误应该尽早被检测出来，最好是在编译时刻&lt;/h4&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.smartonline.net.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://www.smartonline.net.cn/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>《设计原本》</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E6%9C%AC/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E6%9C%AC/</id>
    <published>2019-11-23T07:22:34.000Z</published>
    <updated>2019-11-23T09:19:49.765Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;【1】什么是设计？Dorothy Sayers(英国作家和戏剧家)说设计有三个阶段：概念构造的形成，在真实媒质上的实现，与真正用户的交互。&lt;/p&gt;
&lt;p&gt;【2】新思想来自于将一门艺术中的领悟联系并应用到另一门艺术中，经理若干次这样的经历而有所悟，脑海里自然就孕育出了“新思想”。——培根&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.smartonline.net.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://www.smartonline.net.cn/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>《架构之美》</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/%E6%9E%B6%E6%9E%84%E4%B9%8B%E7%BE%8E/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/%E6%9E%B6%E6%9E%84%E4%B9%8B%E7%BE%8E/</id>
    <published>2019-11-23T07:16:51.000Z</published>
    <updated>2019-11-23T09:19:37.558Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;【1】形式永远服从功能。&lt;/p&gt;
&lt;p&gt;【2】好的架构的生成：&lt;/p&gt;
&lt;p&gt;​    &amp;lt;1&amp;gt;确实进行有意为之的前端设计。&lt;/p&gt;
&lt;p&gt;​    &amp;lt;2&amp;gt;设计者的素质和经验。&lt;/p&gt;
&lt;p&gt;​    &amp;lt;3&amp;gt;在开发过程中，保持清晰的设计观点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.smartonline.net.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://www.smartonline.net.cn/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>《人月神话》</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/</id>
    <published>2019-11-23T07:10:52.000Z</published>
    <updated>2019-11-23T07:21:47.490Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;【1】由一个人来进行问题的分解，其他人给予他所需要的支持，以提高效率和生产力。&lt;/p&gt;
&lt;p&gt;【2】系统的 体系结构（architecture） 指的是完整和详细的用户接口说明。&lt;/p&gt;
&lt;p&gt;对于计算机，它是编程手册；对于编译器，它是语言手册；&lt;/p&gt;
&lt;p&gt;对于控制程序，它是语言和函数调用手册；&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.smartonline.net.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://www.smartonline.net.cn/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>WING-剧情大纲</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/wing3/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/wing3/</id>
    <published>2019-11-23T01:32:20.000Z</published>
    <updated>2019-11-23T01:33:40.480Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="写作" scheme="https://www.smartonline.net.cn/categories/%E5%86%99%E4%BD%9C/"/>
    
    
      <category term="novel" scheme="https://www.smartonline.net.cn/tags/novel/"/>
    
      <category term="wing" scheme="https://www.smartonline.net.cn/tags/wing/"/>
    
  </entry>
  
  <entry>
    <title>WING-世界观</title>
    <link href="https://www.smartonline.net.cn/2019/11/23/wing2/"/>
    <id>https://www.smartonline.net.cn/2019/11/23/wing2/</id>
    <published>2019-11-23T01:26:54.000Z</published>
    <updated>2019-11-23T01:34:04.097Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="写作" scheme="https://www.smartonline.net.cn/categories/%E5%86%99%E4%BD%9C/"/>
    
    
      <category term="novel" scheme="https://www.smartonline.net.cn/tags/novel/"/>
    
      <category term="wing" scheme="https://www.smartonline.net.cn/tags/wing/"/>
    
  </entry>
  
  <entry>
    <title>WING-人设</title>
    <link href="https://www.smartonline.net.cn/2019/11/19/wing1/"/>
    <id>https://www.smartonline.net.cn/2019/11/19/wing1/</id>
    <published>2019-11-19T01:04:14.000Z</published>
    <updated>2019-11-23T01:36:19.763Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="写作" scheme="https://www.smartonline.net.cn/categories/%E5%86%99%E4%BD%9C/"/>
    
    
      <category term="novel" scheme="https://www.smartonline.net.cn/tags/novel/"/>
    
      <category term="wing" scheme="https://www.smartonline.net.cn/tags/wing/"/>
    
  </entry>
  
  <entry>
    <title>贪婪算法介绍</title>
    <link href="https://www.smartonline.net.cn/2019/11/18/greedy/"/>
    <id>https://www.smartonline.net.cn/2019/11/18/greedy/</id>
    <published>2019-11-18T12:57:57.000Z</published>
    <updated>2019-11-20T08:46:36.065Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://www.smartonline.net.cn/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>SHA(安全散列算法)简单实现</title>
    <link href="https://www.smartonline.net.cn/2019/11/18/sha/"/>
    <id>https://www.smartonline.net.cn/2019/11/18/sha/</id>
    <published>2019-11-18T12:42:00.000Z</published>
    <updated>2019-11-18T13:20:09.270Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;摘要算法：SHA 及 Java 实现样例&lt;/p&gt;
&lt;p&gt;SHA = 安全散列算法（Secure Hash Algorithm）。&lt;/p&gt;
&lt;p&gt;SHA 与 MD5 类似，都是单向不可逆散列函数，用于计算消息摘要，生成消息数字签名（指纹）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://www.smartonline.net.cn/tags/algorithm/"/>
    
      <category term="java" scheme="https://www.smartonline.net.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Diffie-Hellman（秘钥协商算法）介绍</title>
    <link href="https://www.smartonline.net.cn/2019/11/18/diffie-hellman/"/>
    <id>https://www.smartonline.net.cn/2019/11/18/diffie-hellman/</id>
    <published>2019-11-18T12:35:06.000Z</published>
    <updated>2019-11-19T00:48:49.698Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一、概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Diffie-Hellman密钥协商算法主要解决秘钥配送问题，本身并非用来加密用的；该算法其背后有对应数学理论做支撑，简单来讲就是构造一个复杂的计算难题，使得对该问题的求解在现实的时间内无法快速有效的求解（&lt;em&gt;computationally infeasible&lt;/em&gt; ）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://www.smartonline.net.cn/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Simhash算法介绍</title>
    <link href="https://www.smartonline.net.cn/2019/11/18/simhash/"/>
    <id>https://www.smartonline.net.cn/2019/11/18/simhash/</id>
    <published>2019-11-18T12:20:56.000Z</published>
    <updated>2019-11-19T00:54:23.971Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Simhash的生成及存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、背景介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据 &lt;em&gt;Detecting Near-Duplicates for Web Crawling&lt;/em&gt; 论文中的介绍，在互联网中有很多网页的内容是一样的，但是它们的网页元素却不是完全相同的。每个域名下的网页总会有一些自己的东西，比如广告、导航栏、网站版权之类的东西，但是对于搜索引擎来讲，只有内容部分才是有意义的，虽然网页元素不同，但是对搜索结果没有任何影响，所以在判定内容是否重复的时候，应该忽视后面的部分。当新爬取的内容和数据库中的某个网页的内容一样的时候，就称其为Near-Duplicates（重复文章）。对于重复文章，不应再执行入库操作，这种操作的优点是(A)节省带宽、(B)节省磁盘、(C)减轻服务器负荷以及(D)去除相似文章噪点干扰，提升索引的质量。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://www.smartonline.net.cn/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Disruptor（三）</title>
    <link href="https://www.smartonline.net.cn/2019/11/18/disruptor3/"/>
    <id>https://www.smartonline.net.cn/2019/11/18/disruptor3/</id>
    <published>2019-11-18T12:03:12.000Z</published>
    <updated>2019-11-19T00:50:59.661Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;写入 Ringbuffer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文的重点是：不要让 Ring 重叠；如何通知消费者；生产者一端的批处理；以及多个生产者如何协同工作。&lt;/p&gt;
&lt;p&gt;作者：Trisha 廖涵译&lt;/p&gt;
&lt;p&gt;这是 Disruptor 全方位解析（end-to-end view）中缺少的一章。当心，本文非常长。但是为了让你能联系上下文阅读，我还是决定把它们写进一篇博客里。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="concurrent" scheme="https://www.smartonline.net.cn/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Disruptor（二）</title>
    <link href="https://www.smartonline.net.cn/2019/11/18/disruptor2/"/>
    <id>https://www.smartonline.net.cn/2019/11/18/disruptor2/</id>
    <published>2019-11-18T11:57:31.000Z</published>
    <updated>2019-11-19T00:49:59.458Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;从Ringbuffer读取数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上一篇文章中我们都了解了什么是Ring Buffer以及它是如何的特别。但遗憾的是，我还没有讲述如何使用Disruptor向Ring Buffer写数据和从Ring Buffer中读取数据。&lt;/p&gt;
&lt;p&gt;从上一篇文章中我们都了解了什么是&lt;strong&gt;Ring Buffer&lt;/strong&gt;以及它是如何的特别。但遗憾的是，我还没有讲述如何使用&lt;strong&gt;Disruptor&lt;/strong&gt;向&lt;strong&gt;Ring Buffer&lt;/strong&gt;写数据和从&lt;strong&gt;Ring Buffer&lt;/strong&gt;中读取数据。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="concurrent" scheme="https://www.smartonline.net.cn/tags/concurrent/"/>
    
  </entry>
  
</feed>
