<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>WING-剧情大纲</title>
    <url>/2019/11/23/wing3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>wing</tag>
      </tags>
  </entry>
  <entry>
    <title>WING-世界观</title>
    <url>/2019/11/23/wing2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>wing</tag>
      </tags>
  </entry>
  <entry>
    <title>WING-人设</title>
    <url>/2019/11/19/wing1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>wing</tag>
      </tags>
  </entry>
  <entry>
    <title>贪婪算法介绍</title>
    <url>/2019/11/18/greedy/</url>
    <content><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a><strong>算法简介</strong></h2><p><strong>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。</strong></p>
<p><strong>贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。</strong></p>
<a id="more"></a>

<ul>
<li>贪婪算法并<strong>没有固定的算法解决框架</strong>，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。</li>
<li>必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。</li>
</ul>
<p>比如前边介绍的最短路径问题(<a href="https://www.jianshu.com/p/78e674161e54" target="_blank" rel="noopener">广度优先</a>、<a href="https://www.jianshu.com/p/b805e9d1eb5c" target="_blank" rel="noopener">狄克斯特拉</a>)都属于贪婪算法，只是在其问题策略的选择上，刚好可以得到最优解。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a><strong>基本思路</strong></h2><p>其基本的解题思路为：</p>
<p>1.建立数学模型来描述问题</p>
<p>2.把求解的问题分成若干个子问题</p>
<p>3.对每一子问题求解，得到子问题的局部最优解</p>
<p>4.把子问题对应的局部最优解合成原来整个问题的一个近似最优解</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h2><p>这边的案例来自”算法图解”一书</p>
<h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a><strong>案例一</strong></h3><p>区间调度问题:</p>
<p>假设有如下课程，希望尽可能多的将课程安排在一间教室里：</p>
<table>
<thead>
<tr>
<th>课程</th>
<th>开始时间</th>
<th>结束时间</th>
</tr>
</thead>
<tbody><tr>
<td>美术</td>
<td>9AM</td>
<td>10AM</td>
</tr>
<tr>
<td>英语</td>
<td>9:30AM</td>
<td>10:30AM</td>
</tr>
<tr>
<td>数学</td>
<td>10AM</td>
<td>11AM</td>
</tr>
<tr>
<td>计算机</td>
<td>10:30AM</td>
<td>11:30AM</td>
</tr>
<tr>
<td>音乐</td>
<td>11AM</td>
<td>12PM</td>
</tr>
</tbody></table>
<p>这个问题看似要思考很多，实际上算法很简单:</p>
<p>1.选择<strong>结束最早</strong>的课，便是要在这教室上课的第一节课</p>
<p>2.接下来，选择第一堂课结束后才开始的课，并且结束最早的课，这将是第二节在教室上的课。</p>
<p><img src="../../../../asserts/4b066988419.webp" alt="img"></p>
<p>重复这样做就能找出答案，这边的选择策略便是结束最早且和上一节课不冲突的课进行排序，因为每次都选择结束最早的，所以留给后面的时间也就越多，自然就能排下越多的课了。</p>
<p>每一节课的选择都是策略内的局部最优解(留给后面的时间最多)，所以最终的结果也是近似最优解(这个案例上就是最优解)。</p>
<p>(该案例的代码实现，就是一个简单的时间遍历比较过程)</p>
<h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a><strong>案例二</strong></h3><p>背包问题：有一个背包，容量为35磅 ， 现有如下物品</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>重量</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>吉他</td>
<td>15</td>
<td>1500</td>
</tr>
<tr>
<td>音响</td>
<td>30</td>
<td>3000</td>
</tr>
<tr>
<td>笔记本电脑</td>
<td>20</td>
<td>2000</td>
</tr>
<tr>
<td>显示器</td>
<td>29</td>
<td>2999</td>
</tr>
<tr>
<td>笔</td>
<td>1</td>
<td>200</td>
</tr>
</tbody></table>
<p>要求达到的目标为装入的背包的总价值最大，并且重量不超出。</p>
<p>方便计算所以只有3个物品，实际情况可能是成千上万。</p>
<p>同上使用贪婪算法，因为要总价值最大，所以每次每次都装入最贵的,然后在装入下一个最贵的，选择结果如下：</p>
<p>选择: 音响 + 笔，总价值 3000 + 200 = 3200</p>
<p>并不是最优解: 吉他 + 笔记本电脑, 总价值 1500 + 2000 = 3500</p>
<p>当然选择策略有时候并不是很固定，可能是如下：</p>
<p>(1)每次挑选价值最大的,并且最终重量不超出：</p>
<p>选择: 音响 + 笔，总价值 3000 + 200 = 3200</p>
<p>(2)每次挑选重量最大的,并且最终重量不超出(可能如果要求装入最大的重量才会优先考虑)：</p>
<p>选择: 音响 + 笔，总价值 3000 + 200 = 3200</p>
<p>(3)每次挑选单位价值最大的(价格/重量),并且最终重量不超出：</p>
<p>选择: 笔+ 显示器，总价值 200 + 2999 = 3199</p>
<p>如上最终的结果并不是最优解，在这个案例中贪婪算法并无法得出最优解，只能得到近似最优解,也算是该算法的<strong>局限性之一</strong>。该类问题中需要得到最优解的话可以采取动态规划算法(后续更新，也可以关注我的公众号第一时间获取更新信息)。</p>
<h3 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a><strong>案例三</strong></h3><p>集合覆盖问题:</p>
<p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。</p>
<p>如何选择最少的广播台，让所有的地区都可以接收到信号。</p>
<table>
<thead>
<tr>
<th>广播台</th>
<th>覆盖地区</th>
</tr>
</thead>
<tbody><tr>
<td>K1</td>
<td>ID,NV,UT</td>
</tr>
<tr>
<td>K2</td>
<td>WA,ID,MT</td>
</tr>
<tr>
<td>K3</td>
<td>OR,NV,CA</td>
</tr>
<tr>
<td>K4</td>
<td>NV,UT</td>
</tr>
<tr>
<td>K5</td>
<td>CA,AZ</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><img src="../../../../asserts/ce3bfe6cde9.webp" alt="img"></p>
<p>如何找出覆盖所有地区的广播台的集合呢，听起来容易，实现起来很复杂，使用穷举法实现：</p>
<p>(1) 列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2ⁿ个【由组合及二项式定理得出：C(n,1)+C(n,2)+C(n,3)+…+C(n,n) = 2^n】</p>
<p>(2) 在这些集合中，选出覆盖全部地区的最小的集合，假设n不在，但是当n非常大的时候，假设每秒可以计算10个子集</p>
<table>
<thead>
<tr>
<th>广播台数量n</th>
<th>子集总数2ⁿ</th>
<th>需要的时间</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>32</td>
<td>3.2秒</td>
</tr>
<tr>
<td>10</td>
<td>1024</td>
<td>102.4秒</td>
</tr>
<tr>
<td>32</td>
<td>4294967296</td>
<td>13.6年</td>
</tr>
<tr>
<td>100</td>
<td>1.26*100³º</td>
<td>4x10²³年</td>
</tr>
</tbody></table>
<p>目前并没有算法可以快速计算得到准备的值，</p>
<p>而使用贪婪算法，则可以得到非常接近的解，并且效率高:</p>
<p>选择策略上，因为需要覆盖全部地区的最小集合:</p>
<p>(1) 选出一个广播台，即它覆盖了最多未覆盖的地区即便包含一些已覆盖的地区也没关系</p>
<p>(2) 重复第一步直到覆盖了全部的地区</p>
<p>这是一种近似算法（approximation algorithm，贪婪算法的一种）。在获取到精确的最优解需要的时间太长时，便可以使用近似算法，判断近似算法的优劣标准如下:</p>
<ul>
<li>速度有多快</li>
<li>得到的近似解与最优解的接近程度</li>
</ul>
<p>在本例中贪婪算法是个不错的选择，不仅运行速度快，本例运行时间O(n²),最坏的情况，假设n个广播台，每个广播台就覆盖1个地区,n个地区，总计需要查询n*n=O(n²),实现可查看后面的java代码实现</p>
<table>
<thead>
<tr>
<th>广播台数量n</th>
<th>子集总数2ⁿ</th>
<th>穷举需要时间</th>
<th>贪婪算法</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>32</td>
<td>3.2秒</td>
<td>2.5秒</td>
</tr>
<tr>
<td>10</td>
<td>32</td>
<td>102.4秒</td>
<td>10秒</td>
</tr>
<tr>
<td>32</td>
<td>32</td>
<td>13.6年</td>
<td>102.4秒</td>
</tr>
<tr>
<td>100</td>
<td>32</td>
<td>4x10²³年</td>
<td>1000秒</td>
</tr>
</tbody></table>
<p>此时算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区，可能不是预期中的K2, K3,K4,K5(也许预期中的更便宜，更便于实施等等)</p>
<h2 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a><strong>NP完全问题</strong></h2><h3 id="案例四"><a href="#案例四" class="headerlink" title="案例四"></a><strong>案例四</strong></h3><p>旅行商问题</p>
<p>假设有旅行商需要从下面三个城市的某一个城市出发，如何规划路线获取行程的最短路径。</p>
<p><img src="../../../../asserts/1505a09f64e.webp" alt="img"></p>
<p>存在3！(阶乘)=6种可能情况:</p>
<p>A-&gt;B-&gt;C A-&gt;C-&gt;B B-&gt;A-&gt;C B-&gt;C-&gt;A C-&gt;A-&gt;B C-&gt;B-&gt;A </p>
<p>这边和之前求最短路径的算法(广度搜索、狄克斯特拉、贝尔曼-福特)，最大的差别是没有固定源点(起点),，每一个节点都可能是源点，并且需要经过每一个节点，所以若穷举法则不得不找出每一种可能并进行比较。</p>
<p>当城市数量为n,则可能性为n!，假设每秒处理判断一个路线</p>
<table>
<thead>
<tr>
<th>数量n</th>
<th>总数n!</th>
<th>穷举需要时间</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>120</td>
<td>120秒</td>
</tr>
<tr>
<td>10</td>
<td>32</td>
<td>42天</td>
</tr>
</tbody></table>
<p>而使用贪婪算法，随机选择从一个城市出发，比如A，每次选择从最近的还没去过的城市出发,则可以得到近似最优解。</p>
<p>第一次比较n-1个城市</p>
<p>第二次比较n-2个城市</p>
<p>…</p>
<p>第n-1次比较1个城市</p>
<p>第n次不存在需要比较的了个</p>
<p>0+1+2+3+..+(n-1) ≈ O(n²/2)</p>
<table>
<thead>
<tr>
<th>数量n</th>
<th>总数n!</th>
<th>穷举需要时间</th>
<th>贪婪需要时间</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>120</td>
<td>120秒</td>
<td>12.5秒</td>
</tr>
<tr>
<td>10</td>
<td>32</td>
<td>42天</td>
<td>50秒</td>
</tr>
</tbody></table>
<p>类似上述集合覆盖问题、旅行商问题，都属于NP完全问题，在数学领域上并没有快速得到最优解的方案，贪婪算法是最适合处理这类问题的了。</p>
<h2 id="如何判断是NP完全问题的"><a href="#如何判断是NP完全问题的" class="headerlink" title="如何判断是NP完全问题的:"></a><strong>如何判断是NP完全问题的:</strong></h2><p>1.元素较少时，一般运行速度很快，但随着元素数量增多，速度会变得非常慢</p>
<p>2.涉及到需要计算比较”所有的组合”情况的通常是NP完全问题</p>
<p>3.无法分割成小问题，必须考虑各种可能的情况。这可能是NP完全问题</p>
<p>4.如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题</p>
<p>5.如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题</p>
<p>6.如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>1.贪婪算法可以寻找局部最优解，并尝试与这种方式获得全局最优解</p>
<p>2.得到的可能是近似最优解，但也可能便是最优解(区间调度问题，最短路径问题(<a href="https://juejin.im/post/5b64630ae51d45190b61d79a" target="_blank" rel="noopener">广度优先</a>、<a href="https://juejin.im/post/5b7000ab6fb9a009bd03cb79" target="_blank" rel="noopener">狄克斯特拉</a>))</p>
<p>3.对于完全NP问题，目前并没有快速得到最优解的解决方案</p>
<p>4.面临NP完全问题，最佳的做法就是使用近似算法</p>
<p>5.贪婪算法(近似算法)在大部分情况下易于实现，并且效率不错</p>
<h2 id="JAVA-实现"><a href="#JAVA-实现" class="headerlink" title="JAVA 实现"></a><strong>JAVA 实现</strong></h2><p>贪婪算法需要根据具体问题，选择对应的策略来实现，所以这边只取集合覆盖问题做个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 贪婪算法 - 集合覆盖问题 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment">* */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greedy</span> </span>&#123;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        </span><br><span class="line">        <span class="comment">//初始化广播台信息        </span></span><br><span class="line">        HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span>  </span><br><span class="line">            HashMap&lt;String,HashSet&lt;String&gt;&gt;();        </span><br><span class="line">        broadcasts.put(<span class="string">"K1"</span>,  </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"ID"</span>,<span class="string">"NV"</span>,<span class="string">"UT"</span>&#125;)));  </span><br><span class="line">        broadcasts.put(<span class="string">"K2"</span>, </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"WA"</span>,<span class="string">"ID"</span>,<span class="string">"MT"</span>&#125;)));  </span><br><span class="line">        broadcasts.put(<span class="string">"K3"</span>, </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"OR"</span>,<span class="string">"NV"</span>,<span class="string">"CA"</span>&#125;)));  </span><br><span class="line">        broadcasts.put(<span class="string">"K4"</span>, </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"NV"</span>,<span class="string">"UT"</span>&#125;)));  </span><br><span class="line">        broadcasts.put(<span class="string">"K5"</span>, </span><br><span class="line">            <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"CA"</span>,<span class="string">"AZ"</span>&#125;)));  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需要覆盖的全部地区        </span></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[]  </span><br><span class="line">             &#123;<span class="string">"ID"</span>,<span class="string">"NV"</span>,<span class="string">"UT"</span>,<span class="string">"WA"</span>,<span class="string">"MT"</span>,<span class="string">"OR"</span>,<span class="string">"CA"</span>,<span class="string">"AZ"</span>&#125;));   </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//所选择的广播台列表        </span></span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;String&gt;();        </span><br><span class="line">        String maxKey = <span class="keyword">null</span>;        </span><br><span class="line">        <span class="keyword">while</span>(allAreas.size()!=<span class="number">0</span>) &#123;            </span><br><span class="line">            maxKey = <span class="keyword">null</span>;            </span><br><span class="line">            <span class="keyword">for</span>(String key : broadcasts.keySet()) &#123;  </span><br><span class="line">                tempSet.clear();  </span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);  </span><br><span class="line">                tempSet.addAll(areas);  </span><br><span class="line">                                                   </span><br><span class="line">                <span class="comment">//求出2个集合的交集，此时tempSet会被赋值为交集的内容，所以使用临时变量  </span></span><br><span class="line">                tempSet.retainAll(allAreas);                </span><br><span class="line">                <span class="comment">//如果该集合包含的地区数量比原本的集合多                </span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size()&gt;<span class="number">0</span> &amp;&amp; (maxKey == <span class="keyword">null</span> || tempSet.size() &gt;  </span><br><span class="line">                                         broadcasts.get(maxKey).size())) &#123;                    </span><br><span class="line">                    maxKey = key;                </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;                        </span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);  </span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.print(<span class="string">"selects:"</span> + selects);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完main方法打印信息如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selects:[K1, K2, K3, K5]</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html" target="_blank" rel="noopener">https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/fede80bad3f1" target="_blank" rel="noopener">https://www.jianshu.com/p/fede80bad3f1</a></p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>SHA(安全散列算法)简单实现</title>
    <url>/2019/11/18/sha/</url>
    <content><![CDATA[<p>摘要算法：SHA 及 Java 实现样例</p>
<p>SHA = 安全散列算法（Secure Hash Algorithm）。</p>
<p>SHA 与 MD5 类似，都是单向不可逆散列函数，用于计算消息摘要，生成消息数字签名（指纹）。</p>
<a id="more"></a>

<p>Algorithm    散列值长度（单位比特）</p>
<table>
<thead>
<tr>
<th>SHA-1</th>
<th>160</th>
</tr>
</thead>
<tbody><tr>
<td>SHA-224</td>
<td>224</td>
</tr>
<tr>
<td>SHA-256</td>
<td>256</td>
</tr>
<tr>
<td>SHA-384</td>
<td>384</td>
</tr>
<tr>
<td>SHA-512</td>
<td>512</td>
</tr>
</tbody></table>
<p>Java 实现样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySHA</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub         </span></span><br><span class="line">        String msg = <span class="string">"0123456789abcdef"</span>;         </span><br><span class="line">        MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA"</span>);  </span><br><span class="line">        sha.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []shaBin = sha.digest();            </span><br><span class="line">        printBytes(shaBin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha1 = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);  </span><br><span class="line">        sha1.update(msg.getBytes());            </span><br><span class="line">        printBytes(sha1Bin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha224 = MessageDigest.getInstance(<span class="string">"SHA-224"</span>);  </span><br><span class="line">        sha224.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []sha224Bin = sha224.digest();            </span><br><span class="line">        printBytes(sha224Bin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha256 = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);  </span><br><span class="line">        sha256.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []sha256Bin = sha256.digest();            </span><br><span class="line">        printBytes(sha256Bin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha384 = MessageDigest.getInstance(<span class="string">"SHA-384"</span>);  </span><br><span class="line">        sha384.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []sha384Bin = sha384.digest();            </span><br><span class="line">        printBytes(sha384Bin);</span><br><span class="line">        </span><br><span class="line">        MessageDigest sha512 = MessageDigest.getInstance(<span class="string">"SHA-512"</span>);  </span><br><span class="line">        sha512.update(msg.getBytes());            </span><br><span class="line">        <span class="keyword">byte</span> []sha512Bin = sha512.digest();            </span><br><span class="line">        printBytes(sha512Bin);        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**     </span></span><br><span class="line"><span class="comment">* 十六进制打印字节数组     </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> b byte[]     </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBytes</span><span class="params">(<span class="keyword">byte</span>[] b)</span>    </span>&#123;        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)        &#123;            </span><br><span class="line">        System.out.printf(<span class="string">"%02X"</span>, b[i]);        </span><br><span class="line">    &#125;        </span><br><span class="line">    System.out.println();    </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注：散列值都是按照十六进制大写字母编码表示</p>
<p>很多人肯定会出来反驳，加密简单的123456可以在某些解密网站直接解密出来。</p>
<p>在这样的情况下，我们可以尝试在字符串追加其他文字如<strong>yangzhangyin</strong>，实际如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger; </span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SHAEncryption</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptSHA(<span class="keyword">byte</span>[] data, String shaN) </span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;         </span><br><span class="line">        MessageDigest sha = MessageDigest.getInstance(shaN);  </span><br><span class="line">        sha.update(data);        </span><br><span class="line">        <span class="keyword">return</span> sha.digest();     </span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptFlychordPwd</span><span class="params">(String str)</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">byte</span>[] outputData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];            </span><br><span class="line">        <span class="keyword">try</span> &#123;                </span><br><span class="line">            outputData =  encryptSHA((str+<span class="string">"yangzhangyin"</span>).getBytes(), </span><br><span class="line">                                     <span class="string">"SHA-256"</span>);                </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="number">1</span>, outputData).toString(<span class="number">16</span>);            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;                </span><br><span class="line">            e.printStackTrace();            </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;        </span><br><span class="line">    &#125;                </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//加密123456</span></span><br><span class="line">        System.out.println(ss.encryptFlychordPwd(<span class="string">"123456"</span>));          </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就解决了简单密码被解密的问题啦。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Diffie-Hellman（秘钥协商算法）介绍</title>
    <url>/2019/11/18/diffie-hellman/</url>
    <content><![CDATA[<p><strong>一、概述</strong></p>
<p>Diffie-Hellman密钥协商算法主要解决秘钥配送问题，本身并非用来加密用的；该算法其背后有对应数学理论做支撑，简单来讲就是构造一个复杂的计算难题，使得对该问题的求解在现实的时间内无法快速有效的求解（<em>computationally infeasible</em> ）。</p>
<a id="more"></a>

<p>理解Diffie-Hellman密钥协商的原理并不困难，只需要一点数论方面的知识既可以理解，主要会用到简单的模算术运算、本原根、费马小定理、离散对数等基础数论的知识。在<a href="http://www.cnblogs.com/qcblog/p/8976017.html" target="_blank" rel="noopener"><strong>现代密码学中的基础数论知识梳理</strong></a>中已经对这些知识做了必要的总结。</p>
<p> <strong>二、从何而来</strong></p>
<p>DH密钥协商算法在1976年在Whitfield Diffie和Martin Hellman两人合著的论文<strong>New Directions in Cryptography</strong>（Section Ⅲ PUBLIC KEY CRYPTOGRAPHY）中被作为一种公开秘钥分发系统(<em>public key distribution system</em>)被提出来。原文的叙述过程比较简单，但基本阐述了算法的原理以及其可行性。</p>
<p>在该论文中实际上提出了一些在当时很有创新性的思想。原论文重点讨论两个话题：</p>
<p>（1）在公网通道上如何进行安全的秘钥分派。</p>
<p>（2）认证（可以细分为消息认证和用户认证）。</p>
<p>为了解决第一个问题，原文提出两种方法：公钥加密系统(<em>public key cryptosystem</em>)和秘钥分发系统(<em>public key distribution system</em>)。对于公钥加密系统，原文只是勾画了一种比较抽象的公钥加密系统的概念模型，重点是加解密采用不同的秘钥，并总结了该系统应该满足的一些特性，相当于是一种思想实验，并没有给出具体的算法实现途径，但这在当时应该来说已经足够吸引人。后来RSA三人组（Ron Rivest、Adi Shamir 和 Leonard Adleman）受此启发，经过许多轮失败的尝试后，于第二年在论文<strong>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</strong>中提出了切实可行且很具体的公钥加密算法–RSA公钥加密算法。而对于秘钥分发系统，就是本文的DH秘钥协商算法。</p>
<p>为了解决第二个问题，原文通过单向函数（one-way function）来解决，这就是单向认证的问题。另外作者还讨论了这些密码学问题之间的关联性以及如何相互转化。比如一个安全的密码系统（可以防御明文攻击）可以用来生成一个的单向函数、公钥加密系统可以用来作为单向认证、陷门密码系统可以用来生成一个公钥加密系统。数学难题的计算复杂度被当成一种保障密码学安全问题的有效工具被利用起来，这一重要思想贯穿现代密码学的许多加密算法。</p>
<p><strong>三、算法流程及原理</strong></p>
<p>按照惯例，以Alice和Bob这两个密码学中的网红为角色，述阐DH算法的流程。</p>
<p>假设Alice需要与Bob协商一个秘钥（秘钥本质上就是一个比特序列，从计算的角度看就是一个大数）。</p>
<p>1）首先Alice与Bob共享一个素数p以及该素数p的本原根g（geneator），当然这里有2⩽g⩽p−1。这两个数是可以不经过加密地由一方发送到另一方，至于谁发送给并不重要，其结果只要保证双方都得知p和g即可。</p>
<p><img src="../../../../asserts/5-1377258439.png" alt="img"></p>
<p>2）然后Alice产生一个私有的随机数A，满足1⩽A⩽p−1，然后计算gAmodp=Ya，将结果Ya通过公网发送给Bob；与此同时，Bob也产生一个私有的随机数B，满足1⩽B⩽p−1，计算gBmodp=Yb，将结果Yb通过公网发送给Alice。</p>
<p><img src="../../../../asserts/9-1497141203.png" alt="img"></p>
<p>3）此时Alice知道的信息有p,g,A,Ya，其中数字A是Alice私有的，只有她自己知道，别人不可能知道，其他三个信息都是别人有可能知道的；Bob知道的信息有p,g,B,Yb，其中数字B是Bob私有的，只有他自己知道，别人不可能知道，其他都是别人有可能知道的。</p>
<p>到目前为止，Alice和Bob之间的秘钥协商结束。</p>
<p>Alice通过计算Ka=(Yb)Amodp得到秘钥Ka，同理，Bob通过计算Kb=(Ya)Bmodp得到秘钥Kb，此时可以证明，必然满足Ka=Kb。因此双方经过协商后得到了相同的秘钥，达成秘钥协商的目的。</p>
<p> 证明：</p>
<p>对于Alice有：</p>
<p>Ka=(Yb)Amodp=(gBmodp)Amodp=gB×Amodp</p>
<p>对于Bob有：</p>
<p>Kb=(Ya)Bmodp=(gAmodp)Bmodp=gA×Bmodp</p>
<p>可见，Alice和Bob生成秘钥时其实是进行相同的运算过程，因此必然有Ka=Kb。”相同的运算过程”是双方能够进行秘钥协商的本质原因，类似的利用椭圆曲线进行秘钥协商也是与之相同的原理。</p>
<p>更严密地考虑，A和B不应该选择p−1，也就是说只能在集合{1,2,3,…,p−2}中选择。这是因为如果选择p−1，那么由费马小定理可知，情况就退化成了gp−1≡1(modp)的情况，对秘钥协商的机密性构成威胁。</p>
<p>所以总结起来，整个流程串起来大概就是这样：</p>
<p><img src="../../../../asserts/8-2035633054.png" alt="img"></p>
<p>那么窃听者Eve能否破解秘钥呢？首先要知道Eve能够得知哪些信息，显然Eve能够窃听到的信息只能有p,g,Ya,Yb，现在的问题是Eve能够通过以上信息计算出Ka或者Kb吗？要计算Ka或者Kb需要知道A或者B。</p>
<p>以计算A为例，Eve能根据条件gAmodp=Ya计算出A吗？实际上当p是大质数的时候，这是相当困难的，这就是离散对数问题。实际上在论文发表的当时，计算该问题的最有效的算法的时间复杂度大约是O(p–√)。也正是求解该问题在计算上的困难程度保证了DH算法的安全性。如果能够找到对数时间复杂度的算法，那么该算法即容易被攻破。</p>
<p><strong>四、一个实例</strong></p>
<p>1）假设Alice和Bob共享的p和g分别是p=17,g=3，显然这里g=3是p=17的一个本原根，实际上3,5,6,7,10,11,12,14都是17的本原根。</p>
<p>2）然后Alice选定一个私有数字，假设A=15，计算Ya=315mod17=14348907mod17=6，将6发送给Bob；同时Bob也选定一个私有的数字，假设B=13，计算Ya=313mod17=1594323mod17=12，将12发送给Alice。</p>
<p>3）Alice计算秘钥Ka=1215mod17=2147483647mod17=8，Bob计算秘钥Kb=613mod17=2147483647mod17=8。双方经过协商后，8最终成为双方的协商的秘钥。</p>
<p>实际上，当指数和模数的位数都比较大的时候，存在一种快速计算幂取模的算法叫做“反复平方算法”，实现取来也比较简单，在<strong>算法导论</strong>中第三十一章有相应的解释。</p>
<p><strong>五、存在的问题</strong></p>
<p> 是否DH秘钥协商算法就一定安全呢？应该说也不是，因为存在一种伪装者攻击（或者称为中间人攻击）能够对这种秘钥协商算法构成威胁。</p>
<p>假设秘钥协商过程中，在Alice和Bob中间有一个称为Mallory的主动攻击者，他能够截获Alice和Bob的消息并伪造假消息，考虑如下情况。</p>
<p>1）Alice和Bob已经共享一个素数p及其该素数p的本原根g，当然Mallory监听到报文也得知了这两个消息。</p>
<p>2）此时Alice计算Ya=gAmodp，然而在将Ya发送给Bob的过程中被Mallory拦截，Mallory自己选定一个随机数S，计算Ysb=gSmodp，然后将Ysb发送给了Bob。</p>
<p><img src="../../../../asserts/2-1457088379.png" alt="img"></p>
<p>3）同时Bob计算Yb=gBmodp，然而在将Yb发送给Alice的过程中被Mallory拦截，Mallory自己选定一个随机数T，计算Yta=gTmodp，然后将Yta发送给了Alice。</p>
<p><img src="../../../../asserts/82-320719224.png" alt="img"></p>
<p>由于通讯消息被替换，Alice计算出的秘钥实际上是Alice和Mallory之间协商秘钥：Kam=gA×Tmodp；Bob计算出的秘钥实际上是Bob与Mallory之间协商的秘钥：Kbm=gB×Smodp。如果之后Alice和Bob用他们计算出的秘钥加密任何信息，Mallory截获之后都能够解密得到明文，而且Mallory完全可以伪装成Alice或者Bob给对方发消息。</p>
<p><strong>六、References</strong></p>
<p>1、<a href="https://www.cis.upenn.edu/~nadiah/courses/cis800-02-f13/readings/diffie-hellman.pdf" target="_blank" rel="noopener">New Directions in Cryptography</a></p>
<p>2、密码编码学与网络安全原理与实践</p>
<p>3、图解密码技术</p>
<p>原文出处：<a href="http://www.cnblogs.com/qcblog/p/9016704.html" target="_blank" rel="noopener">http://www.cnblogs.com/qcblog/p/9016704.html</a></p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Simhash算法介绍</title>
    <url>/2019/11/18/simhash/</url>
    <content><![CDATA[<p><strong>Simhash的生成及存储</strong></p>
<p><strong>一、背景介绍</strong></p>
<p>根据 <em>Detecting Near-Duplicates for Web Crawling</em> 论文中的介绍，在互联网中有很多网页的内容是一样的，但是它们的网页元素却不是完全相同的。每个域名下的网页总会有一些自己的东西，比如广告、导航栏、网站版权之类的东西，但是对于搜索引擎来讲，只有内容部分才是有意义的，虽然网页元素不同，但是对搜索结果没有任何影响，所以在判定内容是否重复的时候，应该忽视后面的部分。当新爬取的内容和数据库中的某个网页的内容一样的时候，就称其为Near-Duplicates（重复文章）。对于重复文章，不应再执行入库操作，这种操作的优点是(A)节省带宽、(B)节省磁盘、(C)减轻服务器负荷以及(D)去除相似文章噪点干扰，提升索引的质量。</p>
<a id="more"></a>

<p>在现实中，一模一样的网页的概率是很小的，大部分的相似网页都会存在一些细节的变化，而如何进行这种判定就是一个本文要解决的一个问题。除了近似文章判定算法的难题，还有以下待解决的难点（按照80亿篇文章来考虑）：</p>
<ul>
<li>数据规模巨大，对于海量数据如何存储</li>
<li>查找速度，如何做到在毫秒级别返回检索结果</li>
</ul>
<p><strong>二、simhash介绍</strong></p>
<p>simhash是由 Charikar 在2002年提出来的，它是一种能计算文档相似度的hash算法，google用它来进行海量文本去重工作。simhash属于局部敏感型（locality sensitive hash）的一种，其主要思想是降维，将高维的特征向量转化成一个<strong>f</strong>位的指纹（fingerprint），通过算出两个指纹的海明距离（hamming distince）来确定两篇文章的相似度，海明距离越小，相似度越低（根据 <em>Detecting Near-Duplicates for Web Crawling</em> 论文中所说），一般海明距离为3就代表两篇文章相同。</p>
<p>simhash也有其局限性，在处理小于500字的短文本时，simhash的表现并不是很好，所以在使用simhash前一定要注意这个细节。</p>
<p><strong>三、simhash与hash算法的区别</strong></p>
<p>传统Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统hash算法产生的两个签名，如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。</p>
<p>　　我们主要解决的是文本相似度计算，要比较的是两个文章是否相似，当然我们降维生成了hash签名也是用于这个目的。看到这里，估计大家就明白了，即使把文章中的字符串变成 01 串，我们使用的simhash算法也还是可以用于计算相似度，而传统的hash却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。</p>
<p>通过simhash计算结果为：</p>
<p>　　1000010010101101111111100000101011010001001111100001001011001011</p>
<p>　　1000010010101101011111100000101011010001001111100001101010001011</p>
<p>通过传统hash计算为：</p>
<p>　　0001000001100110100111011011110</p>
<p>　　1010010001111111110010110011101</p>
<p>大家可以看得出来，相似的文本只有部分 01 串变化了，而普通的hash却不能做到，这个就是局部敏感哈希的魅力。</p>
<p><strong>四、simhash的生成</strong></p>
<p>simhash的生成图解如下图：</p>
<p><img src="../../../../asserts/ashgenerate.jpeg" alt="img"></p>
<p>为了更加通俗易懂，采用例子来详解simhash的生成规则。simhash的生成划分为五个步骤：<strong>分词-&gt;hash-&gt;加权-&gt;合并-&gt;降维</strong></p>
<ul>
<li>1：分词。首先，判断文本分词，形成这个文章的特征单词。然后，形成去掉噪音词的单词序列。最后，为每个分词加上权重。我们假设权重分为5个级别（1~5），比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==&gt; 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。</li>
<li>2：hash。通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101，“51区”通过hash算法计算为 101011。这样，我们的字符串就变成了一串串数字，还记得文章开头说过的吗？要把文章变为数字计算，才能提高相似度计算性能，现在是降维过程进行时。</li>
<li>3：加权。在第2步骤hash生成结果后，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。</li>
<li>4：合并。把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实的计算需要把所有单词的序列串累加。</li>
<li>5：降维。把第4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于或等于0 则记为 0。最后算出结果为：“1 0 1 0 1 1”。</li>
</ul>
<p>整个过程的流程图为：</p>
<p><img src="../../../../asserts/hashgenerate.png" alt="img"></p>
<p><strong>五、simhash分表存储策略</strong></p>
<p>在线上查询算法中，首先建立多个指纹表:T1，T2，√…，Tt。每个指纹表 Ti 关联两个未知数：一个整型pi和一个在f bit-positions上的排列πi，Ti就是对已经存在的所有指纹进行排列πi得到的有序集合。对于一个指纹f和一个整数k，算法分两个步骤：</p>
<ul>
<li>1 找到Ti中所有的前pi个bit-positions和πi（F）的前pi个bit-positions相同的指纹，假设为指纹集合F。</li>
<li>2 在F中的每一个指纹，比较其是否和πi（F）有的差异不超过k个。</li>
</ul>
<p><strong>分表存储原理</strong></p>
<p>借鉴“hashmap算法找出可以hash的key值”。因为我们使用的simhash是局部敏感哈希，这个算法的特点是：只要相似的字符串，只有个别的位数是有差别变化的。这样，我们可以推断两个相似的文本，至少有16位的simhash是一样的。</p>
<p><strong>分表存储设计</strong></p>
<p>假设f = 64 ，k=3，并且我们有80亿 = 2^34个数的网页指纹，d=34，可以有下面四种设计方法 （f：指纹位数，k：海明距离，d：将文章数量转化成2的幂次方，d就是幂值）</p>
<p>1.20个表：将64bit分为11,11,11,11,10,10六个bit块。根据排列组合，如果想从这6个块中找3个作为leading bits的话（这样才能满足|pi-d|是个小整数），一共有C(6,3)=20种找法，所以需要20个表，每个表的前三块来自不同的三个块，那么pi就有11+11+11、11+ 11+10和11+10+10三种可能了。一次嗅探平均需要检索2^(34-31)=8个指纹。</p>
<p>2.16个表：先将64bit均分成4份，然后针对每份，将剩余的48bit再均分成四份，也就是16,12,12,12,12,12五部分，很明显这种组合的可能是4*4，而pi = 28。一次嗅探平均需要检索2^(34-28)=64个指纹。</p>
<p>3.10个表：将64bit分成 13，13，13，13，12 五个bit快。根据排列组合，需要从5块中找到2个作为leading bits，共有C(5,2)=10种找法，需要10张表，而pi=25或26。一次嗅探平均需要检索2^(34-25)=512个指纹。</p>
<p>4.4个表：同理 64 等分为4份，每份16bit，从四份中找出1个leading bits，共有C(4,1)=4种找法，pi=16,一次嗅探平均需要检索2^(34-16)=256K个指纹。</p>
<p><strong>分表存储实现</strong></p>
<p><img src="../../../../asserts/simhashstore.png" alt="img"></p>
<p>存储：</p>
<p>　　1、将一个64位的simhash签名拆分成4个16位的二进制码。（图上红色的16位）</p>
<p>　　2、分别拿这4个16位二进制码查找当前对应位置上是否有元素。（放大后的16位）</p>
<p>　　3、对应位置没有元素，直接追加到链表上；对应位置有则直接追加到链表尾端。（图上的 S1 — SN）</p>
<p>　　查找：</p>
<p>　　1、将需要比较的simhash签名拆分成4个16位的二进制码。</p>
<p>　　2、分别拿着4个16位二进制码每一个去查找simhash集合对应位置上是否有元素。</p>
<p>　　3、如果有元素，则把链表拿出来顺序查找比较，直到simhash小于一定大小的值，整个过程完成。</p>
<p>　　原理：</p>
<p>　　借鉴“hashmap算法找出可以hash的key值”。因为我们使用的simhash是局部敏感哈希，这个算法的特点是：只要相似的字符串，只有个别的位数是有差别变化的。那这样我们可以推断两个相似的文本，至少有16位的simhash是一样的。具体选择16位、8位、4位，大家根据自己的数据测试选择，虽然比较的位数越小越精准，但是空间会变大。分为4个16位段的存储空间是单独simhash存储空间的4倍。之前算出5000w数据是 382 Mb，扩大4倍1.5G左右，还可以接受</p>
<p><strong>最佳分表策略</strong></p>
<p>根据 4.2节分表存储设计，给定 f,k 我们可以有很多种分表的方式，增加表的个数会减少检索时间，但是会增加内存的消耗，相反的，减少表的个数，会减少内存的压力，但是会增加检索时间。</p>
<p>根据google大量的实验，存在一个分表策略满足时间和空间的平衡点</p>
<p><img src="../../../../asserts/simhashont.png" alt="img"></p>
<p>τ=d-pi （<strong>pi计算看4.2章节，取最小pi</strong>）</p>
<p><strong>simhash存储实现(Go)</strong></p>
<p>国外有一大神用go实现了d=3和6的实现，在他的基础上我实现了d到8的扩展，源码请看<a href="https://github.com/kricen/shstorage" target="_blank" rel="noopener">https://github.com/kricen/shstorage</a></p>
<p><strong>参考文章</strong></p>
<p>论文 Detecting Near-Duplicates for Web Crawling</p>
<p><a href="http://www.cnblogs.com/maybe2030/p/5203186.html" target="_blank" rel="noopener">http://www.cnblogs.com/maybe2030/p/5203186.html</a></p>
<p>原文链接：<a href="https://kricen.github.io/2018/03/06/perday/simhash/" target="_blank" rel="noopener">https://kricen.github.io/2018/03/06/perday/simhash/</a></p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Disruptor（三）</title>
    <url>/2019/11/18/disruptor3/</url>
    <content><![CDATA[<p><strong>写入 Ringbuffer</strong></p>
<p>本文的重点是：不要让 Ring 重叠；如何通知消费者；生产者一端的批处理；以及多个生产者如何协同工作。</p>
<p>作者：Trisha 廖涵译</p>
<p>这是 Disruptor 全方位解析（end-to-end view）中缺少的一章。当心，本文非常长。但是为了让你能联系上下文阅读，我还是决定把它们写进一篇博客里。</p>
<a id="more"></a>

<p>本文的 <strong>重点</strong> 是：不要让 Ring 重叠；如何通知消费者；生产者一端的批处理；以及多个生产者如何协同工作。</p>
<p><strong>ProducerBarriers</strong></p>
<p>Disruptor 代码 给 <strong>消费者</strong> 提供了一些接口和辅助类，但是没有给写入 Ring Buffer 的 <strong>生产者</strong> 提供接口。这是因为除了你需要知道生产者之外，没有别人需要访问它。尽管如此，Ring Buffer 还是与消费端一样提供了一个 ProducerBarrier 对象，让生产者通过它来写入 Ring Buffer。</p>
<p>写入 Ring Buffer 的过程涉及到两阶段提交 (two-phase commit)。首先，你的生产者需要申请 buffer 里的下一个节点。然后，当生产者向节点写完数据，它将会调用 ProducerBarrier 的 commit 方法。</p>
<p>那么让我们首先来看看第一步。 “给我 Ring Buffer 里的下一个节点”，这句话听起来很简单。的确，从生产者角度来看它很简单：简单地调用 ProducerBarrier 的 nextEntry() 方法，这样会返回给你一个 Entry 对象，这个对象就是 Ring Buffer 的下一个节点。</p>
<p><strong>ProducerBarrier 如何防止 Ring Buffer 重叠</strong></p>
<p>在后台，由 ProducerBarrier 负责所有的交互细节来从 Ring Buffer 中找到下一个节点，然后才允许生产者向它写入数据。</p>
<p><img src="../../../../asserts/s_782643296.jpeg" alt="img"></p>
<p>（我不确定 闪闪发亮的新手写板 能否有助于提高我画图片的清晰度，但是它用起来很有意思）。</p>
<p>在这幅图中，我们假设只有一个生产者写入 Ring Buffer。过一会儿我们再处理多个生产者的复杂问题。</p>
<p><strong>ConsumerTrackingProducerBarrier</strong> 对象拥有所有正在访问 Ring Buffer 的 <strong>消费者</strong> 列 表。这看起来有点儿奇怪－我从没有期望 ProducerBarrier 了解任何有关消费端那边的事情。但是等等，这是有原因的。因为我们不想与队列“混为一谈”（队列需要追踪队列的头和尾，它们有时候会指向相同的位 置），Disruptor 由消费者负责通知它们处理到了哪个序列号，而不是 Ring Buffer。所以，如果我们想确定我们没有让 Ring Buffer 重叠，需要检查所有的消费者们都读到了哪里。</p>
<p>在上图中，有一个 <strong>消费者</strong> 顺利的读到了最大序号 12（用红色/粉色高亮）。第二个<strong>消费者</strong> 有点儿落后——可能它在做 I/O 操作之类的——它停在序号 3。因此消费者 2 在赶上消费者 1 之前要跑完整个 Ring Buffer 一圈的距离。</p>
<p>现在生产者想要写入 Ring Buffer 中序号 3 占据的节点，因为它是 Ring Buffer 当前游标的下一个节点。但是 ProducerBarrier 明白现在不能写入，因为有一个消费者正在占用它。所以，ProducerBarrier 停下来自旋 (spins)，等待，直到那个消费者离开。</p>
<p><strong>申请下一个节点</strong></p>
<p>现在可以想像消费者 2 已经处理完了一批节点，并且向前移动了它的序号。可能它挪到了序号 9（因为消费端的批处理方式，现实中我会预计它到达 12，但那样的话这个例子就不够有趣了）。</p>
<p><img src="../../../../asserts/aegbsvty487.jpeg" alt="img"></p>
<p>上图显示了当消费者 2 挪动到序号 9 时发生的情况。在这张图中我已经忽略了ConsumerBarrier，因为它没有参与这个场景。</p>
<p>ProducerBarier 会看到下一个节点——序号 3 那个已经可以用了。它会抢占这个节点上的 Entry（我还没有特别介绍 Entry 对象，基本上它是一个放写入到某个序号的 Ring Buffer 数据的桶），把下一个序号（13）更新成 Entry 的序号，然后把 Entry 返回给生产者。生产者可以接着往 Entry 里写入数据。</p>
<p><strong>提交新的数据</strong></p>
<p>两阶段提交的第二步是——对，提交。</p>
<p><img src="../../../../asserts/zqr0ggvq716.jpeg" alt="img"></p>
<p>绿色表示最近写入的 Entry，序号是 13 ——厄，抱歉，我也是红绿色盲。但是其他颜色甚至更糟糕。</p>
<p>当生产者结束向 Entry 写入数据后，它会要求 ProducerBarrier 提交。</p>
<p>ProducerBarrier 先等待 Ring Buffer 的游标追上当前的位置（对于单生产者这毫无意义－比如，我们已经知道游标到了 12 ，而且没有其他人正在写入 Ring Buffer）。然后 ProducerBarrier 更新 Ring Buffer 的游标到刚才写入的 Entry 序号－在我们这儿是 13。接下来，ProducerBarrier 会让消费者知道 buffer 中有新东西了。它戳一下 ConsumerBarrier 上的 WaitStrategy 对象说－“喂，醒醒！有事情发生了！”（注意－不同的 WaitStrategy 实现以不同的方式来实现提醒，取决于它是否采用阻塞模式。）</p>
<p>现在消费者 1 可以读 Entry 13 的数据，消费者 2 可以读 Entry 13 以及前面的所有数据，然后它们都过得很 happy。</p>
<p><strong>ProducerBarrier 上的批处理</strong></p>
<p>有趣的是 Disruptor 可以同时在生产者和 消费者 两端实现批处理。还记得伴随着程序运行，消费者 2 最后达到了序号 9 吗？ProducerBarrier 可以在这里做一件很狡猾的事－它知道 Ring Buffer 的大小，也知道最慢的消费者位置。因此它能够发现当前有哪些节点是可用的。</p>
<p><img src="../../../../asserts/5dct1vbs169.jpeg" alt="img"></p>
<p>如果 ProducerBarrier 知道 Ring Buffer 的游标指向 12，而最慢的消费者在 9 的位置，它就可以让生产者写入节点 3，4，5，6，7 和 8，中间不需要再次检查消费者的位置。</p>
<p><strong>多个生产者的场景</strong></p>
<p>到这里你也许会以为我讲完了，但其实还有一些细节。</p>
<p>在上面的图中我稍微撒了个谎。我暗示了 ProducerBarrier 拿到的序号直接来自 Ring Buffer 的游标。然而，如果你看过代码的话，你会发现它是通过 ClaimStrategy 获取的。我省略这个对象是为了简化示意图，在单个生产者的情况下它不是很重要。</p>
<p>在多个生产者的场景下，你还需要其他东西来追踪序号。这个序号是指当前可写入的序号。注意这和“向 Ring Buffer 的游标加 1”不一样－如果你有一个以上的生产者同时在向 Ring Buffer 写入，就有可能出现某些 Entry 正在被生产者写入但还没有提交的情况。</p>
<p><img src="../../../../asserts/ovuahxbw728.jpeg" alt="img"></p>
<p>让我们复习一下如何申请写入节点。每个生产者都向 ClaimStrategy 申请下一个可用的节点。生产者 1 拿到序号 13，这和上面单个生产者的情况一样。生产者 2 拿到序号 14，尽管 Ring Buffer的当前游标仅仅指向 12。这是因为 ClaimSequence 不但负责分发序号，而且负责跟踪哪些序号已经被分配。</p>
<p>现在每个生产者都拥有自己的写入节点和一个崭新的序号。</p>
<p>我把生产者 1 和它的写入节点涂上绿色，把生产者 2 和它的写入节点涂上可疑的粉色－看起来像紫色。</p>
<p><img src="../../../../asserts/lfmwgd6g622.jpeg" alt="img"></p>
<p>现在假设生产者 1 还生活在童话里，因为某些原因没有来得及提交数据。生产者 2 已经准备好提交了，并且向 ProducerBarrier 发出了请求。</p>
<p>就像我们先前在 commit 示意图中看到的一样，ProducerBarrier 只有在 Ring Buffer 游标到达准备提交的节点的前一个节点时它才会提交。在当前情况下，游标必须先到达序号 13 我们才能提交节点 14 的数据。但是我们不能这样做，因为生产者 1 正盯着一些闪闪发光的东西，还没来得及提交。因此 ClaimStrategy 就停在那儿自旋 (spins)， 直到 Ring Buffer 游标到达它应该在的位置。</p>
<p><img src="../../../../asserts/m4n2n-h4811.jpeg" alt="img"></p>
<p>现在生产者 1 从迷糊中清醒过来并且申请提交节点 13 的数据（生产者 1 发出的绿色箭头代表这个请求）。ProducerBarrier 让 ClaimStrategy 先等待 Ring Buffer 的游标到达序号 12，当然现在已经到了。因此 Ring Buffer 移动游标到 13，让 ProducerBarrier 戳一下 WaitStrategy 告诉所有人都知道 Ring Buffer 有更新了。现在 ProducerBarrier 可以完成生产者 2 的请求，让 Ring Buffer 移动游标到 14，并且通知所有人都知道。</p>
<p>你会看到，尽管生产者在不同的时间完成数据写入，但是 Ring Buffer 的内容顺序总是会遵循 nextEntry() 的初始调用顺序。也就是说，如果一个生产者在写入 Ring Buffer 的时候暂停了，只有当它解除暂停后，其他等待中的提交才会立即执行。</p>
<p>呼——。我终于设法讲完了这一切的内容并且一次也没有提到内存屏障（Memory Barrier）。</p>
<p><strong>更新</strong>：最近的 RingBuffer 版本去掉了 Producer Barrier。如果在你看的代码里找不到 ProducerBarrier，那就假设当我讲“Producer Barrier”时，我的意思是“Ring Buffer”。</p>
<p><strong>更新2</strong>：注意 Disruptor 2.0 版使用了与本文不一样的命名。如果你对类名感到困惑，请阅读我写的Disruptor 2.0更新摘要。</p>
<p>原文链接：<a href="http://ifeve.com/dissecting-the-disruptor-writing-to-the-ring-buffer/" target="_blank" rel="noopener">http://ifeve.com/dissecting-the-disruptor-writing-to-the-ring-buffer/</a></p>
<p>译文链接：<a href="http://ifeve.com/disruptor-writing-ringbuffer/" target="_blank" rel="noopener">http://ifeve.com/disruptor-writing-ringbuffer/</a></p>
]]></content>
      <tags>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Disruptor（二）</title>
    <url>/2019/11/18/disruptor2/</url>
    <content><![CDATA[<p><strong>从Ringbuffer读取数据</strong></p>
<p>从上一篇文章中我们都了解了什么是Ring Buffer以及它是如何的特别。但遗憾的是，我还没有讲述如何使用Disruptor向Ring Buffer写数据和从Ring Buffer中读取数据。</p>
<p>从上一篇文章中我们都了解了什么是<strong>Ring Buffer</strong>以及它是如何的特别。但遗憾的是，我还没有讲述如何使用<strong>Disruptor</strong>向<strong>Ring Buffer</strong>写数据和从<strong>Ring Buffer</strong>中读取数据。</p>
<a id="more"></a>

<p><strong>ConsumerBarrier与消费者</strong></p>
<p>这里我要稍微反过来介绍，因为总的来说读取数据这一过程比写数据要容易理解。假设通过一些“魔法”已经把数据写入到<strong>Ring Buffer</strong>了，怎样从<strong>Ring Buffer</strong>读出这些数据呢？</p>
<p><img src="../../../../asserts/s_880211960.jpeg" alt="img"></p>
<p>(好，我开始后悔使用<strong>Paint/Gimp</strong> 了。尽管这是个购买绘图板的好借口，如果我继续写下去的话… <strong>UML</strong>界的权威们大概也在诅咒我的名字了。)</p>
<p>消费者(<strong>Consumer</strong>)是一个想从<strong>Ring Buffer</strong>里读取数据的线程，它可以访问<strong>ConsumerBarrier</strong>对象——这个对象由<strong>RingBuffer</strong>创建并且代表消费者与<strong>RingBuffer</strong>进行交互。就像<strong>Ring Buffer</strong>显然需要一个序号才能找到下一个可用节点一样，消费者也需要知道它将要处理的序号——每个消费者都需要找到下一个它要访问的序号。在上面的例子中，消费者处理完了<strong>Ring Buffer</strong>里序号<strong>8</strong>之前（包括<strong>8</strong>）的所有数据，那么它期待访问的下一个序号是<strong>9</strong>。</p>
<p>消费者可以调用<strong>ConsumerBarrier</strong>对象的<strong>waitFor()</strong>方法，传递它所需要的下一个序号.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> availableSeq = consumerBarrier.waitFor(nextSequence);</span><br></pre></td></tr></table></figure>

<p><strong>ConsumerBarrier</strong>返回<strong>RingBuffer</strong>的最大可访问序号——在上面的例子中是<strong>12</strong>。<strong>ConsumerBarrier</strong>有一个<strong>WaitStrategy</strong>方法来决定它如何等待这个序号，我现在不会去描述它的细节，代码的注释里已经概括了每一种<strong>WaitStrategy</strong>的优点和缺点 。</p>
<p><strong>接下来怎么做？</strong></p>
<p>接下来，消费者会一直原地停留，等待更多数据被写入<strong>Ring Buffer</strong>。并且，一旦数据写入后消费者会收到通知——节点<strong>9</strong>，<strong>10</strong>，<strong>11</strong>和<strong>12</strong> 已写入。现在序号<strong>12</strong>到了，消费者可以让<strong>ConsumerBarrier</strong>去拿这些序号节点里的数据了。</p>
<p><img src="../../../../asserts/neKawwjs561.jpeg" alt="img"></p>
<p>拿到了数据后，消费者(<strong>Consumer</strong>)会更新自己的标识(<strong>cursor</strong>)。</p>
<p>你应该已经感觉得到，这样做是怎样有助于平缓延迟的峰值了——以前需要逐个节点地询问“我可以拿下一个数据吗？现在可以了么？现在呢？”，消费者(<strong>Consumer</strong>)现在只需要简单的说“当你拿到的数字比我这个要大的时候请告诉我”，函数返回值会告诉它有多少个新的节点可以读取数据了。因为这些新的节点的确已经写入了数据（<strong>Ring Buffer</strong>本身的序号已经更新），而且消费者对这些节点的唯一操作是读而不是写，因此访问不用加锁。这太好了，不仅代码实现起来可以更加安全和简单，而且不用加锁使得速度更快。</p>
<p>另一个好处是——你可以用多个消费者(<strong>Consumer)</strong>去读同一个<strong>RingBuffer</strong> ，不需要加锁，也不需要用另外的队列来协调不同的线程(消费者)。这样你可以在<strong>Disruptor</strong>的协调下实现真正的并发数据处理。</p>
<p><strong>BatchConsumer</strong>代码是一个消费者的例子。如果你实现了<strong>BatchHandler,</strong> 你可以用<strong>BatchConsumer</strong>来完成上面我提到的复杂工作。它很容易对付那些需要成批处理的节点（例如上文中要处理的<strong>9-12</strong>节点）而不用单独地去读取每一个节点。</p>
<p>更新：注意<strong>Disruptor 2.0</strong>版本使用了与本文不一样的命名。如果你对类名感到困惑，请阅读我的<strong>变更总结</strong>。</p>
<p>原文链接：<a href="http://ifeve.com/dissecting-the-disruptor-how-do-i-read-from-the-ring-buffer/" target="_blank" rel="noopener">http://ifeve.com/dissecting-the-disruptor-how-do-i-read-from-the-ring-buffer/</a></p>
<p>译文链接：<a href="http://ifeve.com/dissecting_the_disruptor_how_doi_read_from_the_ring_buffer/" target="_blank" rel="noopener">http://ifeve.com/dissecting_the_disruptor_how_doi_read_from_the_ring_buffer/</a></p>
]]></content>
      <tags>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Disruptor（一）</title>
    <url>/2019/11/18/disruptor1/</url>
    <content><![CDATA[<p><strong>Ringbuffer的特别之处</strong></p>
<p>首先介绍ringbuffer。我对Disruptor的最初印象就是ringbuffer。但是后来我意识到尽管ringbuffer是整个模式（Disruptor）的核心，但是Disruptor对ringbuffer的访问控制策略才是真正的关键点所在。</p>
<p>作者：Trisha 寒桐译</p>
<p>最近，我们开源了LMAX Disruptor， 它是我们的交易系统吞吐量快（LMAX是一个新型的交易平台，</p>
<a id="more"></a>

<p>号称能够单线程每秒处理数百万的订单）的关键原因。为什么我们要将其开源？我们意识到对高性能编程领域的一些传统观点，有点不对劲。我们找到了一种更好、更快地在线程间共享数据的方法，如果不公开于业界共享的话，那未免太自私了。同时开源也让我 们觉得看起来更酷。</p>
<p>从这个站点，你可以下载到一篇解释什么是Disruptor及它为什么如此高性能的文档。这篇文档的编写过程，我并没有参与太多，只是简单地插入了一些标点符号和重组了一些我不懂的句子，但是非常高兴的是，我仍然从中提升了自己的写作水平。</p>
<p>我发现要把所有的事情一下子全部解释清楚还是有点困难的，所有我准备一部分一部分地解释它们，以适合我的NADD听众。</p>
<p>首先介绍ringbuffer。我对Disruptor的最初印象就是ringbuffer。但是后来我意识到尽管ringbuffer是整个模式（Disruptor）的核心，但是Disruptor对ringbuffer的访问控制策略才是真正的关键点所在。</p>
<p><strong>ringbuffer到底是什么？</strong></p>
<p>嗯，正如名字所说的一样，它是一个环（首尾相接的环），你可以把它用做在不同上下文（线程）间传递数据的buffer。</p>
<p><img src="../../../../asserts/2407672373.jpeg" alt="img"></p>
<p>（好吧，这是我通过画图板手画的，我试着画草图，希望我的强迫症不会让我画完美的圆和直线）</p>
<p>基本来说，ringbuffer拥有一个序号，这个序号指向数组中下一个可用的元素。（校对注：如下图右边的图片表示序号，这个序号指向数组的索引4的位置。）</p>
<p><img src="../../../../asserts/mGPxPLmQ319.jpeg" alt="img"></p>
<p>随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。</p>
<p><img src="../../../../asserts/kysAIzvw325.jpeg" alt="img"></p>
<p>要找到数组中当前序号指向的元素，可以通过mod操作：</p>
<p>sequence mod array length = array index     </p>
<p>以上面的ringbuffer为例（java的mod语法）：12 % 10 = 2。很简单吧。</p>
<p>事实上，上图中的ringbuffer只有10个槽完全是个意外。如果槽的个数是2的N次方更有利于基于二进制的计算机进行计算。</p>
<p>（校对注：2的N次方换成二进制就是1000，100，10，1这样的数字， sequence &amp; （array length－1） = array index，比如一共有8槽，3&amp;（8－1）=3，HashMap就是用这个方式来定位数组元素的，这种方式比取模的速度更快。）</p>
<p><strong>那又怎么样？</strong></p>
<p>如果你看了维基百科里面的关于环形buffer的 词条，你就会发现，我们的实现方式，与其最大的区别在于：没有尾指针。我们只维护了一个指向下一个可用位置的序号。这种实现是经过深思熟虑的—我们选择用 环形buffer的最初原因就是想要提供可靠的消息传递。我们需要将已经被服务发送过的消息保存起来，这样当另外一个服务通过nak (校对注：拒绝应答信号)告诉我们没有成功收到消息时，我们能够重新发送给他们。</p>
<p>听起来，环形buffer非常适合这个场景。它维护了一个指向尾部的序号，当收到nak(校对注：拒绝应答信号)请求，可以重发从那一点到当前序号之间的所有消息：</p>
<p><img src="../../../../asserts/unA8JQ4Q654.jpeg" alt="img"></p>
<p>我们实现的ring buffer和大家常用的队列之间的区别是，我们不删除buffer中的数据，也就是说这些数据一直存放在buffer中，直到新的数据覆盖他们。这就是 和维基百科版本相比，我们不需要尾指针的原因。ringbuffer本身并不控制是否需要重叠（决定是否重叠是生产者-消费者行为模式的一部分–如果你等 不急我写blog来说明它们，那么可以自行检出<a href="https://code.google.com/p/disruptor/" target="_blank" rel="noopener">Disruptor项目</a>）。</p>
<p><strong>它为什么如此优秀？</strong></p>
<p>之所以ringbuffer采用这种数据结构，是因为它在可靠消息传递方面有很好的性能。这就够了，不过它还有一些其他的优点。</p>
<p>首先，因为它是数组，所以要比链表快，而且有一个容易预测的访问模式。（译者注：数组内元素的内存地址的连续性存储的）。这是对CPU缓存友好的—也就是说，在硬件级别，数组中的元素是会被预加载的，因此在ringbuffer当中，cpu无需时不时去主存加载数组中的下一个元素。（校对注：因为只要一个元素被加载到缓存行，其他相邻的几个元素也会被加载进同一个缓存行）</p>
<p>其次，你可以为数组预先分配内存，使得数组对象一直存在（除非程序终止）。这就意味着不需要花大量的时间用于垃圾回收。此外，不像链表那样，需要为每一个添加到其上面的对象创造节点对象—对应的，当删除节点时，需要执行相应的内存清理操作。</p>
<p><strong>缺少的部分</strong></p>
<p>我并没有在本文中介绍如何避免ringbuffer产生重叠，以及如何对ringbuffer进行读写操作。你可能注意到了我将ringbuffer和链表那样的数据结构进行比较，因为我并认为链表是实际问题的标准答案。</p>
<p>当你将Disruptor和基于 队列之类的实现进行比较时，事情将变得很有趣。队列通常注重维护队列的头尾元素，添加和删除元素等。所有的这些我都没有在ringbuffer里提到，这 是因为ringbuffer不负责这些事情，我们把这些操作都移到了数据结构（ringbuffer）的外部</p>
<p>原文链接：<a href="http://ifeve.com/ringbuffer/" target="_blank" rel="noopener">http://ifeve.com/ringbuffer/</a></p>
<p>译文链接：<a href="http://ifeve.com/dissecting-disruptor-whats-so-special/" target="_blank" rel="noopener">http://ifeve.com/dissecting-disruptor-whats-so-special/</a></p>
]]></content>
      <tags>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>TF-IDF算法介绍</title>
    <url>/2019/11/18/TF-IDF/</url>
    <content><![CDATA[<p><strong>TF-IDF是什么</strong></p>
<p>TF-IDF是一种统计方法，用以评估一个词对于一篇文章或语料库中一篇文章的重要性。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。</p>
<p><strong>TF-IDF的使用场景</strong></p>
<p>TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了TF-IDF以外，因特网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜寻结果中出现的顺序。</p>
<a id="more"></a>

<p><strong>TF-IDF原理</strong></p>
<ul>
<li>TF（Term Frequency) 表示词频，即一个词在在一篇文章中出现的次数，但在实际应用时会有一个漏洞，就是篇幅长的文章给定词出现的次数会更多一点。因此我们需要对次数进行归一化，通常用给定词的次数除以文章的总词数。</li>
</ul>
<p><img src="https://math.jianshu.com/math?formula=TF_w%20%3D%20%5Cfrac%7BC_w%7D%7BC%7D" alt="img"></p>
<p>这其中还有一个漏洞，就是 ”的“ ”是“ ”啊“ 等类似的词在文章中出现的此时是非常多的，但是这些大多都是没有意义词，对于判断文章的关键词几乎没有什么用处，我们称这些词为”停用词“，也就是说，在度量相关性的时候不应该考虑这些词的频率。</p>
<ul>
<li>IDF（Inverse Document Frequency）逆文本频率指数，如果包含关键词w的文档越少，则说明关键词w具有很好的类别区分能力。某一关键词的IDF，可以用总的文章数量除以包含该关键词的文章的数量，然后对结果取对数得到</li>
</ul>
<p><img src="https://math.jianshu.com/math?formula=IDF_w%20%3D%20%5Clog(%5Cfrac%7BC%7D%7BC_w%20%2B%201%7D)" alt="img"></p>
<p> 注：分母加1是为了避免没有包含关键词的文章时分母是0的情况</p>
<p>一个词预测主题的能力越强，权重就越大，反之，权重越小，因此一个词的TF-IDF就是：</p>
<p><img src="https://math.jianshu.com/math?formula=TF-IDF%20%3D%20TF*IDF" alt="img"></p>
<p><strong>实际应用</strong></p>
<p>通常在新闻的分类，或者说文章的分类的时候我们会用到ID-IDF。如果让编辑来对新闻或者文章分类，他一定要先读懂文章，然后找出主题，最后根据主题的不同对文章进行分类。而让电脑对文章进行分类，就要求我们先把文字的文章变成一组可以计算的数字，然后通过算法来算出文章的相似性。</p>
<p>首先我们先来看怎么用一组数字（或者说一个向量）来表示一篇文章。对于一篇文章的所有实词（除去无意义的停用词），计算出他们的TF-IDF值，把这些值按照对应的实词在词汇表的位置依次排列，就得到了一个向量。比如，词汇表中有64000个词，其编号和词：</p>
<table>
<thead>
<tr>
<th>单词编号</th>
<th>汉字词</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>阿</td>
</tr>
<tr>
<td>2</td>
<td>啊</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>789</td>
<td>服装</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>64000</td>
<td>做作</td>
</tr>
</tbody></table>
<p>在某一篇文章中，文章中的词的TF-IDF值对应为：</p>
<table>
<thead>
<tr>
<th>单词编号</th>
<th>TF-IDF</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0.0034</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>789</td>
<td>0.034</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>64000</td>
<td>0.075</td>
</tr>
</tbody></table>
<p>如果单词表的某个词在文章中没有出现，对应的值为零，这样我们就得到了一个64000维的向量，我们称为这篇文章的特征向量。然后每篇文章就可以用一个向量来表示，这样我们就可以计算文章之间的相似程度了。</p>
<p>向量的夹角是衡量两个向量相近程度的度量。因此，可以通过计算两篇文章的特征向量的夹角来判断两篇文章的主题的接近程度。那么我们就需要用余弦地理了。</p>
<p><img src="../../../../asserts/bdb304120a1.webp" alt="img"></p>
<p>∠A的余弦值为：</p>
<p><img src="https://math.jianshu.com/math?formula=cosA%20%3D%20%5Cfrac%7Bb%5E2%2Bc%5E2-a%5E2%7D%7B2bc%7D" alt="img"></p>
<p>如果将三角形的两边b和c看成是两个以A为起点的向量，那么上述公式等于：</p>
<p><img src="https://math.jianshu.com/math?formula=cosA%3D%5Cfrac%7B%3Cb%2Cc%3E%7D%7B%7Cb%7C%C2%B7%7Cc%7C%7D" alt="img"></p>
<p>其中，分母便是两个向量b和c的长度，分子表示两个向量的内积。假设文章X和文章Y对应的向量是</p>
<p><img src="https://math.jianshu.com/math?formula=X_1%2CX_2%2C...%2CX_%7B64000%7D%E5%92%8CY_1%2CY_2%2C...%2CY_%7B64000%7D" alt="img"></p>
<p>那么他们的夹角的余弦等于</p>
<p><img src="https://math.jianshu.com/math?formula=cos%CE%B8%3D%5Cfrac%7Bx_1y_1%2Bx_2y_2%2B...%2Bx_%7B64000%7Dy_%7B64000%7D%7D%7B%5Csqrt%7Bx_1%5E2%2Bx_2%5E2%2Bx_%7B64000%7D%5E2%7D%5Ccdot%5Csqrt%7By_1%5E2%2By_2%5E2%2By_%7B64000%7D%5E2%7D%7D" alt="img"></p>
<p>由于向量中的每一个变量都是正数，所以余弦的取值在0到1之间。当两篇文章向量的余弦等于1时，这两个向量夹角为零，两篇文章完全相同；当夹角的余弦接近于1时两篇文章越相似，从而可以归成一类；夹角的余弦越小，夹角越大，两篇文章越不相关。</p>
<p>现在假定我们已知一些文章的特征向量，那么对于任何一个要被分类的文章，就很容易计算出它和各类文章的余弦相似性，并将其归入它该去的那一类中。</p>
<p>如果事先没有已知的文章的特征向量呢，可以用自底向上不断合并的方法。</p>
<ol>
<li>计算所有文章之间凉凉的余弦相似性，把相似性大于一个阈值的合并成一小类</li>
<li>把每个小类中的所有文章作为一个整体，计算小类的特征向量，在计算小雷之间两两的余弦相似性，然后合并成一个大类</li>
</ol>
<p>这样不断做下去，类别越来越少，而每个类越来越大。当某一类太大时，这一类里的文章的相似性就很小了，这时就要停止迭代过程了，然后完成分类。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>工具网站收藏</title>
    <url>/2019/11/18/useful-website/</url>
    <content><![CDATA[<p><strong>Part1:前端工具</strong></p>
<p>【1】字体图标生成网站：IconMoon：<a href="https://icomoon.io/" target="_blank" rel="noopener">https://icomoon.io/</a></p>
<p>【2】reset 和 globle CSS：<a href="https://meyeerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">https://meyerweb.com/eric/tools/css/reset/</a></p>
<p>【3】阿里巴巴矢量图标库：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p>
<a id="more"></a>

<p>【4】EChart：<a href="https://echarts.baidu.com/" target="_blank" rel="noopener">https://echarts.baidu.com/</a></p>
<p>【5】iView：<a href="https://www.iviewui.com/" target="_blank" rel="noopener">https://www.iviewui.com/</a></p>
<p><strong>Part2:视频教程</strong></p>
<p>【1】慕课网：<a href="https://www.imooc.com/" target="_blank" rel="noopener">https://www.imooc.com/</a></p>
<p>【2】Siki学院：<a href="http://www.sikiedu.com/" target="_blank" rel="noopener">http://www.sikiedu.com/</a></p>
<p>【3】Bilibili：<a href="https://www.bilibili.com/" target="_blank" rel="noopener">https://www.bilibili.com/</a></p>
<p><strong>Part3:实用网站</strong></p>
<p>【1】国家哲学社会科学文献中心：<a href="http://www.ncpssd.org" target="_blank" rel="noopener">http://www.ncpssd.org</a></p>
<p>【2】MSDN，我告诉你： <a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派镜像制作</title>
    <url>/2019/11/18/raspberry-blog1/</url>
    <content><![CDATA[<p><strong>【1】树莓派原始镜像烧录。</strong></p>
<p><strong>【2】中文字库以及中文拼音输入法下载：</strong></p>
<p>启动后，开启Terminal终端，出现提示符时输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-zenhei</span><br></pre></td></tr></table></figure>

 <a id="more"></a> 

<p>将安装文泉驿的开源中文字体，在这里向文泉驿表示致敬，貌似它是唯一一个开源的中文字体库。郭嘉有钱建孔子学院，但是从来不会有钱搞一套比较完整的开源中文字库出来的。</p>
<p>中文是可以显示啦，输入呢？Linux下早就有啦，叫SCIM（Smart Common Input Method ），所以只要输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install scim-pinyin</span><br></pre></td></tr></table></figure>

<p>就会安装拼音输入法，安装完成后，可以直接打入scim激活，下次启动是会自动启动的。快捷键也是Ctrl+空格。或者直接点击右下角图标选择。</p>
<p>接着运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>

<p>然后选择change_locale，在Default locale for the system environment:中选择zh_CN.UTF-8。然后重启机器，就发现整个环境变成中文的了。</p>
<p><strong>【3】安装 Pi4j：</strong></p>
<p><strong>Installation</strong></p>
<p><strong>Easy/Preferred</strong></p>
<p>(NOTE: This installation method requires that your RaspberryPi is connected to the Internet.)</p>
<p>The simplest method to install Pi4J on your RaspberryPi is to execute the following command directly on your RaspberryPi.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s get.pi4j.com | sudo bash</span><br></pre></td></tr></table></figure>

<p>This method will download and launch an installation script that perform the following steps:</p>
<ol>
<li>adds the Pi4J APT repository to the local APT repositories</li>
<li>downloads and installs the Pi4J GPG public key for signature validation</li>
<li>invokes the ‘apt-get update’ command on the Pi4J APT repository to update the local package database</li>
<li>invokes the ‘apt-get install pi4j’ command to perform the download and installation</li>
</ol>
<p><strong>Offline/Manual</strong></p>
<p>If you prefer/need to install Pi4J on a RaspberryPi device without an Internet connection, the following instructions provide the steps necessary to install Pi4J without requiring an Internet connection.</p>
<p>First, download a copy of the latest Pi4J Debian/Raspian installer package (.deb) file to your local computer. You can download the Pi4J Debian/Raspian installer package (.deb) using your web browser at the following URL: </p>
<p><a href="http://get.pi4j.com/download/pi4j-1.2-SNAPSHOT.deb" target="_blank" rel="noopener">http://get.pi4j.com/download/pi4j-1.2-SNAPSHOT.deb</a></p>
<p>Next, you will need to transfer the download installer package over to your RaspberryPi. You can use any method you prefer to transfer the file (USB, SCP, FTP, etc.)</p>
<p>(NOTE: If you have a previous version of Pi4J installed, you will need to uninstall it first.)</p>
<p>Once the installer package is available on your RaspberryPi, use the following command on the Pi to perform the installation: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i pi4j-1.2-SNAPSHOT.deb</span><br></pre></td></tr></table></figure>

<p><strong>Upgrade</strong></p>
<p><strong>Easy/Preferred</strong></p>
<p>If you originally installed Pi4J using the <em>‘easy’</em> method, then Pi4J upgrades will be available anytime you perform a system update using ‘sudo apt-get update’ and ‘sudo update-get upgrade’.</p>
<p>If you wish to force an upgrade of the Pi4J package only, you can do so by executing the following command: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install pi4j or pi4j --update</span><br></pre></td></tr></table></figure>

<p><strong>Offline/Manual</strong></p>
<p>If you originally installed Pi4J using the <em>‘offline’</em> method, then you will need to manually uninstall the Pi4J package and download, transfer, and install the new version package using the ‘offline’ uninstall and installation methods described here on this page.</p>
<p><strong>Uninstall</strong></p>
<p><strong>Easy/Preferred</strong></p>
<p>If you originally installed Pi4J using the <em>‘easy’</em> method, then you can uninstall Pi4J simply by executing the following command on your RaspberryPi. </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove pi4j or pi4j --uninstall</span><br></pre></td></tr></table></figure>

<p><strong>Complete/Full Removal</strong></p>
<p>If you originally installed Pi4J using the <em>‘easy’</em> method and you want to remove all traces of Pi4J, including the Pi4J repository in the APT repositories list and the Pi4J GPG signature, then simply execute the following command on your RaspberryPi. </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s get.pi4j.com/uninstall | sudo bash</span><br></pre></td></tr></table></figure>

<p><strong>Offline/Manual</strong></p>
<p>If you originally installed Pi4J using the <em>‘offline’</em> method, then you will need to manually uninstall the Pi4J package by executing the following command on your Raspberry Pi: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -r pi4j</span><br></pre></td></tr></table></figure>

<p><strong>Installed Location / Example Files</strong></p>
<p>This will install the Pi4J libraries and example source files to: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/pi4j/lib </span><br><span class="line">/opt/pi4j/examples</span><br></pre></td></tr></table></figure>

<p>When attempting to compile a Java program using the Pi4J libraries, make sure to include the Pi4J lib folder in the classpath: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac -classpath .:classes:/opt/pi4j/lib/'*' ...</span><br></pre></td></tr></table></figure>

<p>When attempting to start a Java program using the Pi4J libraries, make sure to include the Pi4J lib folder in the classpath: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo java -classpath .:classes:/opt/pi4j/lib/'*' ...</span><br></pre></td></tr></table></figure>

<p>If you would like to explore the examples, you can compile all the examples with the following commands: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/pi4j/examples/build</span><br></pre></td></tr></table></figure>

<p><strong>Pi4j官网:</strong><a href="https://pi4j.com" target="_blank" rel="noopener">https://pi4j.com</a></p>
<p><strong>【4】安装 JavaFX 插件包：</strong></p>
<p>As you can read <a href="https://stackoverflow.com/questions/28284239/javafx-ensemble-on-raspberry-pi/28284736#28284736" target="_blank" rel="noopener">here</a>, the most recent JDK versions for ARM don’t include JavaFX.</p>
<p>If you want to use JavaFX in your Raspberry Pi, the solution is adding the missing JavaFX SDK.</p>
<p>If you install the recent Oracle’s JDK for ARM from <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">here</a> (select jdk-8u111-linux-arm32-vfp-hflt.tar.gz), then you will need to download the JavaFX SDK from Gluon’s <a href="http://gluonhq.com/labs/javafxports/get/" target="_blank" rel="noopener">site</a> (select JavaFX Embedded SDK for armv6 hard float).</p>
<p>Once you have the file, unzip it, and copy the folders to your JDK.</p>
<p>Assuming you have downloaded armv6hf-sdk-8.60.8.zip to your Pi/Downloads folder, and you have unzip it to a folder armv6hf-sdk, like in the following picture:</p>
<p><img src="../../../../asserts/sQzdd.png" alt="Pi ARM JavaFX"></p>
<p>using the following commands will allow you moving from command line the files to the JDK required folders. You can use a graphic tool for this as well.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd Downloads </span><br><span class="line">sudo chown -R root:root armv6hf-sdk </span><br><span class="line">cd armv6hf-sdk </span><br><span class="line">sudo mv lib/javafx-mx.jar /opt/jdk1.8.0_111/lib/ </span><br><span class="line">cd rt/lib/ </span><br><span class="line">sudo mv j* /opt/jdk1.8.0_111/jre/lib/ </span><br><span class="line">sudo mv arm/* /opt/jdk1.8.0_111/jre/lib/arm/ </span><br><span class="line">sudo mv ext/* /opt/jdk1.8.0_111/jre/lib/ext/</span><br></pre></td></tr></table></figure>

<p>After that you should be able to run Java/JavaFX programs.</p>
<p><strong>参考链接:</strong><a href="https://stackoverflow.com/questions/40481455/running-javafx-gui-on-the-raspberry-pi/40483500#40483500" target="_blank" rel="noopener">https://stackoverflow.com/questions/40481455/running-javafx-gui-on-the-raspberry-pi/40483500#40483500</a></p>
<p><strong>【5】解决树莓派图形渲染问题：</strong></p>
<p><a href="https://www.raspberrypi.org/forums/viewtopic.php?f=81&t=60024#p448200" target="_blank" rel="noopener">JavaFX glGetError 0x505</a></p>
<p>You can try increase the available raspberry pi video memory using the <strong>sudo raspi-config</strong> tool. try change to the 50/50 memory spit.</p>
<p><strong>参考链接</strong>:<a href="https://www.raspberrypi.org/forums/viewtopic.php?f=81&amp;t=60024#p448200" target="_blank" rel="noopener">https://www.raspberrypi.org/forums/viewtopic.php?f=81&amp;t=60024#p448200</a></p>
<p><strong>【6】树莓派播放视频：</strong></p>
<p>WebView and Media were never part of the JavaFX ARM distribution, but Gluon recently added it to the embedded SDK that can be downloaded from <a href="http://gluonhq.com/labs/javafxports/get/" target="_blank" rel="noopener">here</a> and installed with a recent JDK for ARM, available <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">here</a>.</p>
<p>Media requires a few extra steps as it depends in the native drivers that usually are not fully installed on a regular Jessie distribution.</p>
<p>First install these drivers:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gstreamer0.10-plugins-good </span><br><span class="line">sudo apt-get install gstreamer0.10-plugins-bad</span><br></pre></td></tr></table></figure>

<p>Now edit /etc/apt/sources.list and add at the end:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://ftp.uk.debian.org/debian/ wheezy main deb-src http://ftp.uk.debian.org/debian/ wheezy main</span><br></pre></td></tr></table></figure>

<p>Save the file (Ctrl+O, Ctrl+X).</p>
<p>Finally update and install the drivers:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update </span><br><span class="line">sudo apt-get install gstreamer0.10-ffmpeg </span><br><span class="line">sudo apt-get install gstreamer0.10-alsa</span><br></pre></td></tr></table></figure>

<p>Now you can try to run again your JavaFX application.</p>
<p>If you find again the same exception (MediaException: UNKNOWN), check if it shows this message: Error in GstPipelineFactory, notice the driver that is missing, and try to install it.</p>
<p><strong>参考链接:</strong><a href="https://stackoverflow.com/questions/42076680/play-a-video-using-javafx-on-raspberry-pi" target="_blank" rel="noopener">https://stackoverflow.com/questions/42076680/play-a-video-using-javafx-on-raspberry-pi</a></p>
<p><strong>【7】常用的设置树莓派自启动的方法：</strong></p>
<p>这个方式不用修改 rc.local 文件。机制上类似于 Windows 的“开始”菜单中的“启动”菜单。方法如下：</p>
<p>在 /home/pi/.config 下创建一个文件夹，名称为 autostart，并在该文件夹下创建一个xxx.desktop文件（文件名以.desktop结尾，前面可以自定义），文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Desktop Entry] </span><br><span class="line">Name=example </span><br><span class="line">Comment=My Python Program </span><br><span class="line">Exec=python /home/pi/example.py </span><br><span class="line">Icon=/home/pi/example.png </span><br><span class="line">Terminal=false </span><br><span class="line">MultipleArgs=false </span><br><span class="line">Type=Application </span><br><span class="line">Categories=Application;Development; </span><br><span class="line">StartupNotify=true</span><br></pre></td></tr></table></figure>

<p>以上 Name、Comment、Icon 可以自定，分别表示这个启动项目的名称、备注以及显示的图标。Exec 表示调用的指令，和在终端输入运行脚本的指令格式一致。</p>
<p><strong>参考链接</strong>：<a href="https://www.jianshu.com/p/1a160067d8fd" target="_blank" rel="noopener">https://www.jianshu.com/p/1a160067d8fd</a></p>
<p><strong>【8】用树莓派播放视频：</strong></p>
<p>树莓派上可以播放 H264 和 mp4 等视频格式，1080p也没问题，因为这种格式的文件有硬件加速。</p>
<p>首先安装 安装 omxplayer ，这是一个命令行的播放器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install omxplayer</span><br></pre></td></tr></table></figure>

<p>然后就可以播放了，当然需要通过 HDMI 连接到显示器看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">omxplayer -o hdmi /path/to/filename.mp4</span><br></pre></td></tr></table></figure>

<p>-o hdmi 表示音频直接通过 HDMI 播放，播放时按左右箭头快进、按 q 退出。</p>
<p>更多命令行选项和播放时的控制快捷键请参考 <a href="https://github.com/huceke/omxplayer" target="_blank" rel="noopener">omxplayer 的文档</a>。</p>
<p><strong>【9】树莓派安装 JDK：</strong></p>
<p>首先是安装JDK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install oracle-java8-jdk</span><br></pre></td></tr></table></figure>

<p>也可以在<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-arm-downloads-2187468.html" target="_blank" rel="noopener">这个地方</a>下载</p>
<p>修改环境变量，我用的版本是JDK8，arm版HFLT，代表arm架构硬件浮点运算，放在/usr/lib/jvm/jdk-8-oracle-arm-vfp-hflt这个文件夹了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/profile</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">[cc lang=<span class="string">"php"</span>]</span><br><span class="line"><span class="comment">#set java environment</span></span><br><span class="line">JAVA_HOME=/usr/lib/jvm/jdk<span class="number">-8</span>-oracle-arm-vfp-hflt</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tool</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME CLASSPATH PATH</span><br><span class="line">[/cc]</span><br></pre></td></tr></table></figure>

<p>接下来是重启树莓派，看看版本号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>



<p><strong>【10】树莓派去黑边：</strong></p>
<p>在使用树莓派连接HDMI电脑显示器的时候，可能会出现屏幕显示不全，有黑边的情况。这时候需要调节分辨率以适应屏幕。</p>
<p>进入树莓派系统，输入以下指令设置config.txt文件： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /boot/config.txt</span><br></pre></td></tr></table></figure>

<p>调节任何参数时，将#号去除即可生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uncomment to force a specific HDMI mode (this will force VGA) </span></span><br><span class="line">hdmi_group=2  //将显示模式切换成DMT（显示器模式） </span><br><span class="line">hdmi_mode=82  //1920x1080   60Hz    1080p</span><br></pre></td></tr></table></figure>

<p>如果显示器不是1080P。则可以参考注1参数修改 </p>
<p>这时候就将显示设置成1080P的分辨率，但是是不带声音的，如果你的显示器支持HDMI声音输出或者自带音响，则将如下代码参数去除#号解锁强制获取声音。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uncomment to force a HDMI mode rather than DVI. This can make audio work <span class="keyword">in</span> <span class="comment"># DMT (computer monitor) </span></span></span><br><span class="line">modes hdmi_drive=2  //HDMI模式</span><br></pre></td></tr></table></figure>

<p>更多设置参考官方配置文档：<a href="https://www.raspberrypi.org/documentation/configuration/config-txt.md" target="_blank" rel="noopener">https://www.raspberrypi.org/documentation/configuration/config-txt.md</a></p>
<p>注1： DMT模式分辨率参数</p>
<table>
<thead>
<tr>
<th>hdmi_mode</th>
<th>resolution</th>
<th>frequency</th>
<th>notes</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>640x350</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>640x400</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>720x400</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>640x480</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>640x480</td>
<td>72Hz</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>640x480</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>640x480</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>800x600</td>
<td>56Hz</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>800x600</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>800x600</td>
<td>72Hz</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>800x600</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>800x600</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>800x600</td>
<td>120Hz</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>848x480</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>1024x768</td>
<td>43Hz</td>
<td>incompatible with the Raspberry Pi</td>
</tr>
<tr>
<td>16</td>
<td>1024x768</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>1024x768</td>
<td>70Hz</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>1024x768</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>1024x768</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>1024x768</td>
<td>120Hz</td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>1152x864</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>1280x768</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>23</td>
<td>1280x768</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>1280x768</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>1280x768</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>1280x768</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>27</td>
<td>1280x800</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>28</td>
<td>1280x800</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>1280x800</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>1280x800</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>1280x800</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>32</td>
<td>1280x960</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>1280x960</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>34</td>
<td>1280x960</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>35</td>
<td>1280x1024</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>1280x1024</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>37</td>
<td>1280x1024</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>1280x1024</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>39</td>
<td>1360x768</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>1360x768</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>41</td>
<td>1400x1050</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>42</td>
<td>1400x1050</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>43</td>
<td>1400x1050</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>44</td>
<td>1400x1050</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>45</td>
<td>1400x1050</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>46</td>
<td>1440x900</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>47</td>
<td>1440x900</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>48</td>
<td>1440x900</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>49</td>
<td>1440x900</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>50</td>
<td>1440x900</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>51</td>
<td>1600x1200</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>52</td>
<td>1600x1200</td>
<td>65Hz</td>
<td></td>
</tr>
<tr>
<td>53</td>
<td>1600x1200</td>
<td>70Hz</td>
<td></td>
</tr>
<tr>
<td>54</td>
<td>1600x1200</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>55</td>
<td>1600x1200</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>56</td>
<td>1600x1200</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>57</td>
<td>1680x1050</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>58</td>
<td>1680x1050</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>59</td>
<td>1680x1050</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>60</td>
<td>1680x1050</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>61</td>
<td>1680x1050</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>62</td>
<td>1792x1344</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>63</td>
<td>1792x1344</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>64</td>
<td>1792x1344</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>65</td>
<td>1856x1392</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>66</td>
<td>1856x1392</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>67</td>
<td>1856x1392</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>68</td>
<td>1920x1200</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>69</td>
<td>1920x1200</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>70</td>
<td>1920x1200</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>71</td>
<td>1920x1200</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>72</td>
<td>1920x1200</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>73</td>
<td>1920x1440</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>74</td>
<td>1920x1440</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>75</td>
<td>1920x1440</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>76</td>
<td>2560x1600</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>77</td>
<td>2560x1600</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>78</td>
<td>2560x1600</td>
<td>75Hz</td>
<td></td>
</tr>
<tr>
<td>79</td>
<td>2560x1600</td>
<td>85Hz</td>
<td></td>
</tr>
<tr>
<td>80</td>
<td>2560x1600</td>
<td>120Hz</td>
<td>reduced blanking</td>
</tr>
<tr>
<td>81</td>
<td>1366x768</td>
<td>60Hz</td>
<td></td>
</tr>
<tr>
<td>82</td>
<td>1920x1080</td>
<td>60Hz</td>
<td>1080p</td>
</tr>
<tr>
<td>83</td>
<td>1600x900</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>84</td>
<td>2048x1152</td>
<td></td>
<td>reduced blanking</td>
</tr>
<tr>
<td>85</td>
<td>1280x720</td>
<td>60Hz</td>
<td>720p</td>
</tr>
<tr>
<td>86</td>
<td>1366x768</td>
<td></td>
<td>reduced blanking</td>
</tr>
</tbody></table>
<p><strong>【11】OmxPlayer 调节声音大小：</strong></p>
<p>to provide more precise information for playing through scripts, there are 3 ways to change sound volume in current version of omxplayer, and values are not so intuitive:</p>
<ol>
<li>on starting command line, param –vol YYY, double millibels, default 0, range [-6000:0]</li>
<li>by stdin interface, sending +/- to omxplayer will increase/decrease volume for 300 dmbels</li>
<li>with DBUS interface, cmd ‘set volume’, value double:XXX, default 1, range [0:1]</li>
</ol>
<p>xxx to yyy relation is: XXX = 10 ^ (YYY / 2000) … according to <a href="https://github.com/popcornmix/omxplayer/blob/350779b00bb7278e0d1d9025b9ed1ddb4a2d99cd/omxplayer.cpp#L1166" target="_blank" rel="noopener">omxplayer.cpp</a> source code, reverse formula would be: YYY = 2000 * (log XXX).</p>
<p>so if we need:</p>
<ul>
<li>volume 1%, XXX=0.01 and YYY=-4000 (10^(-4000/2000)=10^-2=0.01</li>
<li>volume 10%, XXX=0.1 and YYY=-2000 (10^(-2000/2000)=10^-1=0.1</li>
<li>volume 50%, XXX=0.5 and YYY=-602 (10^(-602/2000))~=0.5</li>
<li>volume 100%, XXX=1 and YYY=0 (10^(0/2000)=10^0=1)</li>
<li>volume 150%, XXX=1.5 and YYY=352 … (for boost test, normal values are &lt;=100%)</li>
</ul>
<p>working bash script for dbus volume command:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export DBUS_SESSION_BUS_ADDRESS=$(cat /tmp/omxplayerdbus.$&#123;USER:-root&#125;) \</span><br><span class="line">dbus-send --print-reply --session --reply-timeout=500 \           </span><br><span class="line">		  --dest=org.mpris.MediaPlayer2.omxplayer \           			</span><br><span class="line"> 		  /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Set\  </span><br><span class="line">		  string:"org.mpris.MediaPlayer2.Player" \           </span><br><span class="line"> 		  string:"Volume" double:0.5   # &lt;-- XXX=0.5 (50% sound volume)</span><br></pre></td></tr></table></figure>

<p>equals to volume parameter at startup:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">omxplayer --vol -602 mediaFileName.mp4</span><br></pre></td></tr></table></figure>

<p>… both sets sound volume to 50%.</p>
<p><strong>【12】树莓派设置不休眠的方法</strong></p>
<p>树莓派长时间没人操作时，会自动进入休眠状态，这是因为长时间无操作触发linux的节电休眠机制。所以当树莓派运行后台程序，比如用树莓派看视频时，时间一长就会自动黑屏，树莓派自动进入休眠状态。</p>
<p>怎么设置树莓派不休眠，其实通过建立和设置内置文件就行了，很简单。</p>
<p>以下是防止树莓派休眠的设置步骤：</p>
<p>1、用管理员root账户登录树莓派，在文件夹/etc/profile.d/里面新建内置文件screen.sh。</p>
<p>2、编辑文件screen.sh，写入以下两行内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xset dpms 0 0 0</span><br><span class="line">xset s off</span><br></pre></td></tr></table></figure>

<p>保存文件。</p>
<p>3、重启树莓派，就能实现永久禁用树莓派休眠。</p>
<p><strong>【13】树莓派中的GPU渲染内存设置</strong></p>
<p>为了平衡树莓派CPU运行内存和GPU渲染内存，将GPU的MemorySplit设置成320M这个经验值（总内存1GB，GPU分得320M，则CPU持有704M）是一个不错的选择，设置方法如下：</p>
<p>raspi-config&gt;&gt;Advanced Options&gt;&gt;Memory Split&gt;&gt;更改内存为320</p>
]]></content>
      <tags>
        <tag>raspberry</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<a id="more"></a>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
